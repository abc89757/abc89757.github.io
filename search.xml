<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021-10-26每日刷题打卡</title>
      <link href="/2021/10/26/2021-10-26-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/26/2021-10-26-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-26每日刷题打卡"><a href="#2021-10-26每日刷题打卡" class="headerlink" title="2021-10-26每日刷题打卡"></a>2021-10-26每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p><p>这题有两个方法，第一种节省空间但速度慢，第二种速度快但占用空间较多</p><p>第一种：创建一个vector容器v来存放结果，直接for遍历nums1，里面再放上一个for用来遍历nums2，每次遍历nums1新的元素时去nums2里找到和当前nums1相同的元素，找到以后继续遍历，如果有大于它的数就把那个数插入v中并break结束循环，如果没有大于他的数就插入一个-1。当nums1遍历完后结束循环，返回v即可</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;int&gt;v;        int n&#x3D;nums1.size(),m&#x3D;nums2.size();        bool b&#x3D;false;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            for(int j&#x3D;0;j&lt;m;j++)            &#123;                if(b&amp;&amp;nums2[j]&gt;nums1[i])                &#123;                    v.push_back(nums2[j]);                    break;                &#125;                if(nums1[i]&#x3D;&#x3D;nums2[j])                &#123;                    b&#x3D;true;                &#125;            &#125;            b&#x3D;false;            if(v.size()&#x3D;&#x3D;i)            &#123;                v.push_back(-1);            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种：要用上map、stack的知识，准备一个unordered_map容器mymap，一个stack容器sta，一个vector容器v。先遍历nums2，从最后一个元素开始遍历，每次遍历判断栈sta顶部元素是否小于当前元素，如果小于就持续出栈，知道栈为空或顶端元素大于当前遍历元素，然后mymap开始记录当前元素之后有无最大值，mymap[nums2[i]]==sta.empty?-1:sta.top()，这里意思是，如果栈为空，说明我们之前遍历过的元素没有大于当前元素的（因为都在前面出栈弹掉了），如果栈不为空，就说明栈顶元素是大于我们当前元素的，把这个元素赋给mymap，事后要将当前元素入栈。遍历完后开始遍历nums1，每次经由mymap[nums[i]]获知当前元素之后有没有大于它的元素。把结果插入v中。最后返回v</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_map&lt;int,int&gt;mymap;        stack&lt;int&gt;sta;        vector&lt;int&gt;v;        int n&#x3D;nums1.size();        for(int i&#x3D;nums2.size()-1;i&gt;&#x3D;0;i--)        &#123;            int num &#x3D; nums2[i];            while(!sta.empty()&amp;&amp;sta.top()&lt;num)            &#123;                sta.pop();            &#125;            mymap[num]&#x3D;sta.empty()?-1:sta.top();            sta.push(num);        &#125;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            v.push_back(mymap[nums1[i]]);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h4><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>进阶：</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</p><p>示例 1:</p><p>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p><p>原本试了下看看能不能把O(1)的算法写出来，结果超时了。。。我还是写简单的吧</p><p>准备一个vector容器v，遍历一遍nums，每次在v的（i+k)%nums.size() 位置上放上nums[i]的值（%nums.size()是为了防止数组越界，同时把旋转后的数插入v前面的位置上。)，但由于这里没有返回值，是要修改nums里的值，所以我们遍历一遍v把值复制给nums。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        int n&#x3D;nums.size();        vector&lt;int&gt;v(n);        for(int i&#x3D;0;i&lt;n;i++)        &#123;            v[(i+k)%n]&#x3D;nums[i];        &#125;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            nums[i]&#x3D;v[i];        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个方法，利用队列queue来进行旋转操作（出队后入队）。准备一个queue容器que，将nums从尾部数据开始依次入队que（先进先出），然后把队头元素出队再入队，一个进行k次，之后队列里的位置就是旋转好的序列了，再把que的数据复制在nums里即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        queue&lt;int&gt;que;        int n &#x3D; nums.size();        int m &#x3D; k % n;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            que.push(nums[i]);        &#125;        while(m--)        &#123;            int num&#x3D;que.front();            que.pop();            que.push(num);        &#125;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            nums[i]&#x3D;que.front();            que.pop();        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h4><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>尽量减少不知道咋减少。。。嘛反正是没用额外的数组。</p><p>准备两个指针l和r，初始都为0，用两个指针来遍历nums，当l或r大于等于nums.size()时结束循环，如果l当前指向的位置数不为0，则l和r同时++，如果l指向的位置数为0，则r往前移动，直到nums[r]不为0，然后交换l和r位置上的元素（这里要注意r可能会超出nums.size()，所以要加判断如果r大于等于nums.size()就结束循环）。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;    int l &#x3D; 0, r &#x3D; 0, n &#x3D; nums.size();    while (r &lt; n)    &#123;        if (nums[l] !&#x3D; 0)        &#123;            l++;            r++;        &#125;        else        &#123;            while (r &lt; n&amp;&amp;nums[r] &#x3D;&#x3D; 0 )            &#123;                r++;                            &#125;            if (r &gt;&#x3D; n)            &#123;                break;            &#125;            int math &#x3D; nums[l];            nums[l] &#x3D; nums[r];            nums[r] &#x3D; math;        &#125;    &#125;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照 非递减顺序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p><p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p><p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p><p>示例 1：</p><p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p><p>双指针写法，因为这数组是递增的，所以我们可以用头尾双指针来写，一个left=0，一个right=numbers.size()-1，一个vector容器v，开始遍历，每次判断numbers[left]+numbers[right]的值，如果等于目标值就把left和right插入v中，break掉循环并返回v。如果大于目标值，说明number[right]的值过大（总不能是left太大，人家已经最小了），把right–以减小numbers[right]的值。如果小于目标值说明numbers[left]的值过下，把left++。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;        int i&#x3D;0,j&#x3D;numbers.size()-1;        vector&lt;int&gt;v;       while(i&lt;j)       &#123;           if(numbers[i]+numbers[j]&#x3D;&#x3D;target)           &#123;               v.push_back(i+1);               v.push_back(j+1);               break;           &#125;           else if(numbers[i]+numbers[j]&gt;target)           &#123;               j--;           &#125;           else           &#123;               i++;           &#125;       &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/25/hello-world/"/>
      <url>/2021/10/25/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到我的个人网站！"><a href="#欢迎来到我的个人网站！" class="headerlink" title="欢迎来到我的个人网站！"></a>欢迎来到我的个人网站！</h1>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HelloWorld </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
