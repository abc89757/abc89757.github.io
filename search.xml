<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>周总结：2021-11-01——11-07</title>
      <link href="/2021/11/07/zhou-zong-jie-2021-11-01-11-07/"/>
      <url>/2021/11/07/zhou-zong-jie-2021-11-01-11-07/</url>
      
        <content type="html"><![CDATA[<h1 id="周总结：2021-11-01——11-07"><a href="#周总结：2021-11-01——11-07" class="headerlink" title="周总结：2021-11-01——11-07"></a>周总结：2021-11-01——11-07</h1><h3 id="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"><a href="#这里是这一周来刷题时印象比较深的几道题，挑出来做个总结" class="headerlink" title="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"></a>这里是这一周来刷题时印象比较深的几道题，挑出来做个总结</h3><h4 id="449-序列化和反序列化二叉搜索树"><a href="#449-序列化和反序列化二叉搜索树" class="headerlink" title="449. 序列化和反序列化二叉搜索树"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h4><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p>编码的字符串应尽可能紧凑。</p><p>示例 1：</p><p>输入：root = [2,1,3]<br>输出：[2,1,3]</p><p>前序转字符串的方式就是递归，每次先判断当前节点是否为空，如果为空就往字符串上加一个标志性的字符来说明这是空结点，我这里用的是N（NULL），如果不为空，就把当前节点的val值转为字符串加在字符串上，然后再把该节点的左右子节点送去递归，注意每个节点的val值之间要用特殊的字符隔开，我用的是“，”。等递归完后所有的字符串都合在一起了，直接return即可。</p><p>字符串转换成二叉树的方式也是递归（递归真是个好东西），我们用自己写的dfs函数来完成递归，一共三个参数，字符串data，节点root和索引下标i（i和节点要以引用方式传递）。一开始i先为0在之后的递归里逐渐增加，每次先判断data[i]是否为“N”，如果是说明这里的节点应该为空，把当前节点指向空后直接结束程序，注意要把i+=2（跳过”，“）。如果不为N，那就先遍历字符串，当遇到”，“时结束遍历，再把遍历过的字符串转换成数字，这就是节点的val值，把值赋给root，然后送root的左右子节点去递归。当递归结束后我们得到的root就是最开始的二叉树了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Codec &#123;public:    &#x2F;&#x2F; Encodes a tree to a single string.    string serialize(TreeNode* root) &#123;        if(!root)return &quot;N&quot;;        return to_string(root-&gt;val)+&quot;,&quot;+serialize(root-&gt;left)+&quot;,&quot;+serialize(root-&gt;right);    &#125;    &#x2F;&#x2F; Decodes your encoded data to tree.    TreeNode* deserialize(string data) &#123;        TreeNode *root;        int i&#x3D;0;        dfs(data,i,root);        return root;    &#125;    void dfs(string data,int&amp; i,TreeNode*&amp; root)    &#123;        if(data[i]&#x3D;&#x3D;&#39;N&#39;)        &#123;            i+&#x3D;2;            root&#x3D;NULL;            return;        &#125;        string str;        for(int j&#x3D;i;j&lt;data.size();j++)        &#123;            if(data[j]&#x3D;&#x3D;&#39;,&#39;)            &#123;                j++;                i&#x3D;j;                break;            &#125;            str+&#x3D;data[j];        &#125;        root &#x3D;new TreeNode(get_num(str));        dfs(data,i,root-&gt;left);        dfs(data,i,root-&gt;right);    &#125;    int get_num(string str)    &#123;        int num&#x3D;0;        for(int i&#x3D;0;i&lt;str.size();i++)        &#123;            num&#x3D;num*10+(str[i]-&#39;0&#39;);        &#125;        return num;    &#125;&#125;;&#x2F;&#x2F; Your Codec object will be instantiated and called as such:&#x2F;&#x2F; Codec* ser &#x3D; new Codec();&#x2F;&#x2F; Codec* deser &#x3D; new Codec();&#x2F;&#x2F; string tree &#x3D; ser-&gt;serialize(root);&#x2F;&#x2F; TreeNode* ans &#x3D; deser-&gt;deserialize(tree);&#x2F;&#x2F; return ans;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h4><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p><p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p><p>我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。</p><p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" alt="q1248-01.png (304×270) (leetcode-cn.com)"></p><p>输入：root = [1,2,3,4], x = 4, y = 3<br>输出：false</p><p>堂兄弟的定义是：深度一样，父节点不一样。所以我们准备两个全局map容器father和mymap（不全局也可以，但dfs传参要多加这两个容器）来分别存放父节点和深度，我们用dfs函数来遍历树，dfs有五个参数，一个是当当前节点，一个是当前节点的子节点（左节点或右节点），一个是深度u（初始为0），还有两个是x和y。dfs一开始先判断当前节点是否为空，如果是就直接结束程序，如果不是就判断节点的val值等不等于x或y，如果等于就用mymap函数存下这个节点的深度u，再用father存下节点的父节点。然后我们把当前节点的左节点和右节点接着送去递归。当一切结束后，我们判断两个节点x和y的深度是否相等，如果相等判断他俩的父节点是否为同一个，如果为同一个即不是堂兄弟，如果不是则是堂兄弟。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    unordered_map&lt;int,int&gt;mymap;    unordered_map&lt;int,int&gt;father;    bool isCousins(TreeNode* root, int x, int y) &#123;        TreeNode* t;        t&#x3D;new TreeNode(200);        dfs(root,x,y,0,t);        if(mymap[x]&#x3D;&#x3D;mymap[y]&amp;&amp;father[x]!&#x3D;father[y])        &#123;            return true;        &#125;        return false;    &#125;    void dfs(TreeNode* p,int x,int y,int u,TreeNode* q)    &#123;        if(mymap.size()&#x3D;&#x3D;2)return;        if(!p)return;        if(p-&gt;val&#x3D;&#x3D;x)        &#123;            mymap[x]&#x3D;u;            father[x]&#x3D;q-&gt;val;        &#125;        else if(p-&gt;val&#x3D;&#x3D;y)        &#123;            mymap[y]&#x3D;u;            father[y]&#x3D;q-&gt;val;        &#125;        dfs(p-&gt;left,x,y,u+1,p);        dfs(p-&gt;right,x,y,u+1,p);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7</p><p>因为迭代是在一个函数里进行的，所以可以把全局函数vector&lt;vector&lt; int&gt;&gt;v设置在函数开头，当然也可以继续全局函数。先判断root是否为空，如果为空就返回空的v给它，如果不为空，那我们先准备一个queue容器que来存节点，先把root存入que中，然后开始while遍历，只要que不为空就一直遍历，每次遍历先拿一个数len存que的size，len就是当前层的节点数，这也决定了下面for循环的次数，再准备一个vector容器v1来存这一层节点的val值，然后开始for循环，循环len次，先把当前队列的头结点的val值存入v1中，然后把队列头结点的左子节点和右子节点存入que中，再把队头元素出队，for结束后把v1插入v中。一切遍历结束后返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;           vector&lt;vector&lt;int&gt;&gt;v;        if(!root)return v;        queue&lt;TreeNode*&gt;que;        que.push(root);        while(que.size())        &#123;            int len&#x3D;que.size();            vector&lt;int&gt;v1;            for(int i&#x3D;0;i&lt;len;i++)            &#123;                v1.push_back(que.front()-&gt;val);                if(que.front()-&gt;left)que.push(que.front()-&gt;left);                if(que.front()-&gt;right)que.push(que.front()-&gt;right);                que.pop();            &#125;            v.push_back(v1);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / <br>       4   5<br>      / \   \<br>     5   4   7</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;        if(!root1&amp;&amp;!root2)return root1;        else if(!root1&amp;&amp;root2)return root2;        else if(!root2&amp;&amp;root1)return root1;         dfs(root1,root2);        return root1;    &#125;    void dfs(TreeNode*&amp;p,TreeNode*&amp;q)    &#123;        if(!q)return;        else if(!p&amp;&amp;q)        &#123;            p&#x3D;q;            return;        &#125;        p-&gt;val+&#x3D;q-&gt;val;        dfs(p-&gt;left,q-&gt;left);        dfs(p-&gt;right,q-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-06每日刷题打卡</title>
      <link href="/2021/11/06/2021-11-06-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/06/2021-11-06-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-06每日刷题打卡"><a href="#2021-11-06每日刷题打卡" class="headerlink" title="2021-11-06每日刷题打卡"></a>2021-11-06每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a><a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></h4><p>给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p><p>示例 1：</p><p>输入：nums = [3,0,1]<br>输出：2<br>解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</p><p>简单粗暴，先把nums用sort快速排序一遍，然后找nums[i]!=i的那个下标，就是缺失的数，return i 即可。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(nums[i]!&#x3D;i)            &#123;                return i;            &#125;        &#125;        return n;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="力扣——二叉树"><a href="#力扣——二叉树" class="headerlink" title="力扣——二叉树"></a>力扣——二叉树</h2><h4 id="449-序列化和反序列化二叉搜索树"><a href="#449-序列化和反序列化二叉搜索树" class="headerlink" title="449. 序列化和反序列化二叉搜索树"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h4><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p>编码的字符串应尽可能紧凑。</p><p>示例 1：</p><p>输入：root = [2,1,3]<br>输出：[2,1,3]</p><p>我这里采用前序遍历的方法（本来想用层序的，但这样字符串可能要有点长，而且后序我不喜欢所以用前序）。</p><p>前序转字符串的方式就是递归，每次先判断当前节点是否为空，如果为空就往字符串上加一个标志性的字符来说明这是空结点，我这里用的是N（NULL），如果不为空，就把当前节点的val值转为字符串加在字符串上，然后再把该节点的左右子节点送去递归，注意每个节点的val值之间要用特殊的字符隔开，我用的是“，”。等递归完后所有的字符串都合在一起了，直接return即可。</p><p>字符串转换成二叉树的方式也是递归（递归真是个好东西），我们用自己写的dfs函数来完成递归，一共三个参数，字符串data，节点root和索引下标i（i和节点要以引用方式传递）。一开始i先为0在之后的递归里逐渐增加，每次先判断data[i]是否为“N”，如果是说明这里的节点应该为空，把当前节点指向空后直接结束程序，注意要把i+=2（跳过”，“）。如果不为N，那就先遍历字符串，当遇到”，“时结束遍历，再把遍历过的字符串转换成数字，这就是节点的val值，把值赋给root，然后送root的左右子节点去递归。当递归结束后我们得到的root就是最开始的二叉树了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Codec &#123;public:    &#x2F;&#x2F; Encodes a tree to a single string.    string serialize(TreeNode* root) &#123;        if(!root)return &quot;N&quot;;        return to_string(root-&gt;val)+&quot;,&quot;+serialize(root-&gt;left)+&quot;,&quot;+serialize(root-&gt;right);    &#125;    &#x2F;&#x2F; Decodes your encoded data to tree.    TreeNode* deserialize(string data) &#123;        TreeNode *root;        int i&#x3D;0;        dfs(data,i,root);        return root;    &#125;    void dfs(string data,int&amp; i,TreeNode*&amp; root)    &#123;        if(data[i]&#x3D;&#x3D;&#39;N&#39;)        &#123;            i+&#x3D;2;            root&#x3D;NULL;            return;        &#125;        string str;        for(int j&#x3D;i;j&lt;data.size();j++)        &#123;            if(data[j]&#x3D;&#x3D;&#39;,&#39;)            &#123;                j++;                i&#x3D;j;                break;            &#125;            str+&#x3D;data[j];        &#125;        root &#x3D;new TreeNode(get_num(str));        dfs(data,i,root-&gt;left);        dfs(data,i,root-&gt;right);    &#125;    int get_num(string str)    &#123;        int num&#x3D;0;        for(int i&#x3D;0;i&lt;str.size();i++)        &#123;            num&#x3D;num*10+(str[i]-&#39;0&#39;);        &#125;        return num;    &#125;&#125;;&#x2F;&#x2F; Your Codec object will be instantiated and called as such:&#x2F;&#x2F; Codec* ser &#x3D; new Codec();&#x2F;&#x2F; Codec* deser &#x3D; new Codec();&#x2F;&#x2F; string tree &#x3D; ser-&gt;serialize(root);&#x2F;&#x2F; TreeNode* ans &#x3D; deser-&gt;deserialize(tree);&#x2F;&#x2F; return ans;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1028-从先序遍历还原二叉树"><a href="#1028-从先序遍历还原二叉树" class="headerlink" title="1028. 从先序遍历还原二叉树"></a><a href="https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/">1028. 从先序遍历还原二叉树</a></h4><p>我们从二叉树的根节点 root 开始进行深度优先搜索。</p><p>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。</p><p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p><p>给出遍历输出 S，还原树并返回其根节点 root。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/recover-a-tree-from-preorder-traversal.png" alt="recover-a-tree-from-preorder-traversal.png (798×498) (leetcode-cn.com)"></p><p>输入：”1-2–3–4-5–6–7”<br>输出：[1,2,5,3,4,6,7]</p><p>这里我们采用递归的方法来写（问了大佬大佬写的用栈迭代更简单但我想不出来所以只能用递归），我们用dfs来实现递归，dfs有四个参数，一个是树的结点root，一个是字符串traversal，一个是深度u（u和i初始都为0），一个是遍历字符串的索引i。（索引和结点要以引用方式传递）每次开头先计算一下字符串的‘-’数，遍历字符串然后计算，当遇到不是‘-’的字符时判断一下‘-’数是否小于深度u，如果小于那么就直接return结束程序，如果不小于那就让i继承当前遍历的下标，然后结束这一次的遍历，然后在进行一次遍历，把遍历到的字符都变成数字，当遇到‘-’字符时结束遍历，把转变的数字赋给root，然后再把root的左右子结点送去递归，注意u要+1。最后所有递归结束后root就是字符串转换后的二叉树。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    void dfs(string traversal, TreeNode*&amp; root, int&amp; i, int u)    &#123;        int child_u &#x3D; 0;        for (int j &#x3D; i; j &lt; traversal.size(); j++)        &#123;            if (traversal[j] !&#x3D; &#39;-&#39;)            &#123;                if (child_u &lt; u)                &#123;                    return;                &#125;                else                    i &#x3D; j;                break;            &#125;            child_u++;        &#125;        int num&#x3D;0;;        for (int j &#x3D; i; j &lt; traversal.size(); j++)        &#123;            if (traversal[j] &#x3D;&#x3D; &#39;-&#39;)            &#123;                i &#x3D; j;                break;            &#125;            num&#x3D;num*10+(traversal[j]-&#39;0&#39;);        &#125;        root &#x3D; new TreeNode(num);        dfs(traversal, root-&gt;left, i, u + 1);        dfs(traversal, root-&gt;right, i, u + 1);    &#125;    TreeNode* recoverFromPreorder(string traversal) &#123;        TreeNode* root;        int i &#x3D; 0, deep &#x3D; 0;        dfs(traversal, root, i, deep);        return root;    &#125;    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="919-完全二叉树插入器和剑指-Offer-II-043-往完全二叉树添加节点"><a href="#919-完全二叉树插入器和剑指-Offer-II-043-往完全二叉树添加节点" class="headerlink" title="919. 完全二叉树插入器和剑指 Offer II 043. 往完全二叉树添加节点"></a><a href="https://leetcode-cn.com/problems/complete-binary-tree-inserter/">919. 完全二叉树插入器</a>和<a href="https://leetcode-cn.com/problems/NaqhDT/">剑指 Offer II 043. 往完全二叉树添加节点</a></h4><p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p><p>设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：</p><p>CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；<br>CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；<br>CBTInserter.get_root() 将返回树的头节点。</p><p>示例 1：</p><p>输入：inputs = [“CBTInserter”,”insert”,”get_root”], inputs = [[[1]],[2],[]]<br>输出：[null,1,[1,2]]</p><p>第一次在力扣写实现题！真不容易啊呜呜呜！</p><p>记得先在类里写个成员变量的二叉树，公有权限或私有权限都行（一开始忘了成员变量郁闷的要死）。</p><p>构造函数（要求实现功能是用传入的二叉树来初始化成员变量的二叉树）：用dfs递归的方式来初始化，每次把成员变量的二叉树的值和root的val一样，然后判断root是否有左右子节点，如果有就把成员变量的左右子节点和root的左右子节点分别传入下一次的递归里，当所有递归结束后得到的就是和root一样的二叉树了。</p><p>插入函数（往二叉树插入一个新的节点）：用层序遍历来遍历成员变量的二叉树，去找第一个没有左右子节点或者只有左节点没有右节点的那一个父节点随便创建一个新的节点，用传入的val值来初始化它，再把这个节点连在父节点的左节点或右节点上，最后返回这个父节点的val值。</p><p>返回函数：直接返回成员变量的二叉树即可，非常简单。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class CBTInserter &#123;private:TreeNode* root;public:    CBTInserter(TreeNode* root) &#123;        dfs(root,this-&gt;root);    &#125;    void dfs(TreeNode* root,TreeNode *&amp;p)    &#123;        p&#x3D;new TreeNode(root-&gt;val);        if(root-&gt;left)dfs(root-&gt;left,p-&gt;left);        if(root-&gt;right)dfs(root-&gt;right,p-&gt;right);    &#125;        int insert(int val) &#123;        queue&lt;TreeNode*&gt;que;        que.push(this-&gt;root);        TreeNode *q;        q&#x3D;new TreeNode(val);        while(que.size())        &#123;            int len&#x3D;que.size();            for(int i&#x3D;0;i&lt;len;i++)            &#123;                if(que.front()-&gt;left&amp;&amp;que.front()-&gt;right)                &#123;                    que.push(que.front()-&gt;left);                    que.push(que.front()-&gt;right);                &#125;                else if(que.front()-&gt;left&amp;&amp;!que.front()-&gt;right)                &#123;                    que.front()-&gt;right&#x3D;q;                    return que.front()-&gt;val;                &#125;                else if(!que.front()-&gt;left&amp;&amp;!que.front()-&gt;right)                &#123;                    que.front()-&gt;left&#x3D;q;                    return que.front()-&gt;val;                &#125;                que.pop();            &#125;        &#125;        return &#123;&#125;;    &#125;        TreeNode* get_root() &#123;        return this-&gt;root;    &#125;&#125;;&#x2F;** * Your CBTInserter object will be instantiated and called as such: * CBTInserter* obj &#x3D; new CBTInserter(root); * int param_1 &#x3D; obj-&gt;insert(val); * TreeNode* param_2 &#x3D; obj-&gt;get_root(); *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-05每日刷题打卡</title>
      <link href="/2021/11/05/2021-11-05-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/05/2021-11-05-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-05每日刷题打卡"><a href="#2021-11-05每日刷题打卡" class="headerlink" title="2021-11-05每日刷题打卡"></a>2021-11-05每日刷题打卡</h1><h2 id="力扣-——二叉树"><a href="#力扣-——二叉树" class="headerlink" title="力扣 ——二叉树"></a>力扣 ——二叉树</h2><h4 id="剑指-Offer-II-044-二叉树每层的最大值和515-在每个树行中找最大值"><a href="#剑指-Offer-II-044-二叉树每层的最大值和515-在每个树行中找最大值" class="headerlink" title="剑指 Offer II 044. 二叉树每层的最大值和515. 在每个树行中找最大值"></a><a href="https://leetcode-cn.com/problems/hPov7L/">剑指 Offer II 044. 二叉树每层的最大值</a>和<a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h4><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><p>示例1：</p><p>输入: root = [1,3,2,5,3,null,9]<br>输出: [1,3,9]<br>解释:<br>          1<br>         / <br>        3   2<br>       / \   \<br>      5   3   9 </p><p>层序遍历二叉树，每次遍历新的一层时准备一个max来存最大值，然后依次比较，遍历完后把max存入vector容器中，然后继续遍历下一层。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; largestValues(TreeNode* root) &#123;        vector&lt;int&gt;v;        if(!root)return v;        queue&lt;TreeNode*&gt;que;        que.push(root);        while(que.size())        &#123;            int len&#x3D;que.size();            int max&#x3D;que.front()-&gt;val;            for(int i&#x3D;0;i&lt;len;i++)            &#123;                if(max&lt;que.front()-&gt;val)max&#x3D;que.front()-&gt;val;                if(que.front()-&gt;left)que.push(que.front()-&gt;left);                if(que.front()-&gt;right)que.push(que.front()-&gt;right);                que.pop();            &#125;            v.push_back(max);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / <br>       4   5<br>      / \   \<br>     5   4   7<br>注意: 合并必须从两个树的根节点开始。</p><p>先判断一下，如果root1为空而root2不为空那就返回root2即可，反之返回root1，如果两个都空那么返回哪个都行，如果两个都不为空那我们就开始合并的操作。直接把两个树传入dfs里，我们以root1为主树，dfs的实现是，先判断root2是否为空，如果为空就直接结束程序，如果root2不为空而root1为空，那就直接让root1=root2，以此获得root2的当前结点和之后所有节点（记住dfs的参数传递要以引用的方式才行），如果两个都不为空，那就把root2的val值加到root1上，然后再分别把root1和root2的左子节点和右子节点传入dfs里。当递归结束后root1就是合并后的二叉树了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;        if(!root1&amp;&amp;!root2)return root1;        else if(!root1&amp;&amp;root2)return root2;        else if(!root2&amp;&amp;root1)return root1;         dfs(root1,root2);        return root1;    &#125;    void dfs(TreeNode*&amp;p,TreeNode*&amp;q)    &#123;        if(!q)return;        else if(!p&amp;&amp;q)        &#123;            p&#x3D;q;            return;        &#125;        p-&gt;val+&#x3D;q-&gt;val;        dfs(p-&gt;left,q-&gt;left);        dfs(p-&gt;right,q-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><p>给定一棵树的前序遍历 preorder 与中序遍历  inorder。请构造二叉树并返回其根节点。</p><p>示例 1:</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="tree.jpg (277×302) (leetcode.com)"></p><p>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]</p><p>这题感觉太复杂了想着一开始先写个大概出来等有错了一步步改，结果一写完发现通过测试例了，整个人疑惑了一下然后点了下提交就这么直接过了也太爽了！还有什么比这更爽的事情吗？</p><p>前序遍历的结构组成是：（根节点）（左子树）（右子树）           中序遍历的结构组成是：（左子树）（根节点）（右子树）</p><p>那么我们就可以发现了，前序遍历的开头必是根节点，然后我们拿根节点在中序遍历里找，左边就是左子树的序列，右边就是右子树的序列，然后我们再回到前序遍历里找左子树，找到的第一个就是左子树的根节点，然后再拿这个根节点回到中序遍历里找…………以此循环往复，中途每次找到根节点就把它和父节点连起来最后得到的就是整个树的样子了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        return dfs(preorder,inorder);    &#125;    TreeNode* dfs(vector&lt;int&gt;p,vector&lt;int&gt;q)    &#123;        if(!p.size())return NULL;        TreeNode *root;        root&#x3D;new TreeNode(p[0]);        int n&#x3D;q.size();        vector&lt;int&gt;v1;        vector&lt;int&gt;v2;        vector&lt;int&gt;v3;        vector&lt;int&gt;v4;        int j;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(q[i]&#x3D;&#x3D;p[0])            &#123;                j&#x3D;i;                break;            &#125;            v1.push_back(p[i+1]);            v2.push_back(q[i]);        &#125;        for(int i&#x3D;j+1;i&lt;n;i++)        &#123;            v3.push_back(p[i]);            v4.push_back(q[i]);        &#125;        root-&gt;left&#x3D;dfs(v1,v2);        root-&gt;right&#x3D;dfs(v3,v4);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7</p><p>这题和前面的<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a>基本一样，只不过前序遍历的根节点是数组的第一位，我们后续遍历的根节点是数组的最后一位，只要注意节点的取值，其它的就一模一样了。（如果写了前面不会写这题说明你没明白彻底建议多回去看几遍前面的题）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;        return dfs(inorder,postorder);    &#125;    TreeNode* dfs(vector&lt;int&gt;p,vector&lt;int&gt;q)    &#123;        if(!q.size())return NULL;        vector&lt;int&gt;v1;        vector&lt;int&gt;v2;        vector&lt;int&gt;v3;        vector&lt;int&gt;v4;        TreeNode *root;        int n&#x3D;q.size(),j;        root &#x3D;new TreeNode(q[n-1]);        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(p[i]&#x3D;&#x3D;q[n-1])            &#123;                j&#x3D;i;                break;            &#125;            v1.push_back(p[i]);            v2.push_back(q[i]);        &#125;        for(int i&#x3D;j+1;i&lt;n;i++)        &#123;            v3.push_back(p[i]);            v4.push_back(q[i-1]);        &#125;        root-&gt;left&#x3D;dfs(v1,v2);        root-&gt;right&#x3D;dfs(v3,v4);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h4><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>示例 1:</p><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="tree.jpg (401×301) (leetcode.com)"></p><p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]</p><p>这题目前能想到简单点的方法就是层序遍历，层序遍历完后把每层的最后一个数存入vector中，最后返回那个vector。（注意一开始要判断root是否为空，如果为空就返回一个空的vector容器给它）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt;v1;    vector&lt;int&gt;v;    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        if(!root)return v;        dfs(root,0);        for(int i&#x3D;0;i&lt;v1.size();i++)        &#123;            v.push_back(v1[i][v1[i].size()-1]);        &#125;        return v;    &#125;    void dfs(TreeNode*root,int u)    &#123;        if(!root)return;        if(v1.size()&lt;u+1)        &#123;            vector&lt;int&gt;v2;            v1.push_back(v2);        &#125;        v1[u].push_back(root-&gt;val);        dfs(root-&gt;left,u+1);        dfs(root-&gt;right,u+1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-04每日刷题打卡</title>
      <link href="/2021/11/04/2021-11-04-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/04/2021-11-04-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-04每日刷题打卡"><a href="#2021-11-04每日刷题打卡" class="headerlink" title="2021-11-04每日刷题打卡"></a>2021-11-04每日刷题打卡</h1><h2 id="力扣——二叉树"><a href="#力扣——二叉树" class="headerlink" title="力扣——二叉树"></a>力扣——二叉树</h2><h4 id="102-二叉树的层序遍历和剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#102-二叉树的层序遍历和剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="102. 二叉树的层序遍历和剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>和<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层序遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><p>层序遍历很好理解就是一层层遍历。</p><p>第一种方法——递归：先准备一个全局的vector&lt;vector&lt; int &gt;&gt;容器v用以存结构，函数里先判断root是否为空，如果为空就直接把空的v返回，如果不为空，就把root传入dfs里，同时要传一个层数u，我们为了符合数组的存储方式层数我们从0开始。进入dfs，先判断root是否为空，如果为空就直接结束程序，如果不为空则判断一下当前v的size是否小于u+1，如果小于我们就创建一个vector容器插入v中，然后我们通过v[u].push_back()来插入当前root的val值，再把root的left和right分别送入下一次的dfs递归中，此时我们传的层数为u+1。当所有递归结束后返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt;v;    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;           if(!root)return v;        vector&lt;int&gt;v1;        v.assign(1, v1);        dfs(root,0);        return v;    &#125;    void dfs(TreeNode* root, int u)    &#123;        if (!root)return;        else        &#123;            if(v.size()&lt;u+1)            &#123;                vector&lt;int&gt;v1;                v.push_back(v1);            &#125;            v[u].push_back(root-&gt;val);            dfs(root-&gt;left, u + 1);            dfs(root-&gt;right, u + 1);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种方法——迭代：因为迭代是在一个函数里进行的，所以可以把全局函数vector&lt;vector&lt; int&gt;&gt;v设置在函数开头，当然也可以继续全局函数。先判断root是否为空，如果为空就返回空的v给它，如果不为空，那我们先准备一个queue容器que来存节点，先把root存入que中，然后开始while遍历，只要que不为空就一直遍历，每次遍历先拿一个数len存que的size，len就是当前层的节点数，这也决定了下面for循环的次数，再准备一个vector容器v1来存这一层节点的val值，然后开始for循环，循环len次，先把当前队列的头结点的val值存入v1中，然后把队列头结点的左子节点和右子节点存入que中，再把队头元素出队，for结束后把v1插入v中。一切遍历结束后返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;           vector&lt;vector&lt;int&gt;&gt;v;        if(!root)return v;        queue&lt;TreeNode*&gt;que;        que.push(root);        while(que.size())        &#123;            int len&#x3D;que.size();            vector&lt;int&gt;v1;            for(int i&#x3D;0;i&lt;len;i++)            &#123;                v1.push_back(que.front()-&gt;val);                if(que.front()-&gt;left)que.push(que.front()-&gt;left);                if(que.front()-&gt;right)que.push(que.front()-&gt;right);                que.pop();            &#125;            v.push_back(v1);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h4><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p>示例 1：</p><p>输入：<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>输出：[3, 14.5, 11]<br>解释：<br>第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</p><p>通过上面层序遍历的方法先得到各层的节点数，然后就正常的求平均值就是。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt;v;    vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;        vector&lt;double&gt;nums;        if(!root)return nums;        dfs(root,0);        double sum&#x3D;0;        int n&#x3D;v.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            for(int j&#x3D;0;j&lt;v[i].size();j++)            &#123;                sum+&#x3D;v[i][j];            &#125;            nums.push_back(sum&#x2F;v[i].size());            sum&#x3D;0;        &#125;        return nums;    &#125;    void dfs(TreeNode* root,int u)    &#123;        if(!root)return;        else        &#123;            if(v.size()&lt;u+1)            &#123;                vector&lt;int&gt;v1;                v.push_back(v1);            &#125;            v[u].push_back(root-&gt;val);            dfs(root-&gt;left,u+1);            dfs(root-&gt;right,u+1);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p><p>​    3</p><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回锯齿形层序遍历如下：</p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><p>用上面求层序遍历的方法求完各层节点数，然后把奇数层的节点全都改成逆序就行（偷鸡法）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt;v;    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;        if(!root)return v;        dfs(root,0);        int n&#x3D;v.size();        for(int i&#x3D;1;i&lt;n;i+&#x3D;2)        &#123;            int m&#x3D;v[i].size();            int k&#x3D;m-1;            for(int j&#x3D;0;j&lt;m&#x2F;2;j++)            &#123;                swap(v[i][j],v[i][k]);                k--;            &#125;        &#125;        return v;    &#125;    void dfs(TreeNode* root, int u)    &#123;        if (!root)return;        if (v.size() &lt; u + 1)        &#123;            vector&lt;int&gt;v1;            v.push_back(v1);        &#125;        v[u].push_back(root-&gt;val);        dfs(root-&gt;left, u + 1);        dfs(root-&gt;right, u + 1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="剑指-Offer-II-045-二叉树最底层最左边的值和513-找树左下角的值"><a href="#剑指-Offer-II-045-二叉树最底层最左边的值和513-找树左下角的值" class="headerlink" title="剑指 Offer II 045. 二叉树最底层最左边的值和513. 找树左下角的值"></a><a href="https://leetcode-cn.com/problems/LwUNpT/">剑指 Offer II 045. 二叉树最底层最左边的值</a>和<a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p>示例 1:</p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt="tree1.jpg (302×182) (leetcode.com)"></p><p>输入: root = [2,1,3]<br>输出: 1</p><p>用上面求层序遍历的方法求完各层节点数，然后返回最后一层的的第一个数就行。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt;v;    int findBottomLeftValue(TreeNode* root) &#123;        if(!root)return NULL;        dfs(root,0);        int n&#x3D;v.size()-1;        return v[n][0];    &#125;    void dfs(TreeNode*root,int u)    &#123;        if(!root)return;        if(v.size()&lt;u+1)        &#123;            vector&lt;int&gt;v1;            v.push_back(v1);        &#125;        v[u].push_back(root-&gt;val);        dfs(root-&gt;left,u+1);        dfs(root-&gt;right,u+1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单一点的方法：用一个queue容器que来存节点，准备一个数num_left来存每层最左边的数。先把root存入que中，然后开始while循环，只要que里还有元素就继续循环，先把当前队列的头元素的val值赋给num_left，因为队头元素就是每层的最左边的节点，再准备一个值len存当前队列的节点数，这代表这一层的节点数，也是下面for循环的结束条件。然后进入for循环，每次把当前队头元素的左子节点和右子节点传入队列，然后弹出队头元素（这时前面的len作用就体现出来了，循环len次，每次弹出队头元素，这样循环完后上一层的节点就全都消失，取之而代的是下一层的节点，队头元素就是最左边的节点）。当while结束后返回num_left。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int findBottomLeftValue(TreeNode* root) &#123;        if(!root)return NULL;        queue&lt;TreeNode*&gt;que;        int num_left;        que.push(root);        while(que.size())        &#123;            int len&#x3D;que.size();            num_left&#x3D;que.front()-&gt;val;            for(int i&#x3D;0;i&lt;len;i++)            &#123;                if(que.front()-&gt;left)que.push(que.front()-&gt;left);                if(que.front()-&gt;right)que.push(que.front()-&gt;right);                que.pop();            &#125;        &#125;        return num_left;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-03每日刷题打卡</title>
      <link href="/2021/11/03/2021-11-03-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/03/2021-11-03-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-03每日刷题打卡"><a href="#2021-11-03每日刷题打卡" class="headerlink" title="2021-11-03每日刷题打卡"></a>2021-11-03每日刷题打卡</h1><h2 id="力扣——二叉树"><a href="#力扣——二叉树" class="headerlink" title="力扣——二叉树"></a>力扣——二叉树</h2><p>昨天的前中后序遍历我们用的是递归的方法写的，今天我们改用迭代的方法。</p><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>迭代我们需要准备一个stack容器sta来存放节点以保证能回溯，一个vector容器v来存储结果。先判断给的树root是否为空，如果为空就直接把v返回给他结束程序，如果root不为空我们就开始遍历，用while来遍历root，只要root不为NULL或sta.size()不为0就一直循环下去，while里再套入一个while，只要root不为空就一直在这个while里，每次遍历把当前节点存入sta中，把节点的val存入v中，然后root=root-&gt;left一直遍历下去。当内部的while结束时说明当前节点为空了，也就说明它的父节点没有左节点，我们把存在sta中的父节点取出赋给root，同时顶端元素出栈，把现在节点的val值存入v中，然后让当前节点往right的方向走，然后回到最开始的地方进行下一次迭代。最后迭代结束后v里就是我们要的前序遍历，返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        if(!root)return v;        stack&lt;TreeNode*&gt;sta;        while(sta.size()||root)        &#123;            while(root)            &#123;                v.push_back(root-&gt;val);                sta.push(root);                root&#x3D;root-&gt;left;            &#125;            root&#x3D;sta.top();            sta.pop();            root&#x3D;root-&gt;right;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,3,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>中序遍历和前序遍历的大体步骤一样，但是while循环里的操作顺序略有不同，在while的嵌套while中，我们不往v中存节点的val值，只把节点存入sta中，然后一直往left遍历，当嵌套while结束时说明当前节点的父节点没有左节点，我们把sta的顶端元素（即父节点）赋给root，同时把顶端元素弹出，然后把当前节点的val存入v中，再把节点向right方向走，回到开头处继续迭代。最后返回v。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        if(!root)return v;        stack&lt;TreeNode*&gt;sta;        while(sta.size()||root)        &#123;            while(root)            &#123;                sta.push(root);                root&#x3D;root-&gt;left;            &#125;            root&#x3D;sta.top();            sta.pop();            v.push_back(root-&gt;val);            root&#x3D;root-&gt;right;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:</p><p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p><p>输出: [3,2,1]</p><p>和前面的中序遍历也是大同小异，但我们这里事先准备的不止v和sta，还要准备一个树节点p，初始指向NULL,然后开始遍历，嵌套的while和中序遍历一样，只存节点在sta里，然后节点一直往left走，嵌套的while结束说明当前节点的父节点没有左子树，我们从sta中取出并弹出顶端元素给root，然后判断一下，现在root的right是否等于NULL或等于p，如果满足一点，那么我们把当前节点的val存入v中，并把当前节点赋给p，然后令当前节点变为NULL；如果不满足任意一点，那么我们就把当前节点在存回sta中，并让节点向right方向走。然后回到开头继续迭代，最后返回v。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        if(!root)return v;        stack&lt;TreeNode*&gt;sta;        TreeNode*p&#x3D;NULL;        while(sta.size()||root)        &#123;            while(root)            &#123;                sta.push(root);                root&#x3D;root-&gt;left;            &#125;            root&#x3D;sta.top();            sta.pop();            if(!root-&gt;right||root-&gt;right&#x3D;&#x3D;p)            &#123;                v.push_back(root-&gt;val);                p&#x3D;root;                root&#x3D;NULL;            &#125;            else            &#123;                sta.push(root);                root&#x3D;root-&gt;right;            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h4><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p><p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p><p>我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。</p><p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" alt="q1248-01.png (304×270) (leetcode-cn.com)"></p><p>输入：root = [1,2,3,4], x = 4, y = 3<br>输出：false</p><p>堂兄弟的定义是：深度一样，父节点不一样。所以我们准备两个全局map容器father和mymap（不全局也可以，但dfs传参要多加这两个容器）来分别存放父节点和深度，我们用dfs函数来遍历树，dfs有五个参数，一个是当当前节点，一个是当前节点的子节点（左节点或右节点），一个是深度u（初始为0），还有两个是x和y。dfs一开始先判断当前节点是否为空，如果是就直接结束程序，如果不是就判断节点的val值等不等于x或y，如果等于就用mymap函数存下这个节点的深度u，再用father存下节点的父节点。然后我们把当前节点的左节点和右节点接着送去递归。当一切结束后，我们判断两个节点x和y的深度是否相等，如果相等判断他俩的父节点是否为同一个，如果为同一个即不是堂兄弟，如果不是则是堂兄弟。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    unordered_map&lt;int,int&gt;mymap;    unordered_map&lt;int,int&gt;father;    bool isCousins(TreeNode* root, int x, int y) &#123;        TreeNode* t;        t&#x3D;new TreeNode(200);        dfs(root,x,y,0,t);        if(mymap[x]&#x3D;&#x3D;mymap[y]&amp;&amp;father[x]!&#x3D;father[y])        &#123;            return true;        &#125;        return false;    &#125;    void dfs(TreeNode* p,int x,int y,int u,TreeNode* q)    &#123;        if(mymap.size()&#x3D;&#x3D;2)return;        if(!p)return;        if(p-&gt;val&#x3D;&#x3D;x)        &#123;            mymap[x]&#x3D;u;            father[x]&#x3D;q-&gt;val;        &#125;        else if(p-&gt;val&#x3D;&#x3D;y)        &#123;            mymap[y]&#x3D;u;            father[y]&#x3D;q-&gt;val;        &#125;        dfs(p-&gt;left,x,y,u+1,p);        dfs(p-&gt;right,x,y,u+1,p);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="flaten.jpg (1021×461) (leetcode.com)"></p><p>输入：root = [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]</p><p>准备一个全局vector容器v来存放节点，注意是存节点而不是val值，不喜欢全局变量的话dfs的参数要把v也传过去比较麻烦我就直接全局设定了。之前我们写过递归求前序遍历的方法拿到这里来也是通用的，当我们把前序排序的结果存在v里后，我们把根节点的left和right都指向NULL，然后用for遍历，i=1(因为根节点已经是v[0]了)，每次把根节点的right指向v[i]，然后把root往right上走一格，注意要把left都指向NULL。最后遍历完要把最后一个节点的right指向NULL。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;TreeNode*&gt;v;    void dfs(TreeNode* root)    &#123;        if (!root)return;        else        &#123;            v.push_back(root);            dfs(root-&gt;left);            dfs(root-&gt;right);        &#125;    &#125;    void flatten(TreeNode* root) &#123;        if (!root)return;        dfs(root);        root-&gt;left &#x3D; NULL;        root-&gt;right &#x3D; NULL;        int n &#x3D; v.size();        for (int i &#x3D; 1; i &lt; n; i++)        &#123;            root-&gt;right &#x3D; v[i];            root &#x3D; root-&gt;right;            root-&gt;left&#x3D;NULL;        &#125;        root-&gt;right &#x3D; NULL;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="872-叶子相似的树"><a href="#872-叶子相似的树" class="headerlink" title="872. 叶子相似的树"></a><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a></h4><p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。</p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt="tree.png (735×617) (s3-lc-upload.s3.amazonaws.com)"></p><p>举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。</p><p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。</p><p>如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg" alt="leaf-similar-1.jpg (1122×444) (leetcode.com)"></p><p>输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]<br>输出：true</p><p>这回没法用全局vector容器了，因为这次有两个v，如果用全局系统不知道把值插入哪个地方，所以这次老老实实传v做参数吧。</p><p>准备两个vector容器v1和v2，分别存root1和root2的叶子节点，我们实现一个dfs函数（这里我们采用的是前序遍历的方法），传入树节点root和vector容器做参数，每次先判断当前节点是否为空，如果为空就结束程序，如果不为空就判断当前节点有没有子节点（left和right）如果没有就说明这个是一个叶节点，我们把这个节点的val值存入v中，并结束程序。如果这个节点不是叶子节点，那我们就把当前节点的left和right分别送去递归。当递归完后v1和v2就存好了两个数的叶子节点，先判断两个v所存元素个数是否相等，如果不相等就直接返回false，如果相等再一个个比较元素，如果有不一样的就返回false。如果都一样就返回true。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool leafSimilar(TreeNode* root1, TreeNode* root2) &#123;        vector&lt;int&gt;v1;        vector&lt;int&gt;v2;        dfs(root1,v1);        dfs(root2,v2);        int n&#x3D;v1.size(),m&#x3D;v2.size();        if(n!&#x3D;m)return false;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(v1[i]!&#x3D;v2[i])return false;        &#125;        return true;    &#125;    void dfs(TreeNode* root,vector&lt;int&gt;&amp;v)    &#123;        if(!root)return;        else if(!root-&gt;left&amp;&amp;!root-&gt;right)        &#123;            v.push_back(root-&gt;val);            return;        &#125;        dfs(root-&gt;left,v);        dfs(root-&gt;right,v);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-02每日刷题打卡</title>
      <link href="/2021/11/02/2021-11-02-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/02/2021-11-02-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-02每日刷题打卡"><a href="#2021-11-02每日刷题打卡" class="headerlink" title="2021-11-02每日刷题打卡"></a>2021-11-02每日刷题打卡</h1><h2 id="力扣——二叉树"><a href="#力扣——二叉树" class="headerlink" title="力扣——二叉树"></a>力扣——二叉树</h2><h4 id="104-二叉树的最大深度和剑指-Offer-55-I-二叉树的深度"><a href="#104-二叉树的最大深度和剑指-Offer-55-I-二叉树的深度" class="headerlink" title="104. 二叉树的最大深度和剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>和<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p>​    3</p><p>   / <br>  9  20<br>    /  <br>   15   7</p><p>返回它的最大深度 3 。</p><p>遍历树，每次对比左子树和右子树的深度，选最大的那个。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root &#x3D;&#x3D; nullptr) return 0;        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="ex_depth.jpg (432×302) (leetcode.com)"></p><p>输入：root = [3,9,20,null,null,15,7]<br>输出：2</p><p>遍历树，每遍历一个结点判断一下，如果这个结点为NULL就返回0，如果这个结点left和right都为NULL，说明这个结点就是叶子结点，返回1。如果不是叶子节点，拿这个结点接着去遍历，这个结点的左子树和右子树看看哪个的深度最小，最后返回这个小的深度+1（+1是算上根节点）。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        if(!root)return 0;        if(!root-&gt;left&amp;&amp;!root-&gt;right)return 1;        int num&#x3D;100000;        if(root-&gt;left!&#x3D;NULL)num&#x3D;min(minDepth(root-&gt;left),num);        if(root-&gt;right!&#x3D;NULL)num&#x3D;min(minDepth(root-&gt;right),num);        return num+1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="complete.jpg (372×302) (leetcode.com)"></p><p>输入：root = [1,2,3,4,5,6]<br>输出：6</p><p>用dfs来写树是最方便了，dfs函数一开始先判断结点是否为NULL，如果是就返回0，如果不是再判断这节点是否是叶子节点（无左节点和右节点），如果是就只记此处有一个节点（return 1)。如果不是就递归调用dfs本身，把这个节点的左节点和右节点当做参数送去遍历，把结果相加后再＋1返回(+1是为了算上自己本身的节点)。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int countNodes(TreeNode* root) &#123;        if(!root)return 0;        return dfs(root-&gt;left)+dfs(root-&gt;right)+1;    &#125;    int dfs(TreeNode *p)    &#123;        if(!p)return 0;        else if(!p-&gt;left&amp;&amp;!p-&gt;right)return 1;        return dfs(p-&gt;left)+dfs(p-&gt;right)+1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h4><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p><p>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg" alt="subtree1-tree.jpg (532×400) (leetcode.com)"></p><p>输入：root = [3,4,5,1,2], subRoot = [4,1,2]<br>输出：true</p><p>判断root中有subRoot的条件是：root和subRoot相等，或subRoot是root的一个左子树，或subRoot是root的一个右子树。而判断root和subRoot相等的条件是：root和subRoot的val值相等，且root的左子树和subRoot的左子树的val值相等，且root的右子树和subRoot的右子树的val值相等。所以我们要写两个递归函数，一个是判断root中有subRoot的dfs函数，还有一个是判断root和subRoot相等的check函数。</p><p>dfs的实现是，先判断当前节点是否为NULL，如果是说明不与subRoot本身相等（subRoot本身至少有一个节点），然后用check来判断当前节点是否和subRoot相等，判断subRoot是否是root的左子树或右子树，只要这三者有一个为true那就为true；</p><p>check的实现是，判断当前节点和subRoot是否都为NULL（我们传递的参数有可能是subRoot的子节点，所以会出现subRoot为空的情况），如果都为空说明相等返回true，然后判断当前节点和subRoot是否有一个为空，如果有就返回false，判断当前节点的val和subRoot的val是否相等，如果不相等返回false，如果相等把当前节点的左节点和subRoot的左节点拿去下一次判断，再把当前节点的右节点和subRoot的右节点拿去下一次判断，两者只要有一个不为true那就都不为true。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123;        return dfs(root,subRoot);    &#125;    bool dfs(TreeNode*p,TreeNode*q)    &#123;        if(!p)return false;        return check(p,q)||dfs(p-&gt;left,q)||dfs(p-&gt;right,q);    &#125;    bool check(TreeNode*p,TreeNode*q)    &#123;        if(!p&amp;&amp;!q)return true;        if(!p&amp;&amp;q||p&amp;&amp;!q||p-&gt;val!&#x3D;q-&gt;val)return false;        return check(p-&gt;left,q-&gt;left)&amp;&amp;check(p-&gt;right,q-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前序遍历：先从根节点开始，然后到左节点，再到右节点。</p><p>我们准备一个vector容器v来存放遍历顺序，用dfs来遍历树，dfs的实现是：先判断当前节点是否为空，如果为空就结束程序，如果不为空就先把当前节点的值存入v中，然后把节点的左子树先送去dfs下一次递归，再把右子树送去下一次递归。当递归完后前序排列的顺序就都存在v中了，返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        dfs(root,v);        return v;    &#125;    void dfs(TreeNode* p,vector&lt;int&gt;&amp; v)    &#123;        if(!p)return;        else        &#123;            v.push_back(p-&gt;val);            dfs(p-&gt;left,v);            dfs(p-&gt;right,v);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,3,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>中序遍历：先从左节点开始，然后到跟节点，再到右节点。</p><p>我们准备一个vector容器v来存放遍历顺序，用dfs来遍历树，dfs的实现是：先判断当前节点是否为空，如果为空就结束程序，如果不为空就先把节点的左子树先送去dfs下一次递归，然后把当前节点的值存入v中，再把右子树送去下一次递归。当递归完后中序排列的顺序就都存在v中了，返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        dfs(root,v);        return v;    &#125;       void dfs(TreeNode* p,vector&lt;int&gt;&amp; v)    &#123;        if(!p)return;        else        &#123;            dfs(p-&gt;left,v);            v.push_back(p-&gt;val);            dfs(p-&gt;right,v);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:</p><p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p><p>输出: [3,2,1]</p><p>后序遍历：先从左节点开始，然后到右节点，再到跟节点。</p><p>我们准备一个vector容器v来存放遍历顺序，用dfs来遍历树，dfs的实现是：先判断当前节点是否为空，如果为空就结束程序，如果不为空就先把节点的左子树先送去dfs下一次递归，然后把右子树送去下一次递归，再把当前节点的值存入v中。当递归完后后序排列的顺序就都存在v中了，返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        dfs(root,v);        return v;    &#125;    void dfs(TreeNode*p,vector&lt;int&gt;&amp; v)    &#123;        if(!p)return;        else        &#123;            dfs(p-&gt;left,v);            dfs(p-&gt;right,v);            v.push_back(p-&gt;val);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这三个遍历只是改变了在v中插入值、传左子树递归、传右子树递归的顺序而已。本质上来说是一模一样的。</p>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-01每日刷题打卡</title>
      <link href="/2021/11/01/2021-11-01-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/01/2021-11-01-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-01每日刷题打卡"><a href="#2021-11-01每日刷题打卡" class="headerlink" title="2021-11-01每日刷题打卡"></a>2021-11-01每日刷题打卡</h1><h2 id="力扣——二叉树"><a href="#力扣——二叉树" class="headerlink" title="力扣——二叉树"></a>力扣——二叉树</h2><h4 id="965-单值二叉树"><a href="#965-单值二叉树" class="headerlink" title="965. 单值二叉树"></a><a href="https://leetcode-cn.com/problems/univalued-binary-tree/">965. 单值二叉树</a></h4><p>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。</p><p>只有给定的树是单值二叉树时，才返回 true；否则返回 false。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png" alt="screen-shot-2018-12-25-at-50104-pm.png "></p><p>输入：[1,1,1,1,1,null,1]<br>输出：true</p><p>这题考的就是树的遍历，比起链表的一个指针next，树有两个指针一个left，一个right。对于树的遍历我们最好用的就是递归的方式。全局变量设定一个bool类型flag初始化为true，每次遍历对比当前节点的val和其left与right的val值，如果不相等就设为false并直接结束所有程序返回flag，如果相等，就把root-&gt;left和root-&gt;right放入遍历中。最后返回flag。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool flag&#x3D;true;    bool isUnivalTree(TreeNode* root) &#123;        if(root&#x3D;&#x3D;NULL)return flag;        if(root-&gt;left!&#x3D;NULL)        &#123;            if(root-&gt;val!&#x3D;root-&gt;left-&gt;val)flag&#x3D;false;            isUnivalTree(root-&gt;left);        &#125;        if(root-&gt;right!&#x3D;NULL)        &#123;            if(root-&gt;val!&#x3D;root-&gt;right-&gt;val)flag&#x3D;false;            isUnivalTree(root-&gt;right);        &#125;        return flag;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种方法，不用全局变量。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isUnivalTree(TreeNode* root) &#123;        bool flag&#x3D;true;        int val&#x3D;root-&gt;val;        dfs(root,flag,val);        return flag;    &#125;    void dfs(TreeNode* root,bool &amp;flag,int val)    &#123;        if(root&#x3D;&#x3D;NULL)return;        if(root-&gt;left!&#x3D;NULL&amp;&amp;root-&gt;left-&gt;val!&#x3D;val)flag&#x3D;false;        if(root-&gt;right!&#x3D;NULL&amp;&amp;root-&gt;right-&gt;val!&#x3D;val)flag&#x3D;false;        dfs(root-&gt;left,flag,val);        dfs(root-&gt;right,flag,val);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h4><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="ex1.jpg (622×182) (leetcode.com)"></p><p>输入：p = [1,2,3], q = [1,2,3]<br>输出：true</p><p>还是遍历树，不过这次是同时遍历两个，还要对比他们的val值。注意有一点，对比root-&gt;val时要考虑到节点为NULL的情况，这会使程序报错，所以对比值前我们应该先判断一下两个节点是否为NULL，如果两个都为NULL那就直接return结束程序，如果只有一个为空就把flag改为false（一个节点有值一个节点没值肯定不一样），如果都不为空就对比val。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSameTree(TreeNode* p, TreeNode* q) &#123;        bool flag&#x3D;true;        dfs(p,q,flag);        return flag;    &#125;    void dfs(TreeNode* p, TreeNode* q,bool &amp;flag) &#123;        if(!flag)return;        if(p&#x3D;&#x3D;NULL&amp;&amp;q&#x3D;&#x3D;NULL)return;        else if(p&#x3D;&#x3D;NULL&amp;&amp;q!&#x3D;NULL||p!&#x3D;NULL&amp;&amp;q&#x3D;&#x3D;NULL)        &#123;            flag&#x3D;false;            return;        &#125;        if(p-&gt;val!&#x3D;q-&gt;val)flag&#x3D;false;        dfs(p-&gt;left,q-&gt;left,flag);        dfs(p-&gt;right,q-&gt;right,flag);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="101-对称二叉树和剑指-Offer-28-对称的二叉树（这两题完全一样，我们放在一起说）"><a href="#101-对称二叉树和剑指-Offer-28-对称的二叉树（这两题完全一样，我们放在一起说）" class="headerlink" title="101. 对称二叉树和剑指 Offer 28. 对称的二叉树（这两题完全一样，我们放在一起说）"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a>和<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a>（这两题完全一样，我们放在一起说）</h4><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p>​    1</p><p>   / <br>  2   2<br> / \ / <br>3  4 4  3</p><p>这题就是上题的翻版，不过上题比较的是相同的子节点，即left和left比，right和right比。这题是left和right比，right和left比。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        bool flag&#x3D;true;        dfs(root-&gt;left,root-&gt;right,flag);        return flag;    &#125;    void dfs(TreeNode *p,TreeNode*q,bool &amp;flag)    &#123;        if(!flag)return;        if(!p&amp;&amp;!q)return;        else if(!p&amp;&amp;q || p&amp;&amp;!q)        &#123;            flag&#x3D;false;            return;        &#125;        if(p-&gt;val!&#x3D;q-&gt;val)flag&#x3D;false;        dfs(p-&gt;left,q-&gt;right,flag);        dfs(p-&gt;right,q-&gt;left,flag);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AcWing——算法基础"><a href="#AcWing——算法基础" class="headerlink" title="AcWing——算法基础"></a>AcWing——算法基础</h2><h4 id="842-排列数字-AcWing题库"><a href="#842-排列数字-AcWing题库" class="headerlink" title="842. 排列数字 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/844/">842. 排列数字 - AcWing题库</a></h4><p>给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>按字典序输出所有排列方案，每个方案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤7</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 2 31 3 22 1 32 3 13 1 23 2 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是我们第一次接触到DFS（深度优先搜索）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将  <em>回溯</em>  到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。</p><p>这里排列数字的过程就是，我们要组成一个三位数的数字，第一位的可能性有1、2、3，我们先选1，第二位的可能性就剩2、3，我们选2，第三位就只剩3了，这条路搜索完毕，我们回溯到第二位上，选3为第二位，这样第三位就只剩2了，这条路也搜索完毕，我们回溯到第二位上，第二位可能的结果也都搜索完，我们回溯到第一位上，选数字2为第一位，然后继续搜…………这样最后我们就可以拿到所有的数。</p><p>我们准备一个int数组math来存放结果，一个bool数组st来告诉我们哪些数不能用，写一个递归函数dfs来进行我们的搜索，只有一个参数u，dfs进来先判断u和n是否相同，如果相同则输出math里存放的结果（要注意换行）。如果不相同我们就开始for(int i=0;i&lt; n;i++)遍历，判断st[i]的值是否为true，如果为true说明i表示的数我们已经使用过了，如果为false说明这个数我们没用过，可以放在第u位上，所有我们math[u]=i，同时把st[i]改为true告诉程序这个数已经被用过了。然后我们递归调用dfs(u+1)，下面是回溯的操作，我们要把数变回原来的样子，即这个数没被使用过的样子st[i]=false。这样我们最后就能获得所有的结果。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100010;int n;int math[N];bool st[N];void dfs(int u)&#123;    if(u&#x3D;&#x3D;n)    &#123;        for(int i&#x3D;0;i&lt;n;i++)printf(&quot;%d &quot;,math[i]);        cout&lt;&lt;endl;        return;    &#125;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)    &#123;        if(!st[i])        &#123;            st[i]&#x3D;true;            math[u]&#x3D;i;            dfs(u+1);            st[i]&#x3D;false;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;math[i]);    dfs(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="843-n-皇后问题-AcWing题库"><a href="#843-n-皇后问题-AcWing题库" class="headerlink" title="843. n-皇后问题 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/845/">843. n-皇后问题 - AcWing题库</a></h4><p>n−n−皇后问题是指将 n 个皇后放在 n×n的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p><p><img src="https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png" alt="1_597ec77c49-8-queens.png"></p><p>现在给定整数 n，请你输出所有的满足条件的棋子摆法。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含整数 n。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>每个解决方案占 n 行，每行输出一个长度为 nn 的字符串，用来表示完整的棋盘状态。</p><p>其中 <code>.</code> 表示某一个位置的方格状态为空，<code>Q</code> 表示某一个位置的方格上摆着皇后。</p><p>每个方案输出完成后，输出一个空行。</p><p><strong>注意：行末不能有多余空格。</strong></p><p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤9</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">.Q.....QQ.....Q...Q.Q......Q.Q..<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DFS中最最最最最最最最最经典的八皇后问题，我们用的就是深度优先搜索的方法来写这道题，拿一个二维数组来模拟棋盘的样子，Q代表皇后的位置，我们的想法是先把皇后放在所有可能的地方上，每放一个皇后，就判断这个皇后同行同列同斜列上有没有皇后，如果有就说明这个方法不可行，然后回溯，然后再选新地方放…………以此类推。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100;int n;char queen[N][N];bool col[N],dg[N],udg[N];void dfs(int u)&#123;    if(u&#x3D;&#x3D;n)    &#123;        for(int i&#x3D;0;i&lt;n;i++)cout&lt;&lt;queen[i]&lt;&lt;endl;        cout&lt;&lt;endl;        return;    &#125;    for(int i&#x3D;0;i&lt;n;i++)    &#123;        if(!col[i]&amp;&amp;!dg[i+u]&amp;&amp;!udg[n-u+i])        &#123;            queen[u][i]&#x3D;&#39;Q&#39;;            col[i]&#x3D;dg[u+i]&#x3D;udg[n-u+i]&#x3D;true;            dfs(u+1);            col[i]&#x3D;dg[u+i]&#x3D;udg[n-u+i]&#x3D;false;            queen[u][i]&#x3D;&#39;.&#39;;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)        for(int j&#x3D;0;j&lt;n;j++)            queen[i][j]&#x3D;&#39;.&#39;;    dfs(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结：2021-10-25——10-31</title>
      <link href="/2021/10/31/zhou-zong-jie-2021-10-25-10-31/"/>
      <url>/2021/10/31/zhou-zong-jie-2021-10-25-10-31/</url>
      
        <content type="html"><![CDATA[<h1 id="周总结：2021-10-25——10-31"><a href="#周总结：2021-10-25——10-31" class="headerlink" title="周总结：2021-10-25——10-31"></a>周总结：2021-10-25——10-31</h1><h3 id="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"><a href="#这里是这一周来刷题时印象比较深的几道题，挑出来做个总结" class="headerlink" title="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"></a>这里是这一周来刷题时印象比较深的几道题，挑出来做个总结</h3><h4 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h4><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>进阶：</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</p><p>示例 1:</p><p>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        queue&lt;int&gt;que;        int n &#x3D; nums.size();        int m &#x3D; k % n;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            que.push(nums[i]);        &#125;        while(m--)        &#123;            int num&#x3D;que.front();            que.pop();            que.push(num);        &#125;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            nums[i]&#x3D;que.front();            que.pop();        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_map&lt;int,int&gt;mymap;        stack&lt;int&gt;sta;        vector&lt;int&gt;v;        int n&#x3D;nums1.size();        for(int i&#x3D;nums2.size()-1;i&gt;&#x3D;0;i--)        &#123;            int num &#x3D; nums2[i];            while(!sta.empty()&amp;&amp;sta.top()&lt;num)            &#123;                sta.pop();            &#125;            mymap[num]&#x3D;sta.empty()?-1:sta.top();            sta.push(num);        &#125;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            v.push_back(mymap[nums1[i]]);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        if(s.size()&#x3D;&#x3D;0)        &#123;            return 0;        &#125;        int len&#x3D;0;        string str;        int n&#x3D;s.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            for(int j&#x3D;i;j&lt;n;j++)            &#123;                string str1;                str1+&#x3D;s[j];                string::size_type idx &#x3D; str.find( str1 );                if(str.size()!&#x3D;0&amp;&amp;idx !&#x3D; string::npos)                &#123;                    break;                &#125;                else                &#123;                    str+&#x3D;str1;                &#125;            &#125;                        if(len&lt;str.size())            &#123;                len&#x3D;str.size();            &#125;            str.clear();        &#125;                return len;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h4><p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p><p>进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p><p>示例 1：</p><p>输入：nums = [1,2,1,3,2,5]<br>输出：[3,5]<br>解释：[5, 3] 也是有效的答案。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        vector&lt;int&gt;v;        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(i+1&gt;&#x3D;n&amp;&amp;v.size()&lt;&#x3D;1)            &#123;                v.push_back(nums[i]);            &#125;            else            &#123;                if(nums[i]!&#x3D;nums[i+1])                &#123;                    v.push_back(nums[i]);                       if(v.size()&#x3D;&#x3D;2)                    &#123;                        break;                    &#125;                                                                &#125;                else                &#123;                    int num&#x3D;nums[i];                    while(nums[i]&#x3D;&#x3D;num)                    &#123;                        i++;                    &#125;                    i--;                &#125;            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-30每日刷题打卡</title>
      <link href="/2021/10/30/2021-10-30-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/30/2021-10-30-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-30每日刷题打卡"><a href="#2021-10-30每日刷题打卡" class="headerlink" title="2021-10-30每日刷题打卡"></a>2021-10-30每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h4><p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p><p>进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p><p>示例 1：</p><p>输入：nums = [1,2,1,3,2,5]<br>输出：[3,5]<br>解释：[5, 3] 也是有效的答案。</p><p>用哈希计数，准备一个unordered_map容器mymap，遍历nums，用mymap计算每个数字出现的次数。最后从mymap里找到出现次数为1的两个数，返回即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int,int&gt;mymap;        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            mymap[nums[i]]++;        &#125;        vector&lt;int&gt;v;        for(auto i:mymap)        &#123;            if(i.second&#x3D;&#x3D;1)            &#123;                v.push_back(i.first);            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进阶——常数空间：就准备一个vector容器v来存结果的两个数，对nums排序，遍历nums，每次判断当前数是否和下一个数相同，如果不相同就把数插入v中，如果相同就持续遍历，直到不相同为止。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        vector&lt;int&gt;v;        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(i+1&gt;&#x3D;n&amp;&amp;v.size()&lt;&#x3D;1)            &#123;                v.push_back(nums[i]);            &#125;            else            &#123;                if(nums[i]!&#x3D;nums[i+1])                &#123;                    v.push_back(nums[i]);                       if(v.size()&#x3D;&#x3D;2)                    &#123;                        break;                    &#125;                                                                &#125;                else                &#123;                    int num&#x3D;nums[i];                    while(nums[i]&#x3D;&#x3D;num)                    &#123;                        i++;                    &#125;                    i--;                &#125;            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/789/">787. 归并排序 - AcWing题库</a></p><p>给定你一个长度为 n 的整数数列。</p><p>请你使用归并排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">53 1 2 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>归并排序也是分治的思想，把一串数组对半分，直到分成一个个数，在把数两个两个的组合成有序对数。比如我们把6 2 4 5 3 1这个数组进行排序，最终分成6和2和4和5和3和1这六个数组，然后两两组合成2 6、4 5、3 1，（组合的方式是，拿一个数组tmp来存，把两个目标数组里的数进行比较，每次挑小的那个放入tmp中即可），再组合成2 4 5 6、3 1，再组合就成了1 2 3 4 5 6，这就是归并排序，即分治后归并。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;1e6+5;int n;int nums[N],tmp[N];void merge_sort(int nums[],int l,int r)&#123;    if(l&gt;&#x3D;r)return;    int mid&#x3D;(l+r)&#x2F;2;    merge_sort(nums,l,mid);    merge_sort(nums,mid+1,r);    int k&#x3D;0,i&#x3D;l,j&#x3D;mid+1;    while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;r)    &#123;        if(nums[i]&lt;&#x3D;nums[j])tmp[k++]&#x3D;nums[i++];        else tmp[k++]&#x3D;nums[j++];    &#125;    while(i&lt;&#x3D;mid)tmp[k++]&#x3D;nums[i++];    while(j&lt;&#x3D;r)tmp[k++]&#x3D;nums[j++];        for(i&#x3D;l,j&#x3D;0;i&lt;&#x3D;r;i++,j++)        nums[i]&#x3D;tmp[j];&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;nums[i]);    merge_sort(nums,0,n-1);    for(int i&#x3D;0;i&lt;n;i++)printf(&quot;%d &quot;,nums[i]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-29每日刷题打卡</title>
      <link href="/2021/10/29/2021-10-29-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/29/2021-10-29-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-29每日刷题打卡"><a href="#2021-10-29每日刷题打卡" class="headerlink" title="2021-10-29每日刷题打卡"></a>2021-10-29每日刷题打卡</h1><h2 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h2><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/woGGnF/">间隔删除链表结点 - 力扣 (LeetCode) 竞赛 (leetcode-cn.com)</a></p><p>给你一个链表的头结点 <code>head</code>，每隔一个结点删除另一个结点（要求保留头结点）。<br>请返回最终链表的头结点。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>head = [1,2,3,4]</code></p><p>输出: <code>[1,3]</code></p><p>解释：<br>蓝色结点为删除的结点</p><p>  <img src="https://pic.leetcode-cn.com/1622545030-DwtsVD-image.png" alt="08"></p></blockquote><p>开头写一个指针指向head，用这个指针遍历，一次遍历跳过当前节点，一次遍历直接往下走没有多余操作。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* deleteListNode(ListNode* head) &#123;        ListNode*p,*q;        p&#x3D;head;        q&#x3D;(ListNode*)malloc(sizeof(ListNode));        q-&gt;next&#x3D;p;        int i&#x3D;1;        while(p!&#x3D;NULL&amp;&amp;p-&gt;next!&#x3D;NULL)        &#123;            if(i&#x3D;&#x3D;1)            &#123;                i&#x3D;0;                p-&gt;next&#x3D;p-&gt;next-&gt;next;            &#125;            else            &#123;                i++;                p&#x3D;p-&gt;next;            &#125;        &#125;        return q-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/9Rs2aO/">柱状图分析 - 力扣 (LeetCode) 竞赛 (leetcode-cn.com)</a></p><p>某柱状图上共有 N 个柱形，数组 <code>heights</code> 中按照排列顺序记录了每个柱形的高度。假定任选 <code>cnt</code> 个柱形可组成一个柱形组，请在所有可能的柱形组中，找出最大高度与最小高度的差值为最小的柱形组，按高度升序返回该柱形组。若存在多个柱形组满足条件，则返回第一个元素最小的柱形组。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>heights = [3,2,7,6,1,8], cnt = 3</code></p><p>输出：<code>[1,2,3]</code></p><p>解释：[1,2,3] 与 [6,7,8] 都符合在所有的柱形组中，最大高度与最小高度的差值为最小的条件，选择第一个元素最小的 [1,2,3] 返回。</p></blockquote><p>先对heights进行排序，然后用长度为cnt的滑动窗口持续找。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; analysisHistogram(vector&lt;int&gt;&amp; heights, int cnt) &#123;        sort(heights.begin(),heights.end());        vector&lt;int&gt;v;        int min&#x3D;1000000,n;        for(int i&#x3D;0;i&lt;&#x3D;heights.size()-cnt;i++)            &#123;            int num&#x3D;heights[cnt+i-1]-heights[i];            if(num&lt;min)                &#123;                n&#x3D;i;                min&#x3D;num;            &#125;        &#125;        for(int i&#x3D;n;i&lt;n+cnt;i++)            &#123;            v.push_back(heights[i]);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-28每日刷题打卡</title>
      <link href="/2021/10/28/2021-10-28-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/28/2021-10-28-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-28每日刷题打卡"><a href="#2021-10-28每日刷题打卡" class="headerlink" title="2021-10-28每日刷题打卡"></a>2021-10-28每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="869-重新排序得到-2-的幂"><a href="#869-重新排序得到-2-的幂" class="headerlink" title="869. 重新排序得到 2 的幂"></a><a href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></h4><p>给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p><p>如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。</p><p>示例 1：</p><p>输入：1<br>输出：true</p><p>说是通过排序来判断能不能组成2的幂数那就不用管啥顺序了，直接判断这个数的组成就行（比如16就是1个1和1个6组成）。 先是看到2的幂，一看到条件数最大也就10^9,那就直接整个蠢方法，拿个字符串数组把小于10^9的2的幂全存进去（包括1）。再准备两个map容器，第一个拿来存所给数的组成成分，遍历我们的字符串数组，就找size和所给数位数相等的元素就行，遍历到后用第二个map容器来统计这个字符串的所给成分，之后拿两个map容器做对比，如果相同就可以返回true，如果不相等就把第二个map清空开始找下一个字符串。要是遍历完后还没能返回true那就返回false。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool reorderedPowerOf2(int n) &#123;        string math[]&#x3D;&#123;&quot;1&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;16&quot;,&quot;32&quot;,&quot;64&quot;,&quot;128&quot;,&quot;256&quot;,&quot;512&quot;,&quot;1024&quot;,&quot;2048&quot;,&quot;4096&quot;,                       &quot;8192&quot;,&quot;16384&quot;,&quot;32768&quot;,&quot;65536&quot;,&quot;131072&quot;,&quot;262144&quot;,&quot;524288&quot;,&quot;1048576&quot;,                       &quot;2097152&quot;,&quot;4194304&quot;,&quot;8388608&quot;,&quot;16777216&quot;,&quot;33554432&quot;,&quot;67108864&quot;,&quot;134217728&quot;,                       &quot;268435456&quot;,&quot;536870912&quot;&#125;;        string num;        vector&lt;int&gt;v;        unordered_map&lt;char,int&gt;num_map;        unordered_map&lt;char,int&gt;math_map;        while(n!&#x3D;0)        &#123;            v.push_back(n%10);            n&#x2F;&#x3D;10;        &#125;        int m&#x3D;v.size();        for(int i&#x3D;m-1;i&gt;&#x3D;0;i--)        &#123;            num+&#x3D;v[i]+48;        &#125;        for(int i&#x3D;0;i&lt;m;i++)        &#123;            num_map[num[i]]++;        &#125;        for(int i&#x3D;0;i&lt;30;i++)        &#123;            if(math[i].size()&#x3D;&#x3D;m)            &#123;                for(int j&#x3D;0;j&lt;m;j++)                &#123;                    math_map[math[i][j]]++;                &#125;                for(int i&#x3D;0;i&lt;m;i++)                &#123;                    if(math_map[num[i]]!&#x3D;num_map[num[i]])                    &#123;                        math_map.clear();                        break;                    &#125;                &#125;                if(math_map.size()!&#x3D;0)                &#123;                    return true;                &#125;            &#125;            else if(math[i].size()&gt;m)            &#123;                break;            &#125;        &#125;        return false;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ACWing——算法基础"><a href="#ACWing——算法基础" class="headerlink" title="ACWing——算法基础"></a>ACWing——算法基础</h2><p><a href="https://www.acwing.com/problem/content/787/">785. 快速排序 - AcWing题库</a></p><p>给定你一个长度为 nn 的整数数列。</p><p>请你使用快速排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">53 1 2 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要用到分治的思想，即把数组分成一部分一部分的来解决。比如4 1 3 2 5，我们先取一个中间值x，随便取，这里我们取2，然后把数组分成两截，大于等于x的放在数组右边，小于等于的我们放在左边。（放的方法我们可以用双指针，一个l在最左边（找大于等于x的值），一个r在最右边（找小于等于x的值），开始遍历，l遍历到4的时候，因为大于x所以就不往前走了，到r走，r走到5，大于x，继续走，走到2小于x了，停下来，然后做个判断，如果l&lt;j，那就把两者的数据交换一下，这样数组就变成了2 1 3 4 5，两个指针继续走，当l&gt;j时结束循环，这样大于等于2的数都在右边了，小于等于2的数都在左边），然后我们把左边的数组继续送去如上操作，右边也是，知道数组里只有一个元素为止。这就是分治——分成一个个小的解决。当一切分完后，排序也排好了。时间复杂度为nlogn，如果被数据针对会变成n^2.</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1e6 + 10;int n;int nums[N];void quick_sort(int nums[], int l, int r)&#123;    if (l &gt;&#x3D; r)return;    int x &#x3D; nums[(l+r)&#x2F;2], i &#x3D; l-1, j &#x3D; r+1 ;    while (i &lt; j)    &#123;        do i++;while(nums[i]&lt;x);        do j--;while(nums[j]&gt;x);        if (i &lt; j)swap(nums[i], nums[j]);    &#125;    quick_sort(nums, l, j);    quick_sort(nums, j + 1, r);&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i &#x3D; 0; i &lt; n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);    &#125;    quick_sort(nums, 0, n - 1);    for (int i &#x3D; 0; i &lt; n; i++)    &#123;        printf(&quot;%d &quot;, nums[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/788/">786. 第k个数 - AcWing题库</a></p><p>给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 kk 个数。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 k。</p><p>第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整数数列。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示数列的第 k 小数。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>1≤k≤n</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">5 32 4 1 5 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这就是上面的题，为了加深上面的印象，只不过这里不是输出数组，而是输出数组索引为k-1的那个元素。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;1e6+10;int n;int k;int nums[N];void quick_sort(int nums[],int l,int r)&#123;    if(l&gt;&#x3D;r)return ;    int x&#x3D;nums[(l+r)&#x2F;2],i&#x3D;l-1,j&#x3D;r+1;    while(i&lt;j)    &#123;        do        &#123;            i++;        &#125;while(nums[i]&lt;x);        do        &#123;            j--;        &#125;while(nums[j]&gt;x);        if(i&lt;j) swap(nums[i],nums[j]);    &#125;    quick_sort(nums,l,j);    quick_sort(nums,j+1,r);&#125;int main()&#123;    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);    for(int i&#x3D;0;i&lt;n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;nums[i]);    &#125;    quick_sort(nums,0,n-1);    cout&lt;&lt;nums[k-1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-27每日刷题打卡</title>
      <link href="/2021/10/27/2021-10-27-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/27/2021-10-27-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-27每日刷题打卡"><a href="#2021-10-27每日刷题打卡" class="headerlink" title="2021-10-27每日刷题打卡"></a>2021-10-27每日刷题打卡</h1><h2 id="力扣——算法入门"><a href="#力扣——算法入门" class="headerlink" title="力扣——算法入门"></a>力扣——算法入门</h2><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a></h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>示例 1：</p><p>输入：s = [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>简简单单的双指针</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int left&#x3D;0,right&#x3D;s.size()-1;        while(left&lt;right)        &#123;            char c&#x3D;s[left];            s[left]&#x3D;s[right];            s[right]&#x3D;c;            left++;            right--;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></h4><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p>示例：</p><p>输入：”Let’s take LeetCode contest”<br>输出：”s’teL ekat edoCteeL tsetnoc”</p><p>用上快慢指针，一个慢指针left，一个快指针right，初始都指向0，开始遍历，当right&gt;=s.size()时结束循环。每次遍历时判断s[left]是否是空格，如果是，left和right都++；如果不是空格，则right先走，走到right的下一个为空格时停下（因为结尾处没空格，所以要加个判断right&lt;n，防止越界报错），然后left和right开始呼唤元素，换完后两个指针去往之前right停下的位置，继续下一次遍历。最后返回s。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    string reverseWords(string s) &#123;        int left&#x3D;0,right&#x3D;0,n&#x3D;s.size();        while(right&lt;n)        &#123;            if(s[left]&#x3D;&#x3D;&#39; &#39;)            &#123;                left++;                right++;            &#125;            else            &#123;                while(right+1&lt;n&amp;&amp;s[right+1]!&#x3D;&#39; &#39;)                &#123;                    right++;                &#125;                int m&#x3D;right+1;                while(left&lt;right)                &#123;                    char c&#x3D;s[left];                    s[left]&#x3D;s[right];                    s[right]&#x3D;c;                    left++;                    right--;                &#125;                left&#x3D;m;                right&#x3D;m;            &#125;        &#125;        return s;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：</p><p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p><p>还是用快慢指针走，准备两个指针，一个p一个q，初始都指向head，开始遍历，当q为空或q的next为空时结束遍历。每次p走一格，q走两格，这也p的位置就始终在q与头结点的位置的中间处，那么当q走到末尾时，p自然就为链表的中间结点了。遍历结束后返回p即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        ListNode*p,*q;        p&#x3D;head;        q&#x3D;head;        while(q!&#x3D;NULL&amp;&amp;q-&gt;next!&#x3D;NULL)        &#123;            p&#x3D;p-&gt;next;            q&#x3D;q-&gt;next;            q&#x3D;q-&gt;next;        &#125;        return p;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="image-20211027090622223"></p><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p><p>继续快慢指针,准备三个指针p,q,o，p-&gt;next指向head，o指向p，q指向head。q做快指针先走，走n格之后q和p一起走，当q为NULL时，p-&gt;next就是我们要的倒数第n个节点了，我们直接用p-&gt;next=p-&gt;next-&gt;next跳过他就好，最后返回o-&gt;next（o-&gt;next指向的是修改好的链表）。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode *p,*q,*o;        p&#x3D;(ListNode*)malloc(sizeof(ListNode));        p-&gt;next&#x3D;head;        q&#x3D;head;        o&#x3D;p;        while(n--)        &#123;            q&#x3D;q-&gt;next;        &#125;        while(q!&#x3D;NULL)        &#123;            q&#x3D;q-&gt;next;            p&#x3D;p-&gt;next;        &#125;        p-&gt;next&#x3D;p-&gt;next-&gt;next;        return o-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>准备一个数len维护最长序列的长度（初始化为0），字符串str计算各个位置上出发最高的子序列为多少。for遍历s，内部嵌套一个for，内部for拿来计算最长子序列，每次从当前遍历元素开始计算，遍历一个新的字符时，用find判断字符串str中有没有相同的字符，如果没有就把字符接到str上，如果有就跳出当前循环，把str的长度和len做对比，如果大于len就把str的长度赋给len，判断完之后要清空str以免造成误差。最后返回len。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        if(s.size()&#x3D;&#x3D;0)        &#123;            return 0;        &#125;        int len&#x3D;0;        string str;        int n&#x3D;s.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            for(int j&#x3D;i;j&lt;n;j++)            &#123;                string str1;                str1+&#x3D;s[j];                string::size_type idx &#x3D; str.find( str1 );                if(str.size()!&#x3D;0&amp;&amp;idx !&#x3D; string::npos)                &#123;                    break;                &#125;                else                &#123;                    str+&#x3D;str1;                &#125;            &#125;                        if(len&lt;str.size())            &#123;                len&#x3D;str.size();            &#125;            str.clear();        &#125;                return len;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h4><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p><p>换句话说，s1 的排列之一是 s2 的 子串 。</p><p>示例 1：</p><p>输入：s1 = “ab” s2 = “eidbaooo”<br>输出：true<br>解释：s2 包含 s1 的排列之一 (“ba”).</p><p>这题一开始觉得老恶心了，想着是把s1可能的排序都找一遍然后在s2里判断有没有相同的序列，后来发现不用这么麻烦，只要找s2里的字符串组成有没有和s1完全一样的就行（比如s1由一个c两个b组成，那只要在s2里也找一个由一个c两个b组成的字符串就行）。既然找成分那就要用上map容器了，准备两个map容器，一个s1map存字符串s1的组成情况，一个s2map存s2中子字符串的组成情况，先遍历一遍s1获得s1的组成情况并存在s1map里，然后开始遍历s2，在for里再嵌套一个for，每次从当前字符开始向前遍历s1.size()个位置，保存这段字符串的组成情况存在s2map里，然后判断s1map和s2map的组成情况是否相同，如果相同就返回true，如果不相同就清空s2map并直接进入下次循环。要是知道末尾也没能返回true就返回false。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool checkInclusion(string s1, string s2) &#123;        unordered_map&lt;char, int&gt;s1map;        unordered_map&lt;char, int&gt;s2map;        int n &#x3D; s1.size(), m &#x3D; s2.size();        for (int i &#x3D; 0; i &lt; n; i++)        &#123;            s1map[s1[i]]++;        &#125;        for (int i &#x3D; 0; i &lt; m; i++)        &#123;            for (int j &#x3D; i; j &lt; i+n; j++)            &#123;                if(j&gt;&#x3D;m)                &#123;                    break;                &#125;                s2map[s2[j]]++;            &#125;            for (int k &#x3D; 0; k &lt; n; k++)            &#123;                if (s2map[s1[k]] !&#x3D; s1map[s1[k]])                &#123;                    s2map.clear();                    break;                &#125;            &#125;            if (s2map.size() !&#x3D; 0)            &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-26每日刷题打卡</title>
      <link href="/2021/10/26/2021-10-26-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/26/2021-10-26-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-26每日刷题打卡"><a href="#2021-10-26每日刷题打卡" class="headerlink" title="2021-10-26每日刷题打卡"></a>2021-10-26每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p><p>这题有两个方法，第一种节省空间但速度慢，第二种速度快但占用空间较多</p><p>第一种：创建一个vector容器v来存放结果，直接for遍历nums1，里面再放上一个for用来遍历nums2，每次遍历nums1新的元素时去nums2里找到和当前nums1相同的元素，找到以后继续遍历，如果有大于它的数就把那个数插入v中并break结束循环，如果没有大于他的数就插入一个-1。当nums1遍历完后结束循环，返回v即可</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;int&gt;v;        int n&#x3D;nums1.size(),m&#x3D;nums2.size();        bool b&#x3D;false;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            for(int j&#x3D;0;j&lt;m;j++)            &#123;                if(b&amp;&amp;nums2[j]&gt;nums1[i])                &#123;                    v.push_back(nums2[j]);                    break;                &#125;                if(nums1[i]&#x3D;&#x3D;nums2[j])                &#123;                    b&#x3D;true;                &#125;            &#125;            b&#x3D;false;            if(v.size()&#x3D;&#x3D;i)            &#123;                v.push_back(-1);            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种：要用上map、stack的知识，准备一个unordered_map容器mymap，一个stack容器sta，一个vector容器v。先遍历nums2，从最后一个元素开始遍历，每次遍历判断栈sta顶部元素是否小于当前元素，如果小于就持续出栈，知道栈为空或顶端元素大于当前遍历元素，然后mymap开始记录当前元素之后有无最大值，mymap[nums2[i]]==sta.empty?-1:sta.top()，这里意思是，如果栈为空，说明我们之前遍历过的元素没有大于当前元素的（因为都在前面出栈弹掉了），如果栈不为空，就说明栈顶元素是大于我们当前元素的，把这个元素赋给mymap，事后要将当前元素入栈。遍历完后开始遍历nums1，每次经由mymap[nums[i]]获知当前元素之后有没有大于它的元素。把结果插入v中。最后返回v</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_map&lt;int,int&gt;mymap;        stack&lt;int&gt;sta;        vector&lt;int&gt;v;        int n&#x3D;nums1.size();        for(int i&#x3D;nums2.size()-1;i&gt;&#x3D;0;i--)        &#123;            int num &#x3D; nums2[i];            while(!sta.empty()&amp;&amp;sta.top()&lt;num)            &#123;                sta.pop();            &#125;            mymap[num]&#x3D;sta.empty()?-1:sta.top();            sta.push(num);        &#125;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            v.push_back(mymap[nums1[i]]);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h4><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>进阶：</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</p><p>示例 1:</p><p>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p><p>原本试了下看看能不能把O(1)的算法写出来，结果超时了。。。我还是写简单的吧</p><p>准备一个vector容器v，遍历一遍nums，每次在v的（i+k)%nums.size() 位置上放上nums[i]的值（%nums.size()是为了防止数组越界，同时把旋转后的数插入v前面的位置上。)，但由于这里没有返回值，是要修改nums里的值，所以我们遍历一遍v把值复制给nums。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        int n&#x3D;nums.size();        vector&lt;int&gt;v(n);        for(int i&#x3D;0;i&lt;n;i++)        &#123;            v[(i+k)%n]&#x3D;nums[i];        &#125;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            nums[i]&#x3D;v[i];        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个方法，利用队列queue来进行旋转操作（出队后入队）。准备一个queue容器que，将nums从尾部数据开始依次入队que（先进先出），然后把队头元素出队再入队，一个进行k次，之后队列里的位置就是旋转好的序列了，再把que的数据复制在nums里即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        queue&lt;int&gt;que;        int n &#x3D; nums.size();        int m &#x3D; k % n;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            que.push(nums[i]);        &#125;        while(m--)        &#123;            int num&#x3D;que.front();            que.pop();            que.push(num);        &#125;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            nums[i]&#x3D;que.front();            que.pop();        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h4><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>尽量减少不知道咋减少。。。嘛反正是没用额外的数组。</p><p>准备两个指针l和r，初始都为0，用两个指针来遍历nums，当l或r大于等于nums.size()时结束循环，如果l当前指向的位置数不为0，则l和r同时++，如果l指向的位置数为0，则r往前移动，直到nums[r]不为0，然后交换l和r位置上的元素（这里要注意r可能会超出nums.size()，所以要加判断如果r大于等于nums.size()就结束循环）。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;    int l &#x3D; 0, r &#x3D; 0, n &#x3D; nums.size();    while (r &lt; n)    &#123;        if (nums[l] !&#x3D; 0)        &#123;            l++;            r++;        &#125;        else        &#123;            while (r &lt; n&amp;&amp;nums[r] &#x3D;&#x3D; 0 )            &#123;                r++;                            &#125;            if (r &gt;&#x3D; n)            &#123;                break;            &#125;            int math &#x3D; nums[l];            nums[l] &#x3D; nums[r];            nums[r] &#x3D; math;        &#125;    &#125;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照 非递减顺序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p><p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p><p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p><p>示例 1：</p><p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p><p>双指针写法，因为这数组是递增的，所以我们可以用头尾双指针来写，一个left=0，一个right=numbers.size()-1，一个vector容器v，开始遍历，每次判断numbers[left]+numbers[right]的值，如果等于目标值就把left和right插入v中，break掉循环并返回v。如果大于目标值，说明number[right]的值过大（总不能是left太大，人家已经最小了），把right–以减小numbers[right]的值。如果小于目标值说明numbers[left]的值过下，把left++。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;        int i&#x3D;0,j&#x3D;numbers.size()-1;        vector&lt;int&gt;v;       while(i&lt;j)       &#123;           if(numbers[i]+numbers[j]&#x3D;&#x3D;target)           &#123;               v.push_back(i+1);               v.push_back(j+1);               break;           &#125;           else if(numbers[i]+numbers[j]&gt;target)           &#123;               j--;           &#125;           else           &#123;               i++;           &#125;       &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/25/hello-world/"/>
      <url>/2021/10/25/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到我的个人网站！"><a href="#欢迎来到我的个人网站！" class="headerlink" title="欢迎来到我的个人网站！"></a>欢迎来到我的个人网站！</h1>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HelloWorld </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
