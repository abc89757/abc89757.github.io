<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021-11-22每日刷题打卡</title>
      <link href="/2021/11/22/2021-11-22-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/22/2021-11-22-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-22每日刷题打卡"><a href="#2021-11-22每日刷题打卡" class="headerlink" title="2021-11-22每日刷题打卡"></a>2021-11-22每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384. 打乱数组"></a><a href="https://leetcode-cn.com/problems/shuffle-an-array/">384. 打乱数组</a></h4><p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。</p><p>实现 Solution class:</p><p>Solution(int[] nums) 使用整数数组 nums 初始化对象<br>int[] reset() 重设数组到它的初始状态并返回<br>int[] shuffle() 返回数组随机打乱后的结果</p><p>示例：</p><p>输入<br>[“Solution”, “shuffle”, “reset”, “shuffle”]<br>[[[1, 2, 3]], [], [], []]<br>输出<br>[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]</p><p>解释<br>Solution solution = new Solution([1, 2, 3]);<br>solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]<br>solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]<br>solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]</p><p>不知道这题有什么意义，但这次学到了个叫做洗牌算法的东西，就是随机的打乱一个数组，每次打乱的地方都不一样。</p><p>这个洗牌算法就是，for循环从下标0开始遍历，生成一个随机数，范围是0~数组长度内，然后每次把下标为i的元素和下标为随机数的元素交换，这样就是随机打乱了数组，把数组遍历完后得到的就是随机打乱的数组了，因为随机数生成每个数的概率都是一样的，所以打乱的也是随机的不会有换了好几次结果都是一样的情况发生。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt;v;    vector&lt;int&gt;v1;    Solution(vector&lt;int&gt;&amp; nums) &#123;        v&#x3D;nums;        v1&#x3D;nums;    &#125;        vector&lt;int&gt; reset() &#123;        v&#x3D;v1;        return v;    &#125;        vector&lt;int&gt; shuffle() &#123;        int n&#x3D;v.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            int a&#x3D;(i+rand()%n)%n;            int temp&#x3D;v[a];            v[a]&#x3D;v[i];            v[i]&#x3D;temp;        &#125;        return v;    &#125;&#125;;&#x2F;** * Your Solution object will be instantiated and called as such: * Solution* obj &#x3D; new Solution(nums); * vector&lt;int&gt; param_1 &#x3D; obj-&gt;reset(); * vector&lt;int&gt; param_2 &#x3D; obj-&gt;shuffle(); *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 翻转字符串里的单词</a></h4><p>给你一个字符串 s ，逐个翻转字符串中的所有 单词 。</p><p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p><p>请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。</p><p>说明：</p><p>输入字符串 s 可以在前面、后面或者单词间包含多余的空格。<br>翻转后单词间应当仅用一个空格分隔。<br>翻转后的字符串中不应包含额外的空格。</p><p>示例 1：</p><p>输入：s = “the sky is blue”<br>输出：”blue is sky the”</p><p>先把字符串整个翻转过来，然后遍历字符串，用双指针遍历找到一个单词的头和尾，然后把这个单词调转过来，然后继续找下一个单词，循环下去即可。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    string reverseWords(string s) &#123;        int n&#x3D;s.size(),l&#x3D;0,r&#x3D;n-1,idx&#x3D;0;        reverse(s.begin(),s.end());        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(s[i]!&#x3D;&#39; &#39;)            &#123;                if(idx)s[idx++]&#x3D;&#39; &#39;;                int end&#x3D;i;                while(end&lt;n&amp;&amp;s[end]!&#x3D;&#39; &#39;)s[idx++]&#x3D;s[end++];                reverse(s.begin()+idx-end+i,s.begin()+idx);                i&#x3D;end;            &#125;        &#125;        s.erase(s.begin()+idx,s.end());        return s;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode-cn.com/problems/compare-version-numbers/">165. 比较版本号</a></h4><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p><p>示例 1：</p><p>输入：version1 = “1.01”, version2 = “1.001”<br>输出：0<br>解释：忽略前导零，”01” 和 “001” 都表示相同的整数 “1”</p><p>我们把版本号以“.”为分界线拆开来，拆成一个个数字字符串，然后我们把字符串转成数字，依次和另一个字符串的数字进行对比，根据大小决定返回-1还是1还是0。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int compareVersion(string version1, string version2) &#123;    int l &#x3D; 0, r &#x3D; 0, n &#x3D; version1.size(), m &#x3D; version2.size();    while(l&lt;n||r&lt;m)    &#123;        int x&#x3D;0;        for(l;l&lt;n;l++)            if(version1[l]&#x3D;&#x3D;&#39;.&#39;)break;            else x&#x3D;x*10+version1[l]-&#39;0&#39;;        int y&#x3D;0;        for(r;r&lt;m;r++)            if(version2[r]&#x3D;&#x3D;&#39;.&#39;)break;            else y&#x3D;y*10+version2[r]-&#39;0&#39;;        r++,l++;        if(x!&#x3D;y)return x&gt;y?1:-1;    &#125;    return 0;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h4><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。</p><p>你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。</p><p>示例 1：</p><p>输入：nums = [1,3,4,2,2]<br>输出：2</p><p>这题和我们写的环状链表可以是一样的解法，也就是快慢指针，环状链表是当走到某一点时，他会回到之前遍历的点上，这里我们遍历数组也可以用类似的方式。</p><p>题目说了数字都在1~n之间，那我们每次可以用遍历到的数字来当我们的下标，循环以往，当出现重复数字的时候，我们就会出现在同一个地方，然后快指针回到开头开始和我们走一样的速度，第二次相遇的时候的那个数就是重复数字了。比如 1 3 4 2 2，l慢指针走一格到下标0，r快指针走两步先到0，然后根据nums[0]走到下标1，l走一步到下标1，r根据nums[1]走到下标3，再根据nums[3]走到2，然后l走到3，r先走到4再走到2，l再走走到2，r先走到4再走到2，此时l和r相等，把r放回原位1，l和r同时走，l到4、r到3，l到2、r到2.此时l和r第二次相遇了，相遇的这个2就是重复的数。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int l&#x3D;0,n&#x3D;nums.size(),r&#x3D;n-1;        while(l&lt;n)        &#123;            r&#x3D;n-1;            while(l&lt;r)                if(nums[l]&#x3D;&#x3D;nums[r])return nums[l];                else r--;            l++;        &#125;        return nums[l];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结：2021-11-15——11-21</title>
      <link href="/2021/11/21/zhou-zong-jie-2021-11-15-11-21/"/>
      <url>/2021/11/21/zhou-zong-jie-2021-11-15-11-21/</url>
      
        <content type="html"><![CDATA[<h1 id="周总结：2021-11-15——11-21"><a href="#周总结：2021-11-15——11-21" class="headerlink" title="周总结：2021-11-15——11-21"></a>周总结：2021-11-15——11-21</h1><h2 id="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"><a href="#这里是这一周来刷题时印象比较深的几道题，挑出来做个总结" class="headerlink" title="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"></a>这里是这一周来刷题时印象比较深的几道题，挑出来做个总结</h2><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/023761b7beccfe21c750c1b8faf96073.png" alt="binarytree.png (200×190) (leetcode.com)"></p><p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p><p>送root去递归，每次先判断root是否为空，为空就返回root，然后创建两个节点，一个l判断左子树中有没有p或q的节点，如果有，把拿个节点赋给l，另一个节点r判断右子树。然后判断，如果l为空就返回r节点，如果r为空就返回l节点，如果都不为空说明当前的root就是最近祖先。返回即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        if(!root||root-&gt;val&#x3D;&#x3D;p-&gt;val||root-&gt;val&#x3D;&#x3D;q-&gt;val)return root;        TreeNode*l&#x3D;lowestCommonAncestor(root-&gt;left,p,q);        TreeNode*r&#x3D;lowestCommonAncestor(root-&gt;right,p,q);        if(!r)return l;        if(!l)return r;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="40-顺时针打印矩阵-AcWing题库"><a href="#40-顺时针打印矩阵-AcWing题库" class="headerlink" title="40. 顺时针打印矩阵 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/39/">40. 顺时针打印矩阵 - AcWing题库</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre class="line-numbers language-none"><code class="language-none">输入：[  [1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们从x=0,y=0处开始逐步把数存入数组里，准备四个方向：上（-1，0），右（0，1），下（1，0），左（0，-1），每次遍历的时候按照方向xy坐标的不同加在我们遍历的xy处就可以达到顺时针遍历，每当遇到边界或是到了之前的位置（转了一圈）就转方向。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;        int n&#x3D;matrix.size();        vector&lt;int&gt;v;        if(!n)return v;        int m&#x3D;matrix[0].size();        vector&lt;vector&lt;bool&gt;&gt;st(n,vector&lt;bool&gt;(m,false));        int dx[]&#x3D;&#123;-1,0,1,0&#125;,dy[]&#x3D;&#123;0,1,0,-1&#125;;        int x&#x3D;0,y&#x3D;0,d&#x3D;1;        for(int i&#x3D;0;i&lt;n*m;i++)        &#123;            v.push_back(matrix[x][y]);            st[x][y]&#x3D;true;            int a&#x3D;x+dx[d],b&#x3D;y+dy[d];            if(a&gt;&#x3D;n||a&lt;0||b&lt;0||b&gt;&#x3D;m||st[a][b])            &#123;                d&#x3D;(d+1)%4;                a&#x3D;x+dx[d],b&#x3D;y+dy[d];            &#125;            x&#x3D;a,y&#x3D;b;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="826-单链表-AcWing题库"><a href="#826-单链表-AcWing题库" class="headerlink" title="826. 单链表 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/828/">826. 单链表 - AcWing题库</a></h4><p>实现一个单链表，链表初始为空，支持三种操作：</p><ol><li>向链表头插入一个数；</li><li>删除第 k 个插入的数后面的数；</li><li>在第 k 个插入的数后插入一个数。</li></ol><p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 22 个插入的数，…第 n 个插入的数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 M，表示操作次数。</p><p>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</p><ol><li><code>H x</code>，表示向链表头插入一个数 x。</li><li><code>D k</code>，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。</li><li><code>I k x</code>，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。</li></ol><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，将整个链表从头到尾输出。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤100000<br>所有操作保证合法。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">6 4 6 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>简单的一道实现连标题，但是这里我们不能用以往的方式来new节点一个个连，因为new的效率实在太慢，我们这里有10w次操作肯定要超时，这里我们采用另一种方式来写链表。</p><p>我们用两个数组来实现链表，一个数组e来存链节点的值，一个数组ne来存对应链节点的next，比如这样一个链表2 1 4 3，这就是e里面存的值，然后ne存的是{1，2，3，-1}（-1代表结尾），意思是第一个节点在e的位置为0，值为2，它的next指针存在ne里，因为他在e的位置为0，所以它的next的位置也为0，ne[0]等于1，说明这个节点的next指向的是下标为1的节点，在e里，下标为1的是1，然后这个e[1]节点的next指针指向的是ne[1]=2。就是这么简单，然后删除操作插入操作就按照这个格式来。（你要看不懂那就直接看代码吧）</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100010;int head,idx,e[N],ne[N];void init()&#123;    head&#x3D;-1;    idx&#x3D;0;&#125;void push_head(int x)&#123;    e[idx]&#x3D;x;    ne[idx]&#x3D;head;    head&#x3D;idx++;&#125;void del_node(int k)&#123;    ne[k-1]&#x3D;ne[ne[k-1]];&#125;void push_node(int k,int x)&#123;    e[idx]&#x3D;x;    ne[idx]&#x3D;ne[k-1];    ne[k-1]&#x3D;idx++;&#125;int main()&#123;    int T;    cin&gt;&gt;T;    init();    while(T--)    &#123;        char s;        int k,x;        cin&gt;&gt;s;        if(s&#x3D;&#x3D;&#39;H&#39;)        &#123;            cin&gt;&gt;x;            push_head(x);        &#125;        else if(s&#x3D;&#x3D;&#39;D&#39;)        &#123;            cin&gt;&gt;k;            if(!k)head&#x3D;ne[head];            else del_node(k);        &#125;        else if(s&#x3D;&#x3D;&#39;I&#39;)        &#123;            cin&gt;&gt;k&gt;&gt;x;            push_node(k,x);        &#125;    &#125;    for(int i&#x3D;head;i!&#x3D;-1;i&#x3D;ne[i])cout&lt;&lt;e[i]&lt;&lt;&quot; &quot;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ca0d0d9f728f2aeda1976de9b08940e5.png" alt="exx1.jpg (322×182) (leetcode.com)"></p><p>输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</p><p>这题还是递归遍历root，准备一个sum存储最大路径和，每次把左子树和右子树分别送去下一次递归，以求得左子树和右子树谁的路径和最大，每次计算路径和有三选择，一种是左子树+root然后返回到上面的根节点，一种是右子树+root，还有一种是左子树+root+右子树。每次比较这三个值的大小，取最大的和sum作比较，如果大于sum就把sum更新。每次递归返回当前节点值和左子树或右子树的和（取最大）给上一级的节点，然后不断比较sum。当递归全部结束后把sum返回。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int sum&#x3D;INT_MIN;    int maxPathSum(TreeNode* root) &#123;        dfs(root);        return sum;    &#125;    int dfs(TreeNode*root)    &#123;        if(!root)return 0;        int l&#x3D;max(dfs(root-&gt;left),0);        int r&#x3D;max(dfs(root-&gt;right),0);        int ans&#x3D;root-&gt;val+max(l,r);        sum&#x3D;max(sum,max(ans,root-&gt;val+r+l));        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-20每日刷题打卡</title>
      <link href="/2021/11/20/2021-11-20-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/20/2021-11-20-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-20每日刷题打卡"><a href="#2021-11-20每日刷题打卡" class="headerlink" title="2021-11-20每日刷题打卡"></a>2021-11-20每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="594-最长和谐子序列"><a href="#594-最长和谐子序列" class="headerlink" title="594. 最长和谐子序列"></a><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></h4><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。</p><p>现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p><p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p><p>示例 1：</p><p>输入：nums = [1,3,2,2,5,2,3,7]<br>输出：5<br>解释：最长的和谐子序列是 [3,2,2,2,3]</p><p>这题一开始没想到的点是可以对nums排序，因为想着子序列是不能改变顺序的，所以就没想到排序来写。但后来发现可以对nums排序，因为我们要找的只是序列里相减小于等于1的序列，比如举个例子来说1 2 5 3 1 2 3 5 2 3，这段的最长子序列是6，即2 3 2 3 2 3 ，中间的5 1 我们都不理他，而且因为只相差了1，所以排序起来他们也是的相邻，即222333，所以可以进行排序。</p><p>我们先用sort对nums进行排序，然后准备两个指针l和r，一开始都指向0，在准备一个存储最大子序列长度的变量max_len，开始遍历，当l&gt;=nums.size()时结束遍历，每次遍历r先走，然后判断nums[r]-nums[l]是否小于等于1，如果满足那么r继续走，如果不满足就拿r-l判断当前子序列的长度，然后和max_len做对比取较大的，然后l++,并让r回到l的位置进行下一次遍历。最后返回最大值max_len。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int findLHS(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end());        int l &#x3D; 0, r &#x3D; 0, n &#x3D; nums.size(), max_len &#x3D; 0;        while (l &lt; n)        &#123;            if (r &lt; n &amp;&amp; nums[r] - nums[l] &lt;&#x3D; 1)r++;            else            &#123;                if (nums[r-1] - nums[l] &#x3D;&#x3D; 1)max_len &#x3D; max(max_len, r - l);                r &#x3D; ++l;            &#125;        &#125;        return max_len;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AcWing——算法基础"><a href="#AcWing——算法基础" class="headerlink" title="AcWing——算法基础"></a>AcWing——算法基础</h2><h4 id="826-单链表-AcWing题库"><a href="#826-单链表-AcWing题库" class="headerlink" title="826. 单链表 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/828/">826. 单链表 - AcWing题库</a></h4><p>实现一个单链表，链表初始为空，支持三种操作：</p><ol><li>向链表头插入一个数；</li><li>删除第 k 个插入的数后面的数；</li><li>在第 k 个插入的数后插入一个数。</li></ol><p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 22 个插入的数，…第 n 个插入的数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 M，表示操作次数。</p><p>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</p><ol><li><code>H x</code>，表示向链表头插入一个数 x。</li><li><code>D k</code>，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。</li><li><code>I k x</code>，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。</li></ol><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，将整个链表从头到尾输出。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤100000<br>所有操作保证合法。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">6 4 6 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>简单的一道实现连标题，但是这里我们不能用以往的方式来new节点一个个连，因为new的效率实在太慢，我们这里有10w次操作肯定要超时，这里我们采用另一种方式来写链表。</p><p>我们用两个数组来实现链表，一个数组e来存链节点的值，一个数组ne来存对应链节点的next，比如这样一个链表2 1 4 3，这就是e里面存的值，然后ne存的是{1，2，3，-1}（-1代表结尾），意思是第一个节点在e的位置为0，值为2，它的next指针存在ne里，因为他在e的位置为0，所以它的next的位置也为0，ne[0]等于1，说明这个节点的next指向的是下标为1的节点，在e里，下标为1的是1，然后这个e[1]节点的next指针指向的是ne[1]=2。就是这么简单，然后删除操作插入操作就按照这个格式来。（你要看不懂那就直接看代码吧）</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100010;int head,idx,e[N],ne[N];void init()&#123;    head&#x3D;-1;    idx&#x3D;0;&#125;void push_head(int x)&#123;    e[idx]&#x3D;x;    ne[idx]&#x3D;head;    head&#x3D;idx++;&#125;void del_node(int k)&#123;    ne[k-1]&#x3D;ne[ne[k-1]];&#125;void push_node(int k,int x)&#123;    e[idx]&#x3D;x;    ne[idx]&#x3D;ne[k-1];    ne[k-1]&#x3D;idx++;&#125;int main()&#123;    int T;    cin&gt;&gt;T;    init();    while(T--)    &#123;        char s;        int k,x;        cin&gt;&gt;s;        if(s&#x3D;&#x3D;&#39;H&#39;)        &#123;            cin&gt;&gt;x;            push_head(x);        &#125;        else if(s&#x3D;&#x3D;&#39;D&#39;)        &#123;            cin&gt;&gt;k;            if(!k)head&#x3D;ne[head];            else del_node(k);        &#125;        else if(s&#x3D;&#x3D;&#39;I&#39;)        &#123;            cin&gt;&gt;k&gt;&gt;x;            push_node(k,x);        &#125;    &#125;    for(int i&#x3D;head;i!&#x3D;-1;i&#x3D;ne[i])cout&lt;&lt;e[i]&lt;&lt;&quot; &quot;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="exx1.jpg (322×182) (leetcode.com)"></p><p>输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</p><p>这题还是递归遍历root，准备一个sum存储最大路径和，每次把左子树和右子树分别送去下一次递归，以求得左子树和右子树谁的路径和最大，每次计算路径和有三选择，一种是左子树+root然后返回到上面的根节点，一种是右子树+root，还有一种是左子树+root+右子树。每次比较这三个值的大小，取最大的和sum作比较，如果大于sum就把sum更新。每次递归返回当前节点值和左子树或右子树的和（取最大）给上一级的节点，然后不断比较sum。当递归全部结束后把sum返回。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int sum&#x3D;INT_MIN;    int maxPathSum(TreeNode* root) &#123;        dfs(root);        return sum;    &#125;    int dfs(TreeNode*root)    &#123;        if(!root)return 0;        int l&#x3D;max(dfs(root-&gt;left),0);        int r&#x3D;max(dfs(root-&gt;right),0);        int ans&#x3D;root-&gt;val+max(l,r);        sum&#x3D;max(sum,max(ans,root-&gt;val+r+l));        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-19每日刷题打卡</title>
      <link href="/2021/11/19/2021-11-19-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/19/2021-11-19-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-19每日刷题打卡"><a href="#2021-11-19每日刷题打卡" class="headerlink" title="2021-11-19每日刷题打卡"></a>2021-11-19每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="397-整数替换"><a href="#397-整数替换" class="headerlink" title="397. 整数替换"></a><a href="https://leetcode-cn.com/problems/integer-replacement/">397. 整数替换</a></h4><p>给定一个正整数 n ，你可以做如下操作：</p><p>如果 n 是偶数，则用 n / 2替换 n 。<br>如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。<br>n 变为 1 所需的最小替换次数是多少？</p><p>示例 1：</p><p>输入：n = 8<br>输出：3<br>解释：8 -&gt; 4 -&gt; 2 -&gt; 1</p><p>我们可以用枚举的情况来计算操作数，这就相当于一个二叉树，只要n不为1，树就向下延伸，当n为1时就是叶子节点了，然后就开始找最小深度即可。</p><p>n为偶数时我们只能/2，分支在n为奇数时该-1还是+1，我们利用二叉树的想法，如果n是偶数就除于2然后送去下次递归，如果是奇数就n+1或n-1送去递归。但有一点问题，当n为2^32-1时，我们+1会直接爆内存，所以我们把两步步骤合起来，比较+1或-1后n就是偶数了，直接/2，那我们就把这两步和一起，众所周知，整数除法是向下取整的，所以我们也不用减一了直接/2就行，至于加一我们可以先除然后再加一，比如7+1再/2是4，我们直接/2+1也是4。每次n为偶数时我们直接记上一次步骤然后把n/2送去递归，为奇数我们就记上两次步骤然后分别送n/2-1和n/2去递归，取两者的最小值，最后递归全部结束时，得到的即时最少的步骤数。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int integerReplacement(int n) &#123;        if(n&#x3D;&#x3D;1)return 0;        if(n%2&#x3D;&#x3D;0)return 1+integerReplacement(n&#x2F;2);        return 2+min(integerReplacement(n&#x2F;2+1),integerReplacement(n&#x2F;2));    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="binarytree.png (200×190) (leetcode.com)"></p><p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p><p>送root去递归，每次先判断root是否为空，为空就返回root，然后创建两个节点，一个l判断左子树中有没有p或q的节点，如果有，把拿个节点赋给l，另一个节点r判断右子树。然后判断，如果l为空就返回r节点，如果r为空就返回l节点，如果都不为空说明当前的root就是最近祖先。返回即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        if(!root||root-&gt;val&#x3D;&#x3D;p-&gt;val||root-&gt;val&#x3D;&#x3D;q-&gt;val)return root;        TreeNode*l&#x3D;lowestCommonAncestor(root-&gt;left,p,q);        TreeNode*r&#x3D;lowestCommonAncestor(root-&gt;right,p,q);        if(!r)return l;        if(!l)return r;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><p>翻转一棵二叉树。</p><p><strong>示例：</strong></p><p>输入：</p><pre class="line-numbers language-none"><code class="language-none">     4   &#x2F;   \  2     7 &#x2F; \   &#x2F; \1   3 6   9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">     4   &#x2F;   \  7     2 &#x2F; \   &#x2F; \9   6 3   1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归遍历root，每次把左右子树交换即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if(!root)return root;        TreeNode*p&#x3D;root-&gt;left;        root-&gt;left&#x3D;root-&gt;right;        root-&gt;right&#x3D;p;        invertTree(root-&gt;left);        invertTree(root-&gt;right);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="117-填充每个节点的下一个右侧节点指针-II和116-填充每个节点的下一个右侧节点指针"><a href="#117-填充每个节点的下一个右侧节点指针-II和116-填充每个节点的下一个右侧节点指针" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II和116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a>和<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h4><p>（116给的是完全二叉树，比这题简单一点，但我做法都是一样的，两题都适用）</p><p>给定一个二叉树</p><p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>示例：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt="117_sample.png (1058×361) (leetcode-cn.com)"></p><p>输入：root = [1,2,3,4,5,null,7]<br>输出：[1,#,2,3,#,4,5,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），’#’ 表示每层的末尾。</p><p>层序遍历，每次把当前节点的next指针指向同一层的下一个节点，如果没有下一个节点就指向NULL。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*&#x2F;&#x2F; Definition for a Node.class Node &#123;public:    int val;    Node* left;    Node* right;    Node* next;    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;    Node(int _val, Node* _left, Node* _right, Node* _next)        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;&#125;;*&#x2F;class Solution &#123;public:    Node* connect(Node* root) &#123;        if(!root)return root;        queue&lt;Node*&gt;que;        que.push(root);        while(que.size())        &#123;            int len&#x3D;que.size();            Node*p&#x3D;new Node(-1);            for(int i&#x3D;0;i&lt;len;i++)            &#123;                p-&gt;next&#x3D;que.front();                p&#x3D;que.front();                if(que.front()-&gt;left)que.push(que.front()-&gt;left);                if(que.front()-&gt;right)que.push(que.front()-&gt;right);                que.pop();            &#125;            p-&gt;next&#x3D;NULL;        &#125;        return root;    &#125;    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-18每日刷题打卡</title>
      <link href="/2021/11/18/2021-11-18-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/18/2021-11-18-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-18每日刷题打卡"><a href="#2021-11-18每日刷题打卡" class="headerlink" title="2021-11-18每日刷题打卡"></a>2021-11-18每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="563-二叉树的坡度"><a href="#563-二叉树的坡度" class="headerlink" title="563. 二叉树的坡度"></a><a href="https://leetcode-cn.com/problems/binary-tree-tilt/">563. 二叉树的坡度</a></h4><p>给定一个二叉树，计算 整个树 的坡度 。</p><p>一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p><p>整个树 的坡度就是其所有节点的坡度之和。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg" alt="tilt2.jpg (1231×312) (leetcode.com)"></p><p>输入：root = [1,2,3]<br>输出：1<br>解释：<br>节点 2 的坡度：|0-0| = 0（没有子节点）<br>节点 3 的坡度：|0-0| = 0（没有子节点）<br>节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）<br>坡度总和：0 + 0 + 1 = 1</p><p>准备一个全局变量ans来计算坡度总和，递归遍历二叉树，先把根节点送去遍历，每次递归一开始先判断节点是否为空，如果为空，直接返回0，（递归函数的返回值是树整体的val值和，比如上面这图的2节点，它整个树的val和就是2+3+5），然后把当前节点的左子树和右子树送去递归，返回值分别用num_l和num_r接收，然后把他俩的差值的绝对值加到ans上，这就是这个节点的坡度了，然后把当前节点的val和num_l与nums_r的总和返回。当所有递归结束后，返回ans即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int ans&#x3D;0;    int findTilt(TreeNode* root) &#123;        dfs(root);        return ans;    &#125;       int dfs(TreeNode*root)    &#123;        if(!root)return 0;        int val_num&#x3D;root-&gt;val;        int val_l&#x3D;dfs(root-&gt;left);        int val_r&#x3D;dfs(root-&gt;right);        ans+&#x3D;abs(val_l-val_r);        return val_r+val_l+val_num;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="802-区间和-AcWing题库"><a href="#802-区间和-AcWing题库" class="headerlink" title="802. 区间和 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/804/">802. 区间和 - AcWing题库</a></h4><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p><p>现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。</p><p>接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p><p>接下来 n 行，每行包含两个整数 x 和 c。</p><p>再接下来 m 行，每行包含两个整数 l 和 r。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 m 行，每行输出一个询问中所求的区间内数字和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>−10^9≤x≤10^9<br>1≤n,m≤10^5<br>−10^9≤l≤r≤10^9<br>−10000≤c≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3 31 23 67 51 34 67 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">805<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>离散化就这么说，题目虽然说了无限长的数轴，但实际用到的只有几个点而已，比如有一条数轴，上面有10w个点，但我只在1 20 5000 10000上加上1，其它点还是0，那么我们只要算这四个点就行，反正其它点是0，我们就把这四个点重新排，第1个点是1，第二个点是20，第三个点是5000，第四个点是10000，那么当题目问我们区间和时，我们只要看区间之间有没有我们这几个点就行，比如计算5~10000的和，那就是20和5000和10000上的值加起来就行。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;typedef pair&lt;int,int&gt; PII;#include&lt;vector&gt;#include&lt;algorithm&gt;const int N&#x3D;300010;int a[N],s[N];vector&lt;int&gt;alls;vector&lt;PII&gt;adds,range;int find(int x)&#123;    int l&#x3D;0,r&#x3D;alls.size()-1;    while(l&lt;r)    &#123;        int mid&#x3D;l+r&gt;&gt;1;        if(alls[mid]&gt;&#x3D;x)r&#x3D;mid;        else l&#x3D;mid+1;    &#125;    return r+1;&#125;int main()&#123;    int l,r,n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;0;i&lt;n;i++)    &#123;        int x,c;        cin&gt;&gt;x&gt;&gt;c;        adds.push_back(&#123;x,c&#125;);        alls.push_back(x);    &#125;    for(int i&#x3D;0;i&lt;m;i++)    &#123;        cin&gt;&gt;l&gt;&gt;r;        range.push_back(&#123;l,r&#125;);        alls.push_back(l);        alls.push_back(r);    &#125;    sort(alls.begin(),alls.end());    alls.erase(unique(alls.begin(),alls.end()),alls.end());    for(auto i:adds)    &#123;        int x&#x3D;find(i.first);        a[x]+&#x3D;i.second;    &#125;    for(int i&#x3D;1;i&lt;&#x3D;alls.size();i++)s[i]&#x3D;s[i-1]+a[i];    for(auto i:range)    &#123;        l&#x3D;find(i.first),r&#x3D;find(i.second);        cout&lt;&lt;s[r]-s[l-1]&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="803-区间合并-AcWing题库"><a href="#803-区间合并-AcWing题库" class="headerlink" title="803. 区间合并 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/805/">803. 区间合并 - AcWing题库</a></h4><p>给定 n 个区间 [li,ri]，要求合并所有有交集的区间。</p><p>注意如果在端点处相交，也算有交集。</p><p>输出合并完成后的区间个数。</p><p>例如：[1,3]和 [2,6] 可以合并为一个区间 [1,6]。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>接下来 n 行，每行包含两个整数 l 和 r。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>−10^9≤li≤ri≤10^9</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">51 22 45 67 87 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>区间合并就是把多个区间合并成一个区间，但必须是有交集的才能合并，比如【1，3】和【2，6】这种才能合并，或者【1，3】和【3，4】这类，即第一个区间的尾部在第二个区间的范围里，如果没交集则没法合并。</p><p>我们把每个区间设置成键值对的情况然后存入vector中，然后我们根据区间的左端点进行排序，从小到大，然后遍历vector，判断当前区间的右端点在不在下一个区间的范围里，如果在说明有交集，把这两个区间合并，如果不在范围里则不合并，最后输出vector容器的size（即有多少区间）。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef pair&lt;int,int&gt; PII;const int N&#x3D;100010;int n,l,r;vector&lt;PII&gt;segs;void merge(vector&lt;PII&gt;&amp;segs)&#123;    vector&lt;PII&gt;res;    sort(segs.begin(),segs.end());    int st&#x3D;-2e9,ed&#x3D;-2e9;    for(auto i:segs)    &#123;        if(ed&lt;i.first)        &#123;            if(st!&#x3D;-2e9)res.push_back(&#123;st,ed&#125;);            st&#x3D;i.first,ed&#x3D;i.second;        &#125;        else ed&#x3D;max(ed,i.second);    &#125;    if(st!&#x3D;-2e9)res.push_back(&#123;st,ed&#125;);    segs&#x3D;res;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)    &#123;        cin&gt;&gt;l&gt;&gt;r;        segs.push_back(&#123;l,r&#125;);    &#125;    merge(segs);    cout&lt;&lt;segs.size()&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-17每日刷题打卡</title>
      <link href="/2021/11/17/2021-11-17-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/17/2021-11-17-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-17每日刷题打卡"><a href="#2021-11-17每日刷题打卡" class="headerlink" title="2021-11-17每日刷题打卡"></a>2021-11-17每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="318-最大单词长度乘积"><a href="#318-最大单词长度乘积" class="headerlink" title="318. 最大单词长度乘积"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></h4><p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><p>示例 1:</p><p>输入: [“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”]<br>输出: 16<br>解释: 这两个单词为 “abcw”, “xtfn”。</p><p>这题我用了两个方法，第一个是几分钟前还不会位运算的本笨比写的暴力方法，第二个是稍稍学习了下位运算的聪明的笨比写的较轻松的方法。</p><p>第一个：准备一个以map容器为元素的vector容器v（即vector&lt;map&lt;char,int&gt;&gt;)，还有一个数max来存最大值（初始化为0），遍历words数组，把各个单词的组成情况用map&lt;char,int&gt;容器存储起来插入到v中，等所有的单词都遍历完后开始下一轮遍历，遍历v容器，先拿第一个元素和剩下所有元素比较，再拿第二个元素和剩下所有元素比较…………以此往复，(比较方式是用for遍历26个字母，因为前面我们用map存下了各个单词的组成状况，所以这里我们用，map[‘a’]或map[‘b’]这样的方式就可以知道这字母的数为多少，假如一个单词为look，那么map[l]=1,map[o]=2，如果没有这个字母那就是为0，比如map[a]=0……)。然后我们比较同时比较两个单词的组成情况，判断一下有没有出现map1[]!=0&amp;&amp;map2[]!=0的情况，如果有就说明这两个单词有重复的字母，不满足条件，我们直接去比较下一对。如果对比结束了发现没有重复的字母，那我们把两个单词的长度相乘，和max对比，大于max就把乘积赋给max，小于则不管。最后一切遍历结束后返回max即可。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int maxProduct(vector&lt;string&gt;&amp; words) &#123;        vector&lt;unordered_map&lt;char, int&gt;&gt;v;        int max_len &#x3D; 0;        for (auto i : words)        &#123;            unordered_map&lt;char, int&gt;mymap;            for (auto j : i)                mymap[j]++;            v.push_back(mymap);        &#125;        int n &#x3D; v.size(), l &#x3D; 0, r &#x3D; 1;        bool flag &#x3D; true;        while(l&lt;n)        &#123;            r&#x3D;0;            while (r &lt; n)            &#123;                                for (char i &#x3D; &#39;a&#39;; i &lt;&#x3D; &#39;z&#39;; i++)                &#123;                    if (v[l][i] !&#x3D; 0 &amp;&amp; v[r][i] !&#x3D; 0)                    &#123;                        flag &#x3D; false;                        break;                    &#125;                &#125;                int num &#x3D;  words[l].size() * words[r].size();                if (flag)                    max_len &#x3D; max(max_len,num);                flag &#x3D; true;                r++;            &#125;            l++;        &#125;        return max_len;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个是位运算，上面的方法我们是分析了一个单词的组成，比方拿look来说是有一个l、两个o、三个k组成的。但我们其实并不需要知道它的组成，我们只需要知道这个字母有没有在这个单词里出现过就行。那我们可以用二进制数的方式来存一个字母是否在单词里出现，因为二进制只用0和1，那么我们可以设定一个26位长的二进制数，即一开始是26个0（000000000……00）哪个字母出现了就把对应的数从0变成1，比如a就是把第一个0变成1即可，然后我们把这个二进制数存入vector里即可（比起上面的vector里存map容器，这里存的只是一个int，方便很多）。到时候比较，我们只需要用到&amp;即可，&amp;的功能是比较两个二进制数，如果两边都为1才为1，比如两个二进制数0010和0110，除了第二位都为1以外，其余位置要么只有一个1，要么都为0，所以运算后的结果为0010（转换成bool就是true），如果一个1都没有就直接是0（转换成bool就是false），我们可以用这个方法来判断单词是否有相同的地方，比如单词abc和aef就是0111和00110001，运算后为0001，说明有相同的，如果是ab和cd，就是0011和1100，运算后为0，说明没有相同的，然后我们在计算然后取最大值即可。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int maxProduct(vector&lt;string&gt;&amp; words) &#123;        vector&lt;int&gt;v;        for(auto i:words)        &#123;            int maxk&#x3D;0;            for(auto j:i)            &#123;                maxk |&#x3D; 1&lt;&lt; (j-&#39;a&#39;);            &#125;            v.push_back(maxk);        &#125;        int n&#x3D;v.size(),max_num&#x3D;0;;        for(int i&#x3D;0;i&lt;n;i++)        &#123;                        for(int j&#x3D;i+1;j&lt;n;j++)            &#123;                int num&#x3D;words[i].size()*words[j].size();                if(!(v[i]&amp;v[j]))                    max_num&#x3D;max(max_num,num);                else continue;            &#125;        &#125;        return max_num;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AcWing——算法基础"><a href="#AcWing——算法基础" class="headerlink" title="AcWing——算法基础"></a>AcWing——算法基础</h2><h4 id="40-顺时针打印矩阵-AcWing题库"><a href="#40-顺时针打印矩阵-AcWing题库" class="headerlink" title="40. 顺时针打印矩阵 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/39/">40. 顺时针打印矩阵 - AcWing题库</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre class="line-numbers language-none"><code class="language-none">输入：[  [1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们从x=0,y=0处开始逐步把数存入数组里，准备四个方向：上（-1，0），右（0，1），下（1，0），左（0，-1），每次遍历的时候按照方向xy坐标的不同加在我们遍历的xy处就可以达到顺时针遍历，每当遇到边界或是到了之前的位置（转了一圈）就转方向。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;        int n&#x3D;matrix.size();        vector&lt;int&gt;v;        if(!n)return v;        int m&#x3D;matrix[0].size();        vector&lt;vector&lt;bool&gt;&gt;st(n,vector&lt;bool&gt;(m,false));        int dx[]&#x3D;&#123;-1,0,1,0&#125;,dy[]&#x3D;&#123;0,1,0,-1&#125;;        int x&#x3D;0,y&#x3D;0,d&#x3D;1;        for(int i&#x3D;0;i&lt;n*m;i++)        &#123;            v.push_back(matrix[x][y]);            st[x][y]&#x3D;true;            int a&#x3D;x+dx[d],b&#x3D;y+dy[d];            if(a&gt;&#x3D;n||a&lt;0||b&lt;0||b&gt;&#x3D;m||st[a][b])            &#123;                d&#x3D;(d+1)%4;                a&#x3D;x+dx[d],b&#x3D;y+dy[d];            &#125;            x&#x3D;a,y&#x3D;b;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="801-二进制中1的个数-AcWing题库"><a href="#801-二进制中1的个数-AcWing题库" class="headerlink" title="801. 二进制中1的个数 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/803/">801. 二进制中1的个数 - AcWing题库</a></h4><p>给定一个长度为 n 的数列，请你求出数列中每个数的二进制表示中 1 的个数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>第二行包含 n 个整数，表示整个数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 n 个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中 1 的个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>0≤数列中元素的值≤10^9</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">51 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里我们用到的是位运算的知识点，采用的是右移运算符（&gt;&gt;)，使用格式是a&gt;&gt;b;意思是把数字a的二进制数向右移动b位，比如7&gt;&gt;2，就是把5的二进制数向右移动2位，7二进制是0111，向右移动两位就变成了01，我们就是采用这个方式，让一个数的二进制数上各个位的数移动到右边第一位，然后和&amp;1，&amp;是按位与的意思，它的意思是两个数的二进制数对应位置上都为1才为1，比如5&amp;7就是0101&amp;0111，运算结果就是0101，我们把右移的数和1进行&amp;运算，就是只看一个数的最右边位置上是不是1，如果是1就就计算有一个1，然后再右移，在计算，最后右移完后就可以知道这个数的二进制有几个1了。（我们这里从32开始右移，移到1停止，从32开始是因为int类型是32字节，即二进制有32位数）</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;int main()&#123;    int m,num,math;    cin&gt;&gt;m;    while(m--)    &#123;        math&#x3D;0;        cin&gt;&gt;num;        for(int i&#x3D;32;i&gt;0;i--)            if(num&gt;&gt;i&amp;1)math++;        cout&lt;&lt;math&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-16每日刷题打卡</title>
      <link href="/2021/11/16/2021-11-16-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/16/2021-11-16-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-16每日刷题打卡"><a href="#2021-11-16每日刷题打卡" class="headerlink" title="2021-11-16每日刷题打卡"></a>2021-11-16每日刷题打卡</h1><h2 id="AcWing——算法基础"><a href="#AcWing——算法基础" class="headerlink" title="AcWing——算法基础"></a>AcWing——算法基础</h2><h4 id="797-差分-AcWing题库"><a href="#797-差分-AcWing题库" class="headerlink" title="797. 差分 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/799/">797. 差分 - AcWing题库</a></h4><p>输入一个长度为 n 的整数序列。</p><p>接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r ]  之间的每个数加上 c。</p><p>请你输出进行完所有操作后的序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p><p>第二行包含 n 个整数，表示整数序列。</p><p>接下来 m 行，每行包含三个整数 l，r，c 表示一个操作。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 n 个整数，表示最终序列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤100000<br>1≤l≤r≤n<br>−1000≤c≤1000<br>−1000≤整数序列中元素的值≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">6 31 2 2 1 2 11 3 13 5 11 6 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3 4 5 3 4 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>昨天我们学到的前缀和用到的是前缀和数组，今天这里我们用到的是逆前缀和数组，也叫差分数组。先介绍一下差分数组是什么：我们知道，前缀和数组的各位数，就是原数组上的前面所有数的和，比如原数组是1 2 3 4 5，那么前缀和数组的第三位就是前三个数的和，即6，这就是前缀和数组。而逆前缀和就说，原数组是这个差分数组的前缀和数组（关系逆转了），比如原数组是1 2 3 4 5，那么差分数组就该是 1 1 1 1 1，这样原数组上的第四位数，就是差分数组的1~4之和，即4。差分数组各位上的运算如下：（a为原数组，b为差分）b[i]=a[i]-a[i-1]，不理解的可以想一下：b[1]=a[1]-a[0]、b[2]=a[2]-a[1]、b[3]=a[3]=a[2]，这样b1+b2+b2就等于a3了。</p><p>然后为什么把区间[l,r]加上c要用差分数组呢，如果我们按正常的情况，就是遍历a中[l,r]位置上的数，然后把c加上去，时间复杂度是n，如果多次重复这种操作容易超时。而差分数组可以化简这一操作，比如正常的数组为1 2 3 4 5，现在你要把[2,4]上的数都加上3，原数组就变成1 5 6 7 5，而差分数组只要把l位置上的数加上3即可，即 1 4 1 1 1 ，因为原数组上的数是差分数组的前缀和，那么只要l上加上c，那么l和l之后的所有数都会加上c了，但有一点注意的是，我们加的数是有区间范围的，比如说上面的例子，我们只想2<del>4位置上的数＋3，但用拆分数组算后发现第5位数也加上了3变成了8，这不是我们想要的，所以我们要在区间之外的数都-3，即差分数组r+1位置上的数-3即可，这样l位置前的数不会收到+3的影响，l</del>r位置上的数会+3，r之后的数会+3后-3，即不会变化。这样就可以很方便的把原数组l~r区间的数都加上c了，比起对原数组遍历，差分数组只用在l和r+1上两个位置做动作，时间复杂度为O（1）。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100010;int n,m;int a[N],b[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);        b[i]&#x3D;a[i]-a[i-1];    &#125;    while(m--)    &#123;        int l,r,c;        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;        b[l]+&#x3D;c;        b[r+1]-&#x3D;c;    &#125;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)    &#123;        a[i]&#x3D;a[i-1]+b[i];        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="798-差分矩阵-AcWing题库"><a href="#798-差分矩阵-AcWing题库" class="headerlink" title="798. 差分矩阵 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/800/">798. 差分矩阵 - AcWing题库</a></h4><p>输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1)和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。</p><p>每个操作都要将选中的子矩阵中的每个元素的值加上 cc。</p><p>请你将进行完所有操作后的矩阵输出。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n,m,q。</p><p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p><p>接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c 表示一个操作。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1000<br>1≤q≤100000<br>1≤x1≤x2≤n<br>1≤y1≤y2≤m<br>−1000≤c≤1000<br>−1000≤矩阵内元素的值≤1000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3 4 31 2 2 13 2 2 11 1 1 11 1 2 2 11 3 2 3 23 1 3 4 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">2 3 4 14 3 4 12 2 2 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用的也是差分数组，解释起来有点长，感兴趣的可以通过公式+画图来理解</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;1010;int n,m,q;int a[N][N],b[N][N];void insert(int x1,int y1,int x2,int y2,int c)&#123;    b[x1][y1]+&#x3D;c;    b[x1][y2+1]-&#x3D;c;    b[x2+1][y1]-&#x3D;c;    b[x2+1][y2+1]+&#x3D;c;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        for(int j&#x3D;1;j&lt;&#x3D;m;j++)        &#123;            scanf(&quot;%d&quot;,&amp;a[i][j]);            insert(i,j,i,j,a[i][j]);        &#125;    while(q--)    &#123;        int x1,y1,x2,y2,c;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;        insert(x1,y1,x2,y2,c);    &#125;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)    &#123;        for(int j&#x3D;1;j&lt;&#x3D;m;j++)        &#123;            b[i][j]+&#x3D;b[i-1][j]+b[i][j-1]-b[i-1][j-1];            cout&lt;&lt;b[i][j]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="799-最长连续不重复子序列-AcWing题库"><a href="#799-最长连续不重复子序列-AcWing题库" class="headerlink" title="799. 最长连续不重复子序列 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/801/">799. 最长连续不重复子序列 - AcWing题库</a></h4><p>给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>第二行包含 n 个整数（均在 0∼10^5范围内），表示整数序列。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤10^5</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">51 2 2 3 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>准备两个数组，a[N],s[N]，N开到100010。再用一个数res来存贮最长序列的长度。先把数都存入a数组里，然后用双指针i和j遍历a,初始i和j都为0，i每次遍历都++，当i&gt;=a.size()时结束循环，i每走一格，s[a[i]]++，这里是为了计算i走过的位置是否有重复数，以a[i]为下标，s[a[i]]就为a[i]这个数出现的次数，然后判断，如果s[a[i]]&gt;1,说明i走过的地方有重复数，此时j开始动，当s[a[i]]不大于1时j停下，每次s[a[j]]–，这里是为了找到和当前a[i]相同数字的位置，如果–后s[a[i]]还是大于1，说明还没找到和当前a[i]相同数的位置，j继续++，如果s[a[i]]不大于1了，就说明已经找到相同数的位置，j停止++。每次i++后，对比res和i-j+1的大小（i-j+1代表当前连续子序列的长度），取较大的那个给res赋值。当i走到数组尽头时结束遍历，输出res。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100010;int n;int a[N],s[N];int main()&#123;    int res&#x3D;0;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i&#x3D;0,j&#x3D;0;i&lt;n;i++)    &#123;        s[a[i]]++;        while(s[a[i]]&gt;1)        &#123;            s[a[j]]--;            j++;        &#125;        res&#x3D;max(res,i-j+1);    &#125;    cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="800-数组元素的目标和-AcWing题库"><a href="#800-数组元素的目标和-AcWing题库" class="headerlink" title="800. 数组元素的目标和 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/802/">800. 数组元素的目标和 - AcWing题库</a></h4><p>给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。</p><p>数组下标从 0 开始。</p><p>请你求出满足 A[i]+B[j]=x 的数对 (i,j)。</p><p>数据保证有唯一解。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n,m,x，分别表示 A 的长度，B 的长度以及目标值 x。</p><p>第二行包含 n 个整数，表示数组 A。</p><p>第三行包含 m 个整数，表示数组 B。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含两个整数 i 和 j。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>数组长度不超过 10^5。<br>同一数组内元素各不相同。<br>1≤数组元素≤10^9</p><h4 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">4 5 61 2 4 73 4 6 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>双指针就是我亲人啊，我们以前写过一个数组从头到尾的，这次变成两个而已，没区别。一个指针从a数组的开头走，一个指针从b数组的尾部走，加一起大于若x就把b数组的指针往后挪，若小于x就把a数组指针往前挪，相等就停止遍历然后输出。（注意，双指针遍历的这种方式必须要求数组是有序的，不然会错）</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100010;int n,m,x;int a[N],b[N],c[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i&#x3D;0;i&lt;m;i++)scanf(&quot;%d&quot;,&amp;b[i]);    int i&#x3D;0,j&#x3D;m-1;    while(1)    &#123;        if(a[i]+b[j]&gt;x)j--;        else if(a[i]+b[j]&lt;x)i++;        else break;    &#125;    cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2816-判断子序列-AcWing题库"><a href="#2816-判断子序列-AcWing题库" class="headerlink" title="2816. 判断子序列 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/2818/">2816. 判断子序列 - AcWing题库</a></h4><p>给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。</p><p>请你判断 a 序列是否为 b 序列的子序列。</p><p>子序列指序列的一部分项按<strong>原有次序排列</strong>而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5}的一个子序列。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n,m。</p><p>第二行包含 n 个整数，表示 a1,a2,…,an</p><p>第三行包含 m 个整数，表示 b1,b2,…,bm</p><h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果 a 序列是 b 序列的子序列，输出一行 <code>Yes</code>。</p><p>否则，输出 <code>No</code>。</p><h4 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤m≤10^5<br>−10^9≤ai,bi≤10^9</p><h4 id="输入样例：-4"><a href="#输入样例：-4" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3 51 3 51 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="输出样例：-4"><a href="#输出样例：-4" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">Yes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>双指针真的是我亲人！这两题是我目前唯二没看y总视频写出来的。</p><p>准备两个数组a、b，a数组用来存小的，b数组用来存大的，准备两个指针i、j，初始分别指向a、b的开头，然后开始遍历，当a[i]=b[j]上i才++，然后j一直往前走。当遍历结束后判断一下i是否走完了a数组，如果是就输出Yes，反之输出No。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100010;int n,m;int a[N],b[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i&#x3D;0;i&lt;m;i++)scanf(&quot;%d&quot;,&amp;b[i]);    int i&#x3D;0,j&#x3D;0;    while(j&lt;m&amp;&amp;i&lt;n)    &#123;        if(a[i]&#x3D;&#x3D;b[j])i++;        j++;    &#125;    if(i&#x3D;&#x3D;n)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-15每日刷题打卡</title>
      <link href="/2021/11/15/2021-11-15-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/15/2021-11-15-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-15每日刷题打卡"><a href="#2021-11-15每日刷题打卡" class="headerlink" title="2021-11-15每日刷题打卡"></a>2021-11-15每日刷题打卡</h1><h2 id="AcWing——算法基础"><a href="#AcWing——算法基础" class="headerlink" title="AcWing——算法基础"></a>AcWing——算法基础</h2><h4 id="AcWing-794-高精度除法-AcWing"><a href="#AcWing-794-高精度除法-AcWing" class="headerlink" title="AcWing 794. 高精度除法 - AcWing"></a><a href="https://www.acwing.com/activity/content/problem/content/828/">AcWing 794. 高精度除法 - AcWing</a></h4><p>给定两个非负整数 （不含前导 00） A，B，请你计算 A/B 的商和余数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，第一行包含整数 A，第二行包含整数 B。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共两行，第一行输出所求的商，第二行输出所求余数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤A的长度≤100000<br>1≤B≤10000<br>B 一定不为 0</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">72<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">31<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>除法和乘法相似，都是拿被拆散的A直接和b相除来得结果（因为b很小所以不用拆），不同于加减乘，除法是从最高位开始的，比如255除15，则是2先和15除，得0，然后2因为没有被除掉所以保留，当移到下一位时就变成了25，25除15得1，余数是10，10就被保留下来，到最后一位变成105，除15得7，这样结果就是017，然后把前导0去掉就是我们要的结果了（和乘法不一样，这里除的是前导0，即把数组先反转一下即可）。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt;&amp;A,int b,int &amp;r)&#123;    vector&lt;int&gt;C;    for(int i&#x3D;0;i&lt;A.size();i++)    &#123;        r&#x3D;r*10+A[i];        C.push_back(r&#x2F;b);        r%&#x3D;b;    &#125;    reverse(C.begin(),C.end());    while(C.size()&gt;1&amp;&amp;!C.back())C.pop_back();    return C;&#125;int main()&#123;    int b;    string a;    vector&lt;int&gt;A;    cin&gt;&gt;a&gt;&gt;b;    for(int i&#x3D;0;i&lt;a.size();i++)A.push_back(a[i]-&#39;0&#39;);    int r&#x3D;0;    auto C&#x3D;div(A,b,r);    for(int i&#x3D;C.size()-1;i&gt;&#x3D;0;i--)cout&lt;&lt;C[i];    cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="795-前缀和-AcWing题库"><a href="#795-前缀和-AcWing题库" class="headerlink" title="795. 前缀和 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/797/">795. 前缀和 - AcWing题库</a></h4><p>输入一个长度为 nn 的整数序列。</p><p>接下来再输入 mm 个询问，每个询问输入一对 l,rl,r。</p><p>对于每个询问，输出原序列中从第 ll 个数到第 rr 个数的和。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p><p>第二行包含 n 个整数，表示整数数列。</p><p>接下来 m 行，每行包含两个整数 l和 r，表示一个询问的区间范围。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 m 行，每行输出一个询问的结果。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤l≤r≤n<br>1≤n,m≤100000<br>−1000≤数列中元素的值≤1000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">5 32 1 3 6 41 21 32 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3610<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>前缀和就是计算一个区间内所有数的整合，正常情况我们是一个个加一起的，但如果我们直接提问10000次，让你从1加到10000，这样必然会超过时间限制，所以就有了前缀和数组。</p><p>准备两个数组，一个前缀和数组s一个正常数组a，大小一样，先把数都存入正常数组里，然后开始遍历前缀和数组s（开辟好空间了，里面会被系统自动填充0），每遍历一个格子，就让这个格子的值等于前一个格子的值加上a数组里相同位置上的数。比如1.2.3.4这个是a数组，前缀和数组的第三位就是第二位之前的和：1+2=3，加上a上相同位置格子的数（第三位）：3，那么前缀和数组的第三位就是6.同理第四位就是6+4=10。这样当我们求一个区间的和时，不用重新开始加，而是计算大区间的前缀和数组-小区间位置上的前缀和数组。比如上面我们要计算第二个数到第4个数的和，那就是前缀和第4位格子里的数：10-前缀和第1个格子的数：1，即9。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100010;int n,m,l,r;int a[N],s[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i&#x3D;1;i&lt;&#x3D;n;i++)s[i]&#x3D;s[i-1]+a[i];    while(m--)    &#123;        cin&gt;&gt;l&gt;&gt;r;        cout&lt;&lt;s[r]-s[l-1]&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="796-子矩阵的和-AcWing题库"><a href="#796-子矩阵的和-AcWing题库" class="headerlink" title="796. 子矩阵的和 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/798/">796. 子矩阵的和 - AcWing题库</a></h4><p>输入一个 nn 行 mm 列的整数矩阵，再输入 qq 个询问，每个询问包含四个整数 x1,y1,x2,y2x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</p><p>对于每个询问输出子矩阵中所有数的和。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n，m，q。</p><p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p><p>接下来 q 行，每行包含四个整数 x1,y1,x2,y2表示一组询问。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q 行，每行输出一个询问的结果。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1000<br>1≤q≤200000<br>1≤x1≤x2≤n<br>1≤y1≤y2≤m<br>−1000≤矩阵内元素的值≤1000</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3 4 31 7 2 43 6 2 82 1 2 31 1 2 22 1 3 41 3 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">172721<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也用的是前缀和数组的解法，这是一个固定的模板，解释起来有点麻烦，感兴趣的自己看看公式然后画图理解就行。</p><p>前缀和数组公式：s [ i ] [ j ]=s[ i-1 ] [ j ]+s [ i ] [ j-1 ]-s [ i-1 ] [ j-1 ]+a[ i ] [ j ];</p><p>计算：s[ x2 ] [ y2 ]-s [ x2 ] [ y1-1 ]-s[ x1-1 ] [ y2 ]+s [ x1-1] [ y1-1 ]</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;1010;int n,m,q;int a[N][N],s[N][N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        for(int j&#x3D;1;j&lt;&#x3D;m;j++)            scanf(&quot;%d&quot;,&amp;a[i][j]);    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        for(int j&#x3D;1;j&lt;&#x3D;m;j++)            s[i][j]&#x3D;s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];    while(q--)    &#123;        int x1,x2,y1,y2;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;        cout&lt;&lt;s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="319-灯泡开关"><a href="#319-灯泡开关" class="headerlink" title="319. 灯泡开关"></a><a href="https://leetcode-cn.com/problems/bulb-switcher/">319. 灯泡开关</a></h4><p>初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。</p><p>第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。</p><p>找出并返回 n 轮后有多少个亮着的灯泡。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg" alt="bulb.jpg (421×321) (leetcode.com)"></p><p>输入：n = 3<br>输出：1<br>解释：<br>初始时, 灯泡状态 [关闭, 关闭, 关闭].<br>第一轮后, 灯泡状态 [开启, 开启, 开启].<br>第二轮后, 灯泡状态 [开启, 关闭, 开启].<br>第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </p><p>你应该返回 1，因为只有一个灯泡还亮着。</p><p>这题属实震撼我，主要是代码原因，我愿称之为最短。</p><p>这题的灯泡，可以举个例子来了解一下，比如这里有6个灯泡，第一轮全部变成000000（0代表亮），第二轮每隔一个灭一个，即010101，第三轮每隔两个灭一个：011100，第四轮：011000，第五轮：011010，第六轮：011011，最后亮的只有1和4两个灯泡。此时我们可以发现，因为一开始是灭的，所以如果对灯泡的操作数为偶数，那灯泡最终就是灭，如果是奇数，最后就是亮。那么什么位置上的灯泡操作数为奇数呢。我们可以想想，第i轮代表每i-1个灯泡就会被操作一次，意思就是只有灯泡位置大于i的才有可能会被操作，小于i的则直接跳过了，比如上面的，当第5轮时只有第五个灯泡被操作，1234都没被操作。这会可以大致想到了，只有灯泡位置数的因子数才能操作它，比如第六个灯泡只会被1、2、3、6操作，第4个灯泡则是1、2、4，然后关于因数我们知道，因数都是成对的，毕竟两个数相乘才能得到原来的数，所以一个因数一般是要和另一个因数相乘才可以，但有个数是特殊的，即一个数的平方根，因为平方根是和自己相乘，比如4的平方根是2，2*2=4，这就表明了，具有完全平方数的数，它的因子数为奇数，即最后灯泡会亮的位数。那么我们该怎么知道n个灯泡里有几个完全平方数，这里再举个例子，假设一共10个灯泡，灯泡是从1~10，现在是1&lt;=x^2&lt;=10，对x开方取整数就得到1&lt;=x&lt;=3，即有完全平方数的是1、2、3，一共三个，代表的就是1、4、9位置上的灯泡，所以我们想知道n个灯泡里有几个能亮，就看n里有几个完全平方数，看n里有几个完全平方数，即对n开方，看范围里有几个整数即可（0除外）。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int bulbSwitch(int n) &#123;        return sqrt(n);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结：2021-11-08——11-14</title>
      <link href="/2021/11/14/zhou-zong-jie-2021-11-08-11-14/"/>
      <url>/2021/11/14/zhou-zong-jie-2021-11-08-11-14/</url>
      
        <content type="html"><![CDATA[<h1 id="周总结：2021-11-08——11-14"><a href="#周总结：2021-11-08——11-14" class="headerlink" title="周总结：2021-11-08——11-14"></a>周总结：2021-11-08——11-14</h1><h3 id="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"><a href="#这里是这一周来刷题时印象比较深的几道题，挑出来做个总结" class="headerlink" title="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"></a>这里是这一周来刷题时印象比较深的几道题，挑出来做个总结</h3><h4 id="173-二叉搜索树迭代器和剑指-Offer-II-055-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器和剑指-Offer-II-055-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器和剑指 Offer II 055. 二叉搜索树迭代器"></a><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a>和<a href="https://leetcode-cn.com/problems/kTOapQ/">剑指 Offer II 055. 二叉搜索树迭代器</a></h4><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：<br>BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br>boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br>int next()将指针向右移动，然后返回指针处的数字。<br>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p><p>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/743f55b78d358ff4ba5fbb7d8088a0d9.png" alt="bst-tree.png (189×178) (leetcode.com)"></p><p>输入<br>[“BSTIterator”, “next”, “next”, “hasNext”, “next”, “hasNext”, “next”, “hasNext”, “next”, “hasNext”]<br>[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]<br>输出<br>[null, 3, 7, true, 9, true, 15, true, 20, false]</p><p>解释<br>BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);<br>bSTIterator.next();    // 返回 3<br>bSTIterator.next();    // 返回 7<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 9<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 15<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 20<br>bSTIterator.hasNext(); // 返回 False</p><p>这是一道实现题，要我们实现三个函数的功能，要实现这个功能，我们的迭代器要做成一条单一的链，而不是树的情况（不然next和hasNext的遍历比较麻烦），首先我们要先准备一个成员变量的树节点p作为最开始的头指针，这个节点的值因为题目要求说比所给树的所有节点都小，那我们就找这个树最小的节点-1即可，先中序遍历一遍root，用所得到的中序序列来初始化p，每次从中序序列里取一个值初始化p的right节点，以此往复。最后就得到了一条只有right的树，且这个树的节点值递增的，也就是之前所给树的中序序列。一开始p是头结点，它的下一个才是根节点，然后next就把p往right走并返回节点值即可。hasNext即判断p-&gt;right是否为空，如果为空就返回false，不为空就返回true。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class BSTIterator &#123;private:    TreeNode* p;public:    BSTIterator(TreeNode* root) &#123;        vector&lt;int&gt;v;        stack&lt;TreeNode*&gt;sta;        while(sta.size()||root)        &#123;            while(root)            &#123;                sta.push(root);                root&#x3D;root-&gt;left;            &#125;            root&#x3D;sta.top();            sta.pop();            v.push_back(root-&gt;val);            root&#x3D;root-&gt;right;        &#125;        this-&gt;p&#x3D;new TreeNode(v[0]-1);        dfs(p-&gt;right,v,0);    &#125;    void dfs(TreeNode *&amp;p,vector&lt;int&gt;v,int i)    &#123;        if(i&gt;&#x3D;v.size())return;        p&#x3D;new TreeNode(v[i++]);        dfs(p-&gt;right,v,i);    &#125;        int next() &#123;        this-&gt;p&#x3D;this-&gt;p-&gt;right;        return this-&gt;p-&gt;val;    &#125;        bool hasNext() &#123;        return (p-&gt;right)&#x3D;&#x3D;NULL?false:true;    &#125;&#125;;&#x2F;** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj &#x3D; new BSTIterator(root); * int param_1 &#x3D; obj-&gt;next(); * bool param_2 &#x3D; obj-&gt;hasNext(); *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="98-验证二叉搜索树和面试题-04-05-合法二叉搜索树"><a href="#98-验证二叉搜索树和面试题-04-05-合法二叉搜索树" class="headerlink" title="98. 验证二叉搜索树和面试题 04.05. 合法二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>和<a href="https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/">面试题 04.05. 合法二叉搜索树</a></h4><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3d85b39145ecc61874276bcb7cfe6765.png" alt="tree1.jpg (302×182) (leetcode.com)"></p><p>输入：root = [2,1,3]<br>输出：true</p><p>咋一看，好像每次只当前节点值要小于右节点并且大于左节点就行，但不光是这样，它是整个左子树上的值都要小于当前节点，右子树上的值都要大于当前节点，比如如果上面的左节点1连了一个右节点5，虽然满足了1节点的条件，但根节点2要小于5，所以不满足左子树上所有值小于当前节点的设定了。</p><p>所以我们每次递归遍历的时候，要顺便传入一个最大值和最小值，一开始最大值最小值都是NULL，随着递归的进行，对于左子树来说：最小值会变成当前节点左子树的值，最大值会变成当前节点的值；对于右子树来说：最小值会变成当前节点的值，最大值会变成当前节点右子树的值。这样当每次遍历时，判断这个节点的val值是否在最小值和最大值之间，如果不在就说明不是一个合格的搜索二叉树。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool flag&#x3D;true;    bool isValidBST(TreeNode* root) &#123;        if(!root-&gt;left&amp;&amp;!root-&gt;right)return flag;        dfs(root,NULL,NULL);        return flag;    &#125;    void dfs(TreeNode* root,TreeNode* max,TreeNode* min)    &#123;        if(!flag||!root)return;                if(max&amp;&amp;root-&gt;val &gt;&#x3D; max-&gt;val)flag&#x3D;false;        if(min&amp;&amp;root-&gt;val &lt;&#x3D; min-&gt;val)flag&#x3D;false;        if(root-&gt;left)dfs(root-&gt;left,root,min);        if(root-&gt;right)dfs(root-&gt;right,max,root);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个方法：其实二叉搜索树有一个性质，那就是它的中序序列是一个递增的序列，我们只要求得二叉树的中序序列，在判断这个中序序列是否单调递增即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt;v;    bool isValidBST(TreeNode* root) &#123;        if(!root-&gt;left&amp;&amp;!root-&gt;right)return true;        dfs(root);        int n&#x3D;v.size();        for(int i&#x3D;0;i&lt;n-1;i++)        &#123;            if(v[i]&gt;&#x3D;v[i+1])                return false;        &#125;        return true;    &#125;    void dfs(TreeNode* root)    &#123;        if(!root)return;        dfs(root-&gt;left);        v.push_back(root-&gt;val);        dfs(root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="538-把二叉搜索树转换为累加树和1038-把二叉搜索树转换为累加树和剑指-Offer-II-054-所有大于等于节点的值之和"><a href="#538-把二叉搜索树转换为累加树和1038-把二叉搜索树转换为累加树和剑指-Offer-II-054-所有大于等于节点的值之和" class="headerlink" title="538. 把二叉搜索树转换为累加树和1038. 把二叉搜索树转换为累加树和剑指 Offer II 054. 所有大于等于节点的值之和"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a>和<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">1038. 把二叉搜索树转换为累加树</a>和<a href="https://leetcode-cn.com/problems/w6cpku/">剑指 Offer II 054. 所有大于等于节点的值之和</a></h4><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。<br>注意：本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d5bc62df2367d7950927b68dc248a147.png" alt="tree.png (775×529) (leetcode-cn.com)"></p><p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p><p>准备一个vector容器v，然后对root中序遍历，每遍历到一个节点时，先用这个节点的值对v中所有元素相加，然后再把这个节点的值插入v中，这样最好得到的是所有大于等于当前节点的和了，再遍历一遍root，把节点值用v中的值替换掉即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt;v;    TreeNode* convertBST(TreeNode* root) &#123;        dfs(root);        int i&#x3D;0;        dfs2(root,i);        return root;    &#125;    void dfs(TreeNode* root)    &#123;        if(!root)return;        dfs(root-&gt;left);        for(int&amp; i:v)            i+&#x3D;root-&gt;val;        v.push_back(root-&gt;val);        dfs(root-&gt;right);    &#125;    void dfs2(TreeNode*&amp; root,int&amp; i)    &#123;        if(!root)return;        dfs2(root-&gt;left,i);        root-&gt;val&#x3D;v[i++];        dfs2(root-&gt;right,i);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1008-前序遍历构造二叉搜索树"><a href="#1008-前序遍历构造二叉搜索树" class="headerlink" title="1008. 前序遍历构造二叉搜索树"></a><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008. 前序遍历构造二叉搜索树</a></h4><p>返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。</p><p>(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）</p><p>题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。</p><p>示例：</p><p>输入：[8,5,1,7,10,12]<br>输出：[8,5,10,1,7,null,12]</p><p><img src="https://img-blog.csdnimg.cn/img_convert/76cee53029690222c68720081bec3897.png" alt="1266.png (590×386) (leetcode-cn.com)"></p><p>因为是前序遍历，所以我们知道序列的第一个值为根节点，然后就像我们之前知道的，左子树的所有值小于根节点，右子树的所有值大于根节点，那么我们可以遍历一遍序列，把所有小于第一个值的元素存入一个vector容器v1里，大于第一个值的元素存入另一个vector容器v2里。再利用这两个数组分别去构造左右子树（重复如上步骤），最后得到的就是原来的二叉树了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* bstFromPreorder(vector&lt;int&gt;&amp; preorder) &#123;        TreeNode* root;        dfs(root,preorder);        return root;    &#125;    void dfs(TreeNode*&amp;root,vector&lt;int&gt;preorder)    &#123;        if(!preorder.size())return;        vector&lt;int&gt;v1;        vector&lt;int&gt;v2;        int num&#x3D;preorder[0],n&#x3D;preorder.size();        for(int i&#x3D;1;i&lt;n;i++)            if(preorder[i]&lt;num)                v1.push_back(preorder[i]);            else                v2.push_back(preorder[i]);        root&#x3D;new TreeNode(num);        dfs(root-&gt;left,v1);        dfs(root-&gt;right,v2);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-13每日刷题打卡</title>
      <link href="/2021/11/13/2021-11-13-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/13/2021-11-13-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-13每日刷题打卡"><a href="#2021-11-13每日刷题打卡" class="headerlink" title="2021-11-13每日刷题打卡"></a>2021-11-13每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520. 检测大写字母"></a><a href="https://leetcode-cn.com/problems/detect-capital/">520. 检测大写字母</a></h4><p>我们定义，在以下情况时，单词的大写用法是正确的：</p><p>全部字母都是大写，比如 “USA” 。<br>单词中所有字母都不是大写，比如 “leetcode” 。<br>如果单词不只含有一个字母，只有首字母大写， 比如 “Google” 。<br>给你一个字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。</p><p>示例 1：</p><p>输入：word = “USA”<br>输出：true</p><p>准备两个数big_num和small_num来计算单词的大写字母数和小写字母数，遍历一遍word，每遇到一个大写字母big_num就++，反之small_num++。遍历完后进行判断，如果big_num等于word的长度，说明word全是由大写字母组成，如果small_num等于word的长度，说明全是由小写字母组成，如果small_num+1等于word的长度，且word首字母为大写，说明是开头大写其余小写的情况，这三种情况都返回true，其余情况返回false。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool detectCapitalUse(string word) &#123;        int n&#x3D;word.size(),big_num&#x3D;0,small_num&#x3D;0;        for(auto i:word)            if(i&gt;&#x3D;97&amp;&amp;i&lt;&#x3D;122)                small_num++;            else                big_num++;        if(n&#x3D;&#x3D;big_num)return true;        else if(n&#x3D;&#x3D;small_num)return true;        else if(small_num+1&#x3D;&#x3D;n&amp;&amp;word[0]&gt;&#x3D;65&amp;&amp;word[0]&lt;&#x3D;90)return true;        return false;    &#125;   &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="力扣——二叉搜索树"><a href="#力扣——二叉搜索树" class="headerlink" title="力扣——二叉搜索树"></a>力扣——二叉搜索树</h2><h4 id="653-两数之和-IV-输入-BST和剑指-Offer-II-056-二叉搜索树中两个节点之和"><a href="#653-两数之和-IV-输入-BST和剑指-Offer-II-056-二叉搜索树中两个节点之和" class="headerlink" title="653. 两数之和 IV - 输入 BST和剑指 Offer II 056. 二叉搜索树中两个节点之和"></a><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a>和<a href="https://leetcode-cn.com/problems/opLdQZ/">剑指 Offer II 056. 二叉搜索树中两个节点之和</a></h4><p>给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg" alt="sum_tree_1.jpg (562×322) (leetcode.com)"></p><p>输入: root = [5,3,6,2,4,null,7], k = 9<br>输出: true</p><p>中序遍历root，序列存入vector中，然后用双指针的方法来判断是否有需要的结果。</p><p>设定两个指针，一个left=0，一个right=v.size()-1。while循环遍历，当l不小于r时结束循环，每次判断l+r的大小，如果大于目标值，r–；如果小于目标值，l++；如果等于目标值，返回true。while结束后，说明没有等于目标值的情况，直接返回false即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt;v;    bool findTarget(TreeNode* root, int k) &#123;        dfs(root);        int l&#x3D;0,r&#x3D;v.size()-1;        while(l&lt;r)        &#123;            if(v[l]+v[r]&gt;k)                r--;            else if(v[l]+v[r]&lt;k)                l++;            else if(v[l]+v[r]&#x3D;&#x3D;k)                return true;        &#125;        return false;    &#125;    void dfs(TreeNode* root)    &#123;        if(!root)return;        dfs(root-&gt;left);        v.push_back(root-&gt;val);        dfs(root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AcWing——算法基础"><a href="#AcWing——算法基础" class="headerlink" title="AcWing——算法基础"></a>AcWing——算法基础</h2><h4 id="793-高精度乘法-AcWing题库"><a href="#793-高精度乘法-AcWing题库" class="headerlink" title="793. 高精度乘法 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/795/">793. 高精度乘法 - AcWing题库</a></h4><p>给定两个非负整数（不含前导 0） A 和 B，请你计算 A×B 的值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，第一行包含整数 A，第二行包含整数 BB。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 A×B 的值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤A的长度≤100000<br>0≤B≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">23<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>跟高精度的加法类似，不过这里要存入vector的只有a，因为b最大只有10000，不用拆开存到vector中。所以我们把a设置成字符串存到vector容器v中（也是倒着存），b就设置成int类型就可以。开始运算，准备存储结果的C和一个整型t=0，每次A的各位数字都要直接乘上b，而不是像加减法那样一位一位的来，把A[i] * b加到t上，然后往C中插入数据，不过我们插入的是t%10，因为乘法可能出现大于10的情况，我们就取t的余数就行，然后把t/10，这样t此时剩下的数就是下一次的进位了（比如计算3* 4=12，C存的就是12%10=2，然后t/10=1，这样下次的运算就是进位1，所以我们前面说要把A[i] * b加到t上，这是考虑进位的情况）。循环结束后判断t是否为0，不为0就继续往C中插入数据知道t为0位置。注意要判断一下前导0，即如果C的末尾元素是0，则要把0去掉。最后把c输出即可。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;vector&lt;int&gt; mul(vector&lt;int&gt;&amp;A,int b)&#123;    vector&lt;int&gt;C;    int t&#x3D;0;    for(int i&#x3D;0;i&lt;A.size()||t;i++)    &#123;        if(i&lt;A.size())t+&#x3D;A[i]*b;        C.push_back(t%10);        t&#x2F;&#x3D;10;    &#125;    while(C.size()&gt;1&amp;&amp;!C.back())C.pop_back();    return C;&#125;int main()&#123;    int b;    string a;    vector&lt;int&gt;A;    cin&gt;&gt;a&gt;&gt;b;    for(int i&#x3D;a.size()-1;i&gt;&#x3D;0;i--)A.push_back(a[i]-&#39;0&#39;);    auto C&#x3D;mul(A,b);    for(int i&#x3D;C.size()-1;i&gt;&#x3D;0;i--)cout&lt;&lt;C[i];    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-12每日刷题打卡</title>
      <link href="/2021/11/12/2021-11-12-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/12/2021-11-12-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-12每日刷题打卡"><a href="#2021-11-12每日刷题打卡" class="headerlink" title="2021-11-12每日刷题打卡"></a>2021-11-12每日刷题打卡</h1><h2 id="AcWing——算法基础"><a href="#AcWing——算法基础" class="headerlink" title="AcWing——算法基础"></a>AcWing——算法基础</h2><h4 id="790-数的三次方根-AcWing题库"><a href="#790-数的三次方根-AcWing题库" class="headerlink" title="790. 数的三次方根 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/792/">790. 数的三次方根 - AcWing题库</a></h4><p>给定一个浮点数 n，求它的三次方根。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个浮点数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个浮点数，表示问题的解。</p><p>注意，结果保留 6 位小数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>−10000≤n≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">1000.00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">10.000000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>二分查找，这里的数据范围是-10000到10000，那我们就以这个为范围二分查找，每次取中间点，判断中间点的三次方是否等于它给的值，如果相等就退出循环直接输出mid的值。如果不相等，再根据判断大小来决定是取左区间还是右区间。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;int main()&#123;    double x;    scanf(&quot;%lf&quot;,&amp;x);    double l&#x3D;-10000,r&#x3D;10000;    while(r-l&gt;1e-8)    &#123;        double mid&#x3D;(l+r)&#x2F;2;        if(mid*mid*mid&gt;&#x3D;x)r&#x3D;mid;        else l&#x3D;mid;    &#125;    printf(&quot;%lf&quot;,l);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="791-高精度加法-AcWing题库"><a href="#791-高精度加法-AcWing题库" class="headerlink" title="791. 高精度加法 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/793/">791. 高精度加法 - AcWing题库</a></h4><p>给定两个正整数（不含前导 0），计算它们的和。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，每行包含一个整数。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含所求的和。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤整数长度≤100000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">1223<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">35<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>高精度，通俗点来说就是因为数太大了，大到int或long long也无法存下，所以我们采用别的方式来存储这些大的离谱的数。</p><p>我们常用的就是把数分成一位一位的然后存入数组里，一开始接收他给的数时，因为正常的整型或浮点型接受不了这么大的数，所以我们把数通过字符串接收，然后通过遍历字符串把各位的字符转成存入vector中（这里的情况，vector比数组要方便，你自己好好想想就知道了），要注意一点是，我们要把字符串逆着存入vector中，比如5201314我们要存成4131025，因为这是为了方便进位，比如我们是990+10，如果是正着存，那vector中的情况也是990，此时结果运算完后是1000，多出来一位，这相当于我们要把原来的数集体后移，这是非常麻烦的，如果我们存的是099，这样只用最后面加1位数就行了。</p><p>把要运算的两个数都存在vector后，开始运算，从下标0开始，相同位的加在一起，如果大于10则只取个位数，然后他们的下一位数+1（进位）。最后把结果输出。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;vector&lt;int&gt; add(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B)&#123;    vector&lt;int&gt;C;    int t&#x3D;0;    for(int i&#x3D;0;i&lt;A.size()||i&lt;B.size();i++)    &#123;        if(i&lt;A.size())t+&#x3D;A[i];        if(i&lt;B.size())t+&#x3D;B[i];        C.push_back(t%10);        t&#x2F;&#x3D;10;    &#125;    if(t)C.push_back(1);    return C;&#125;int main()&#123;    string a,b;    cin&gt;&gt;a&gt;&gt;b;    vector&lt;int&gt;A,B;    for(int i&#x3D;a.size()-1;i&gt;&#x3D;0;i--)A.push_back(a[i]-&#39;0&#39;);    for(int i&#x3D;b.size()-1;i&gt;&#x3D;0;i--)B.push_back(b[i]-&#39;0&#39;);        auto C&#x3D;add(A,B);    for(int i&#x3D;C.size()-1;i&gt;&#x3D;0;i--)cout&lt;&lt;C[i];    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="792-高精度减法-AcWing题库"><a href="#792-高精度减法-AcWing题库" class="headerlink" title="792. 高精度减法 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/794/">792. 高精度减法 - AcWing题库</a></h4><p>给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，每行包含一个整数。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含所求的差。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤整数长度≤10^5</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3211<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">21<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>总的来说和加法差不多，不同点是减法要考虑结果为负数的可能。我们还是先接收字符串存入vector中，然后要比较两个vector谁大谁小（比长度，要是长度一样就比最高位的数谁大谁小），大的那个做主位去减小的那个，如果顺序和给数时的顺序不同，那输出结果时在开头输出一个负号即可。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;bool cmp(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B)&#123;    if(A.size()!&#x3D;B.size())return A.size()&gt;B.size();    for(int i&#x3D;A.size()-1;i&gt;&#x3D;0;i--)        if(A[i]!&#x3D;B[i])            return A[i]&gt;B[i];    return true;&#125;vector&lt;int&gt; sub(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B)&#123;    vector&lt;int&gt;C;    int t&#x3D;0;    for(int i&#x3D;0;i&lt;A.size();i++)    &#123;        t&#x3D;A[i]-t;        if(i&lt;B.size())t-&#x3D;B[i];        C.push_back((t+10)%10);        if(t&lt;0)t&#x3D;1;        else t&#x3D;0;    &#125;    while(C.size()&gt;1&amp;&amp;!C.back())C.pop_back();    return C;&#125;int main()&#123;    string a,b;    vector&lt;int&gt;A,B;    cin&gt;&gt;a&gt;&gt;b;    for(int i&#x3D;a.size()-1;i&gt;&#x3D;0;i--)A.push_back(a[i]-&#39;0&#39;);    for(int i&#x3D;b.size()-1;i&gt;&#x3D;0;i--)B.push_back(b[i]-&#39;0&#39;);    if(cmp(A,B))    &#123;        auto C&#x3D;sub(A,B);        for(int i&#x3D;C.size()-1;i&gt;&#x3D;0;i--)cout&lt;&lt;C[i];    &#125;    else    &#123;        auto C&#x3D;sub(B,A);        cout&lt;&lt;&quot;-&quot;;        for(int i&#x3D;C.size()-1;i&gt;&#x3D;0;i--)cout&lt;&lt;C[i];    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="235-二叉搜索树的最近公共祖先和剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先和剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先和剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a>和<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p>示例 1:</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="binarysearchtree_improved.png (200×190) (leetcode-cn.com)"></p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p><p>while遍历root，每次先判断p和q的值与root的值的关系，如果p和q的val都小于root，说明p和q都在root的左子树，那root就往left方向遍历，如果val都大于root，说明都在右子树，往right遍历，如果一个大一个小，说明一个在左子树一个在右子树，那当前节点就是p和q的最近公共祖先了，返回即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        while(1)        &#123;            if(p-&gt;val&gt;root-&gt;val&amp;&amp;q-&gt;val&gt;root-&gt;val)            &#123;                root&#x3D;root-&gt;right;            &#125;            else if(p-&gt;val&lt;root-&gt;val&amp;&amp;q-&gt;val&lt;root-&gt;val)            &#123;                root&#x3D;root-&gt;left;            &#125;            else break;        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><p>给定二叉搜索树:</p><pre><code>    4   / \  2   7 / \1   3</code></pre><p>和值: 2<br>你应该返回如下子树:</p><pre><code>  2      / \   1   3</code></pre><p>while遍历root，如果root的val值小于给的val值，说明给的val值应该在root的右子树，root往right方向走；如果大于，说明val应该在左子树，root往left方向走；如果相等，返回root；如果root为NULL，说明到头来也没找到，返回NULL。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* searchBST(TreeNode* root, int val) &#123;        while(1)            if(!root)break;            else if(root-&gt;val &lt; val)root&#x3D;root-&gt;right;            else if(root-&gt;val &gt; val)root&#x3D;root-&gt;left;            else if(root-&gt;val &#x3D;&#x3D; val)break;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-11每日刷题打卡</title>
      <link href="/2021/11/11/2021-11-11-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/11/2021-11-11-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-11每日刷题打卡"><a href="#2021-11-11每日刷题打卡" class="headerlink" title="2021-11-11每日刷题打卡"></a>2021-11-11每日刷题打卡</h1><h2 id="力扣——二叉搜索树"><a href="#力扣——二叉搜索树" class="headerlink" title="力扣——二叉搜索树"></a>力扣——二叉搜索树</h2><h4 id="538-把二叉搜索树转换为累加树和1038-把二叉搜索树转换为累加树和剑指-Offer-II-054-所有大于等于节点的值之和"><a href="#538-把二叉搜索树转换为累加树和1038-把二叉搜索树转换为累加树和剑指-Offer-II-054-所有大于等于节点的值之和" class="headerlink" title="538. 把二叉搜索树转换为累加树和1038. 把二叉搜索树转换为累加树和剑指 Offer II 054. 所有大于等于节点的值之和"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a>和<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">1038. 把二叉搜索树转换为累加树</a>和<a href="https://leetcode-cn.com/problems/w6cpku/">剑指 Offer II 054. 所有大于等于节点的值之和</a></h4><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。<br>注意：本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="tree.png (775×529) (leetcode-cn.com)"></p><p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p><p>准备一个vector容器v，然后对root中序遍历，每遍历到一个节点时，先用这个节点的值对v中所有元素相加，然后再把这个节点的值插入v中，这样最好得到的是所有大于等于当前节点的和了，再遍历一遍root，把节点值用v中的值替换掉即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt;v;    TreeNode* convertBST(TreeNode* root) &#123;        dfs(root);        int i&#x3D;0;        dfs2(root,i);        return root;    &#125;    void dfs(TreeNode* root)    &#123;        if(!root)return;        dfs(root-&gt;left);        for(int&amp; i:v)            i+&#x3D;root-&gt;val;        v.push_back(root-&gt;val);        dfs(root-&gt;right);    &#125;    void dfs2(TreeNode*&amp; root,int&amp; i)    &#123;        if(!root)return;        dfs2(root-&gt;left,i);        root-&gt;val&#x3D;v[i++];        dfs2(root-&gt;right,i);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><pre><code> 5/ \</code></pre><p>   2   6<br>  / <br> 1   3<br>示例 1：</p><p>输入: [1,6,3,2,5]<br>输出: false</p><p>后序遍历的特点是：[左子树] [右子树] [根节点]，所以可知根节点是最后一位，然后左子树总比根节点小，右子树总比根节点大，所以我们在遍历 postorder时可以准备两个vector容器v1、v2来分别存左子树和右子树的节点值（顺便要提前判断一下postorder的size，如果小于等于1，说明必是一个后序遍历，返回true），开始遍历 postorder，把前面遍历到的所有小于根节点的值存入v1中，当遇到第一个大于根节点的值时停止插入v1，而后所有的值都插入v2，这个过程中也要比较，如果有存在小于根节点的值，说明这不是一个合格的二叉搜索数的后序序列，直接返回false，如果一直遍历到结尾也没问题，那么就进行下一次递归，把v1和v2分别送去递归，当所有递归结束后，我们就得到了bool类型的结果。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool flag;    bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123;        return dfs(postorder);    &#125;    bool dfs(vector&lt;int&gt;&amp;v)    &#123;        int n&#x3D;v.size();        if(n&lt;&#x3D;1)return true;        int j&#x3D;0;        vector&lt;int&gt;v1;        vector&lt;int&gt;v2;        for(int i&#x3D;0;i&lt;n;i++)        &#123;                        if(v[i]&gt;&#x3D;v[n-1])            &#123;                j&#x3D;i;                break;            &#125;            v1.push_back(v[i]);        &#125;        for(int i&#x3D;j;i&lt;n-1;i++)        &#123;            if(v[i]&lt;v[n-1])            &#123;                return false;            &#125;            else                v2.push_back(v[i]);        &#125;        return dfs(v1)&amp;&amp;dfs(v2);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AcWing——算法基础"><a href="#AcWing——算法基础" class="headerlink" title="AcWing——算法基础"></a>AcWing——算法基础</h2><h4 id="788-逆序对的数量-AcWing题库"><a href="#788-逆序对的数量-AcWing题库" class="headerlink" title="788. 逆序对的数量 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/790/">788. 逆序对的数量 - AcWing题库</a></h4><p>给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。</p><p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i&lt;j 且 a[i]&gt;a[j]，则其为一个逆序对；否则不是。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 nn，表示数列的长度。</p><p>第二行包含 nn 个整数，表示整个数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示逆序对的个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>数列中的元素的取值范围 [1,1^9][1,109]。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">62 3 4 5 6 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这题用的是归并排序来解，你可能有点不理解为什么是归并，这里举个例子。比如有一个序列 15 4 2 3 6，我们最后一步归并会把它变成</p><p>1 4 5  |（mid)| 2 3 6  然后比较左右两边的序列，把小的存到数组里，对比1和2，1小，不构成逆序对；然后对比4和2，2小，此时在左边的数组里，因为4右边的数都比4大，所以2能和4以及4右边的全部数组成逆序对，逆序对的数量就为mid-4的下标+1，然后对比4和3……所以我们可以利用归并来求得逆序对的数量，当左边的数组小时我们不多做操作，右边的小时逆序对的数量要加上mid-左边数组当前索引+1。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;1e6+5;int n;long long res&#x3D;0;int arr[N],tmp[N];void merge_sort(int l,int r)&#123;    if (l &gt;&#x3D; r)return;    int mid &#x3D; (l + r) &#x2F; 2;    merge_sort(l, mid);    merge_sort(mid + 1, r);    int i &#x3D; l, j &#x3D; mid + 1, k &#x3D; 0;    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)    &#123;        if (arr[i] &lt;&#x3D; arr[j])tmp[k++] &#x3D; arr[i++];        else        &#123;            tmp[k++] &#x3D; arr[j++];            res +&#x3D; mid - i + 1;        &#125;    &#125;    while (i &lt;&#x3D; mid)tmp[k++] &#x3D; arr[i++];    while (j &lt;&#x3D; r)tmp[k++] &#x3D; arr[j++];    for (int i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i++, j++)        arr[i] &#x3D; tmp[j];    &#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;0;i&lt;n;i++)        scanf(&quot;%d&quot;,&amp;arr[i]);        merge_sort(0,n-1);    cout&lt;&lt;res;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="789-数的范围-AcWing题库"><a href="#789-数的范围-AcWing题库" class="headerlink" title="789. 数的范围 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/791/">789. 数的范围 - AcWing题库</a></h4><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p><p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 00 开始计数）。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 q，表示数组长度和询问个数。</p><p>第二行包含 n 个整数（均在 1∼100001∼10000 范围内），表示完整数组。</p><p>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">6 31 2 2 3 3 4345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3 45 5-1 -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>二分查找，查找两次，第一次找数的起始位，第二次找数的终止位</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100010;int n,m;int nums[N];int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;nums[i]);    while(m--)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        int l&#x3D;0,r&#x3D;n-1;        int mid&#x3D;(l+r)&#x2F;2;        while(l&lt;r)        &#123;            if(nums[mid]&gt;&#x3D;x)r&#x3D;mid;            else l&#x3D;mid+1;            mid&#x3D;(l+r)&#x2F;2;        &#125;        if(nums[l]!&#x3D;x)        &#123;            cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl;            continue;        &#125;        else            cout&lt;&lt;l&lt;&lt;&quot; &quot;;                    l&#x3D;0,r&#x3D;n-1;        mid&#x3D;(l+r+1)&#x2F;2;        while(l&lt;r)        &#123;            if(nums[mid]&lt;&#x3D;x)l&#x3D;mid;            else r&#x3D;mid-1;            mid&#x3D;(l+r+1)&#x2F;2;        &#125;        cout&lt;&lt;l&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-10每日刷题打卡</title>
      <link href="/2021/11/10/2021-11-10-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/10/2021-11-10-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-10每日刷题打卡"><a href="#2021-11-10每日刷题打卡" class="headerlink" title="2021-11-10每日刷题打卡"></a>2021-11-10每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495. 提莫攻击"></a><a href="https://leetcode-cn.com/problems/teemo-attacking/">495. 提莫攻击</a></h4><p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p><p>当提莫攻击艾希，艾希的中毒状态正好持续 duration 秒。  </p><p>正式地讲，提莫在 t 发起发起攻击意味着艾希在时间区间 [t, t + duration - 1]（含 t 和 t + duration - 1）处于中毒状态。如果提莫在中毒影响结束 前 再次攻击，中毒状态计时器将会 重置 ，在新的攻击之后，中毒影响将会在 duration 秒后结束。</p><p>给你一个 非递减 的整数数组 timeSeries ，其中 timeSeries[i] 表示提莫在 timeSeries[i] 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 duration 。</p><p>返回艾希处于中毒状态的 总 秒数。</p><p>示例 1：</p><p>输入：timeSeries = [1,4], duration = 2<br>输出：4<br>解释：提莫攻击对艾希的影响如下：</p><ul><li>第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。</li><li>第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。<br>艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。</li></ul><p>这题也太草了，看到这题时忍不住笑了。这题解释一下就是说如果艾希中毒状态结束后被攻击，那就是两次攻击中毒时间分开计算，即2*duration，如果是中毒结束前被再次攻击，那就要一起算了，即timeSeries[i]-timeSeries[i-1]+duration，此时我们也知道这道题的解法了，准备一个数ans来计算中毒总时长，计算timeSeries数组里相邻两个元素的差值，如果差值大于等于duration，那第一次攻击的有效中毒时间就是duration，加到ans上，如果是小于duration，那就说明第一次攻击的有效中毒时间就是timeSeries[i]-timeSeries[i-1]，加到ans上。注意，到了末尾时我们的循环就结束了，但最后一次攻击也是有中毒时间的，而且因为没有下一次攻击，所以最后一次攻击的中毒时间必是duration，所以我们要把ans加上duration才是正确答案（也可以一开始初始化ans时不初始为0而初始为duration），然后再返回ans。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int findPoisonedDuration(vector&lt;int&gt;&amp; timeSeries, int duration) &#123;        int n&#x3D;timeSeries.size(),ans&#x3D;duration;        for(int i&#x3D;0;i&lt;n-1;i++)            if(timeSeries[i+1]-timeSeries[i]&gt;&#x3D;duration)                ans+&#x3D;duration;            else                ans+&#x3D;timeSeries[i+1]-timeSeries[i];        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="力扣——二叉搜索树"><a href="#力扣——二叉搜索树" class="headerlink" title="力扣——二叉搜索树"></a>力扣——二叉搜索树</h2><h4 id="173-二叉搜索树迭代器和剑指-Offer-II-055-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器和剑指-Offer-II-055-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器和剑指 Offer II 055. 二叉搜索树迭代器"></a><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a>和<a href="https://leetcode-cn.com/problems/kTOapQ/">剑指 Offer II 055. 二叉搜索树迭代器</a></h4><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：<br>BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br>boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br>int next()将指针向右移动，然后返回指针处的数字。<br>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p><p>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p><p>示例：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt="bst-tree.png (189×178) (leetcode.com)"></p><p>输入<br>[“BSTIterator”, “next”, “next”, “hasNext”, “next”, “hasNext”, “next”, “hasNext”, “next”, “hasNext”]<br>[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]<br>输出<br>[null, 3, 7, true, 9, true, 15, true, 20, false]</p><p>解释<br>BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);<br>bSTIterator.next();    // 返回 3<br>bSTIterator.next();    // 返回 7<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 9<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 15<br>bSTIterator.hasNext(); // 返回 True<br>bSTIterator.next();    // 返回 20<br>bSTIterator.hasNext(); // 返回 False</p><p>这是一道实现题，要我们实现三个函数的功能，要实现这个功能，我们的迭代器要做成一条单一的链，而不是树的情况（不然next和hasNext的遍历比较麻烦），首先我们要先准备一个成员变量的树节点p作为最开始的头指针，这个节点的值因为题目要求说比所给树的所有节点都小，那我们就找这个树最小的节点-1即可，先中序遍历一遍root，用所得到的中序序列来初始化p，每次从中序序列里取一个值初始化p的right节点，以此往复。最后就得到了一条只有right的树，且这个树的节点值递增的，也就是之前所给树的中序序列。一开始p是头结点，它的下一个才是根节点，然后next就把p往right走并返回节点值即可。hasNext即判断p-&gt;right是否为空，如果为空就返回false，不为空就返回true。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class BSTIterator &#123;private:    TreeNode* p;public:    BSTIterator(TreeNode* root) &#123;        vector&lt;int&gt;v;        stack&lt;TreeNode*&gt;sta;        while(sta.size()||root)        &#123;            while(root)            &#123;                sta.push(root);                root&#x3D;root-&gt;left;            &#125;            root&#x3D;sta.top();            sta.pop();            v.push_back(root-&gt;val);            root&#x3D;root-&gt;right;        &#125;        this-&gt;p&#x3D;new TreeNode(v[0]-1);        dfs(p-&gt;right,v,0);    &#125;    void dfs(TreeNode *&amp;p,vector&lt;int&gt;v,int i)    &#123;        if(i&gt;&#x3D;v.size())return;        p&#x3D;new TreeNode(v[i++]);        dfs(p-&gt;right,v,i);    &#125;        int next() &#123;        this-&gt;p&#x3D;this-&gt;p-&gt;right;        return this-&gt;p-&gt;val;    &#125;        bool hasNext() &#123;        return (p-&gt;right)&#x3D;&#x3D;NULL?false:true;    &#125;&#125;;&#x2F;** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj &#x3D; new BSTIterator(root); * int param_1 &#x3D; obj-&gt;next(); * bool param_2 &#x3D; obj-&gt;hasNext(); *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="剑指-Offer-II-053-二叉搜索树中的中序后继"><a href="#剑指-Offer-II-053-二叉搜索树中的中序后继" class="headerlink" title="剑指 Offer II 053. 二叉搜索树中的中序后继"></a><a href="https://leetcode-cn.com/problems/P5rCT8/">剑指 Offer II 053. 二叉搜索树中的中序后继</a></h4><p>给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。</p><p>节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2019/01/23/285_example_1.PNG" alt="285_example_1.PNG (122×117) (leetcode.com)"></p><p>输入：root = [2,1,3], p = 1<br>输出：2<br>解释：这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。</p><p>中序遍历一遍二叉树，把他的中序序列存在vector容器v中，然后遍历v，找到所给p节点的val值，然后返回它的下一个数据，如果v中没有下一个数据就返回NULL。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;TreeNode*&gt;v;    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) &#123;        dfs(root);        int n&#x3D;v.size();        for(int i&#x3D;0;i&lt;n;i++)            if(v[i]-&gt;val&#x3D;&#x3D;p-&gt;val)                return (i+1)&gt;&#x3D;n?NULL:v[i+1];        return &#123;&#125;;    &#125;    void dfs(TreeNode*root)    &#123;        if(!root)return;        dfs(root-&gt;left);        v.push_back(root);        dfs(root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者我们可以在中序遍历的时候就创建好节点，这样一来不用遍历两便中序遍历，二来不需要多余的vector容器来存中序序列。</p><p>首先准备一个节点q，一开始指向NULL，拿一个bool类型flag=false来判断什么时候该拿root的val值初始化q，我们用迭代的方法中序遍历，每次比较root的值之前先判断一下flag是否为true，如果为true就拿当前值来初始化q，然后返回q结束程序。如果不为true就比较root和所给节点p的值，然后当遍历到节点值和所给节点p的值相同时，我们把flag改为true，这样我们的下一个中序序列的值就可以那来初始化q了。如果root没有下一个值了，那q仍然是NULL，会被直接返回。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) &#123;        TreeNode*q;        q&#x3D;NULL;        bool flag&#x3D;false;        stack&lt;TreeNode*&gt;sta;        while(root||sta.size())        &#123;            while(root)            &#123;                sta.push(root);                root&#x3D;root-&gt;left;            &#125;            root&#x3D;sta.top();            sta.pop();            if(flag&amp;&amp;root-&gt;val!&#x3D;num)            &#123;                q&#x3D;new TreeNode(root-&gt;val);                return q;            &#125;            if(root-&gt;val&#x3D;&#x3D;p-&gt;val)                flag&#x3D;true;            root&#x3D;root-&gt;right;        &#125;        return q;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><p>结点左子树中所含结点的值小于等于当前结点的值<br>结点右子树中所含结点的值大于等于当前结点的值<br>左子树和右子树都是二叉搜索树<br>例如：<br>给定 BST [1,null,2,2],</p><p>   1<br>    <br>     2<br>    /<br>   2</p><p>先中序遍历一遍root，把中序序列结果存入v中，然后遍历一遍v，找到出现频率最高的数，然后再遍历一遍v，把出现频率最高的数全都存入另一个vector容器中，最后返回这个容器。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt;mymap;    vector&lt;int&gt; findMode(TreeNode* root) &#123;        vector&lt;int&gt;v;        dfs(root);        int max&#x3D;0,num&#x3D;mymap[0],score&#x3D;0;;        for(auto i:mymap)            if(i&#x3D;&#x3D;num)                score++;            else            &#123;                max&#x3D;max&gt;score?max:score;                num&#x3D;i;                score&#x3D;1;            &#125;        max &#x3D; max &gt; score ? max : score;        score&#x3D;0;        num&#x3D;mymap[0];        for(auto i:mymap)        &#123;            if(i&#x3D;&#x3D;num)                score++;            else            &#123;                score&#x3D;1;                num&#x3D;i;            &#125;            if(score&#x3D;&#x3D;max)                    v.push_back(num);        &#125;        return v;    &#125;    void dfs(TreeNode*root)    &#123;        if(!root)return;        dfs(root-&gt;left);        mymap.push_back(root-&gt;val);        dfs(root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-09每日刷题打卡</title>
      <link href="/2021/11/09/2021-11-09-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/09/2021-11-09-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-09每日刷题打卡"><a href="#2021-11-09每日刷题打卡" class="headerlink" title="2021-11-09每日刷题打卡"></a>2021-11-09每日刷题打卡</h1><h2 id="力扣——二叉搜索树"><a href="#力扣——二叉搜索树" class="headerlink" title="力扣——二叉搜索树"></a>力扣——二叉搜索树</h2><h4 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938. 二叉搜索树的范围和"></a><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></h4><p>给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" alt="bst1.jpg (542×301) (leetcode.com)"></p><p>输入：root = [10,5,15,3,7,null,18], low = 7, high = 15<br>输出：32</p><p>遍历一遍二叉树，用一个全局变量sum来计算结果，每遍历一个节点，判断该节点的值是否在 [low, high] 范围内，如果在就加到sum上。遍历完后返回sum即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int sum&#x3D;0;    int down&#x3D;0;    int up&#x3D;0;    int rangeSumBST(TreeNode* root, int low, int high) &#123;        down&#x3D;low;        up&#x3D;high;        dfs(root);        return sum;    &#125;    void dfs(TreeNode* root)    &#123;        if(!root)return;        if(root-&gt;val &gt;&#x3D; down&amp;&amp;root-&gt;val &lt;&#x3D; up)            sum+&#x3D;root-&gt;val;        dfs(root-&gt;left);        dfs(root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="530-二叉搜索树的最小绝对差和783-二叉搜索树节点最小距离"><a href="#530-二叉搜索树的最小绝对差和783-二叉搜索树节点最小距离" class="headerlink" title="530. 二叉搜索树的最小绝对差和783. 二叉搜索树节点最小距离"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a>和<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a></h4><p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="bst1.jpg (292×301) (leetcode.com)"></p><p>输入：root = [4,2,6,1,3]<br>输出：1</p><p>中序遍历一遍二叉树，把结果存在vector容器v里，然后从下标1开始到结尾，每次计算v[i]-v[i-1]的值，最后求得最小的那个值，返回它。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int getMinimumDifference(TreeNode* root) &#123;        stack&lt;TreeNode*&gt;sta;        vector&lt;int&gt;v;        while(root||sta.size())        &#123;            while(root)            &#123;                v.push_back(root-&gt;val);                sta.push(root);                root&#x3D;root-&gt;left;            &#125;            root&#x3D;sta.top();            sta.pop();            root&#x3D;root-&gt;right;        &#125;        int min&#x3D;INT_MAX,n&#x3D;v.size();        sort(v.begin(),v.end());        for(int i&#x3D;1;i&lt;n;i++)        &#123;            if(min&gt;(v[i]-v[i-1]))                min&#x3D;(v[i]-v[i-1]);        &#125;        return min;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p>示例 1:</p><p>输入: root = [3,1,4,null,2], k = 1<br>   3<br>  / <br> 1   4<br>  <br>   2<br>输出: 4</p><p>把树的中序序列保存到vector容器v中，返回v[v.size()-k]即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt;v;    int kthLargest(TreeNode* root, int k) &#123;        dfs(root);        return v[v.size()-k];    &#125;    void dfs(TreeNode*root)    &#123;        if(!root)return;        dfs(root-&gt;left);        v.push_back(root-&gt;val);        dfs(root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="897-递增顺序搜索树和剑指-Offer-II-052-展平二叉搜索树"><a href="#897-递增顺序搜索树和剑指-Offer-II-052-展平二叉搜索树" class="headerlink" title="897. 递增顺序搜索树和剑指 Offer II 052. 展平二叉搜索树"></a><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序搜索树</a>和<a href="https://leetcode-cn.com/problems/NYBBNL/">剑指 Offer II 052. 展平二叉搜索树</a></h4><p>给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" alt="ex1.jpg (1201×701) (leetcode.com)"></p><p>输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]<br>输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</p><p>把中序序列存在vector容器v中，再根据v的值逐步创建树。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt;v;    TreeNode* increasingBST(TreeNode* root) &#123;        dfs(root);        TreeNode*p;        int i&#x3D;0;        dfs2(p,i);        return p;    &#125;    void dfs(TreeNode*root)    &#123;        if(!root)return;        dfs(root-&gt;left);        v.push_back(root-&gt;val);        dfs(root-&gt;right);    &#125;    void dfs2(TreeNode*&amp;p,int &amp;i)    &#123;        if(i&gt;&#x3D;v.size())return;        p&#x3D;new TreeNode(v[i++]);        dfs2(p-&gt;right,i);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种方法就是在中序遍历的时候改变它的指向，让他直接变成我们要的树。</p><p>准备一个全局的树节点p做开头，函数里先初始化一个头结点q，让这个头结点指向p，开始递归，递归的过程和中序遍历一样，只不过中间的地方我们不是存值，而是要把p-&gt;right=root，再把root的左节点指向空，以免形成环，再把p往下走一格。</p><p>当递归完后，返回q-&gt;right即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;private:    TreeNode * p;public:    TreeNode* increasingBST(TreeNode* root) &#123;        TreeNode * q&#x3D;new TreeNode(-1);        p&#x3D;q;        dfs(root);        return q-&gt;right;    &#125;    void dfs(TreeNode*root)    &#123;        if(!root)return;        dfs(root-&gt;left);                p-&gt;right&#x3D;root;        root-&gt;left&#x3D;nullptr;        p&#x3D;root;        dfs(root-&gt;right);    &#125;    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-08每日刷题打卡</title>
      <link href="/2021/11/08/2021-11-08-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/08/2021-11-08-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-08每日刷题打卡"><a href="#2021-11-08每日刷题打卡" class="headerlink" title="2021-11-08每日刷题打卡"></a>2021-11-08每日刷题打卡</h1><h2 id="力扣——二叉搜索树"><a href="#力扣——二叉搜索树" class="headerlink" title="力扣——二叉搜索树"></a>力扣——二叉搜索树</h2><h4 id="98-验证二叉搜索树和面试题-04-05-合法二叉搜索树"><a href="#98-验证二叉搜索树和面试题-04-05-合法二叉搜索树" class="headerlink" title="98. 验证二叉搜索树和面试题 04.05. 合法二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>和<a href="https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/">面试题 04.05. 合法二叉搜索树</a></h4><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="tree1.jpg (302×182) (leetcode.com)"></p><p>输入：root = [2,1,3]<br>输出：true</p><p>咋一看，好像每次只当前节点值要小于右节点并且大于左节点就行，但不光是这样，它是整个左子树上的值都要小于当前节点，右子树上的值都要大于当前节点，比如如果上面的左节点1连了一个右节点5，虽然满足了1节点的条件，但根节点2要小于5，所以不满足左子树上所有值小于当前节点的设定了。</p><p>所以我们每次递归遍历的时候，要顺便传入一个最大值和最小值，一开始最大值最小值都是NULL，随着递归的进行，对于左子树来说：最小值会变成当前节点左子树的值，最大值会变成当前节点的值；对于右子树来说：最小值会变成当前节点的值，最大值会变成当前节点右子树的值。这样当每次遍历时，判断这个节点的val值是否在最小值和最大值之间，如果不在就说明不是一个合格的搜索二叉树。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool flag&#x3D;true;    bool isValidBST(TreeNode* root) &#123;        if(!root-&gt;left&amp;&amp;!root-&gt;right)return flag;        dfs(root,NULL,NULL);        return flag;    &#125;    void dfs(TreeNode* root,TreeNode* max,TreeNode* min)    &#123;        if(!flag||!root)return;                if(max&amp;&amp;root-&gt;val &gt;&#x3D; max-&gt;val)flag&#x3D;false;        if(min&amp;&amp;root-&gt;val &lt;&#x3D; min-&gt;val)flag&#x3D;false;        if(root-&gt;left)dfs(root-&gt;left,root,min);        if(root-&gt;right)dfs(root-&gt;right,max,root);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个方法：其实二叉搜索树有一个性质，那就是它的中序序列是一个递增的序列，我们只要求得二叉树的中序序列，在判断这个中序序列是否单调递增即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt;v;    bool isValidBST(TreeNode* root) &#123;        if(!root-&gt;left&amp;&amp;!root-&gt;right)return true;        dfs(root);        int n&#x3D;v.size();        for(int i&#x3D;0;i&lt;n-1;i++)        &#123;            if(v[i]&gt;&#x3D;v[i+1])                return false;        &#125;        return true;    &#125;    void dfs(TreeNode* root)    &#123;        if(!root)return;        dfs(root-&gt;left);        v.push_back(root-&gt;val);        dfs(root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="面试题-04-02-最小高度树和108-将有序数组转换为二叉搜索树"><a href="#面试题-04-02-最小高度树和108-将有序数组转换为二叉搜索树" class="headerlink" title="面试题 04.02. 最小高度树和108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/">面试题 04.02. 最小高度树</a>和<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p><p>示例:<br>给定有序数组: [-10,-3,0,5,9],</p><p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p><pre><code>      0      / \    -3   9    /   /  -10  5 </code></pre><p>我们利用二叉搜索树的中序序列为递增区间的性质来求得二叉树，我们假定这个有序数组为二叉树的中序序列，既然我们想把一个绳子只折一次变成最短，那肯定是要从中间对折，所以我们取数组的中点值为根节点，然后把左右两边的数组分成两个数组，左边的构成左子树，右边的构成右子树，再从左边的数组里取中间值构建根节点的左节点，右边的数组里取中间值构建成根节点的右节点…………循环往复。最后当数组没有数字时，我们就得到了最短的二叉树，返回根节点即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        TreeNode*root;        dfs(root,nums);        return root;    &#125;    void dfs(TreeNode*&amp;root,vector&lt;int&gt;nums)    &#123;        int n&#x3D;nums.size();        if(!n)return;        int len&#x3D;n&#x2F;2;        vector&lt;int&gt;v1;        vector&lt;int&gt;v2;        root&#x3D;new TreeNode(nums[len]);        for(int i&#x3D;0;i&lt;len;i++)            v1.push_back(nums[i]);        for(int i&#x3D;len+1;i&lt;n;i++)            v2.push_back(nums[i]);                dfs(root-&gt;left,v1);        dfs(root-&gt;right,v2);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h4><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定的有序链表： [-10, -3, 0, 5, 9],</p><p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p><pre><code>  0 / \</code></pre><p>   -3   9<br>   /   /<br> -10  5</p><p>和上一题的解法一样，只不过我们先遍历一遍链表把链表各节点的val值存入vector中，再用vector重复上一题的操作。</p><p>（当然，也可以一遍一遍二叉树一遍遍历链表，只要用快慢指针就可以求得链表的中间值了）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* sortedListToBST(ListNode* head) &#123;        TreeNode* root;        if(!head)return NULL;        vector&lt;int&gt;v;        while(head!&#x3D;NULL)        &#123;            v.push_back(head-&gt;val);            head&#x3D;head-&gt;next;        &#125;        dfs(root,v);        return root;    &#125;    void dfs(TreeNode*&amp;root,vector&lt;int&gt;nums)    &#123;        int n&#x3D;nums.size();        if(!n)return;        int len&#x3D;n&#x2F;2;        root&#x3D;new TreeNode(nums[len]);        vector&lt;int&gt;v1;        vector&lt;int&gt;v2;        for(int i&#x3D;0;i&lt;len;i++)            v1.push_back(nums[i]);        for(int i&#x3D;len+1;i&lt;n;i++)            v2.push_back(nums[i]);        dfs(root-&gt;left,v1);        dfs(root-&gt;right,v2);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a></h4><p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p><p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" alt="recover1.jpg (422×302) (leetcode.com)"></p><p>输入：root = [1,3,null,null,2]<br>输出：[3,1,null,null,2]<br>解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</p><p>中序遍历遍历二叉树，把得到的序列从小到大排序，再遍历一遍二叉树把节点值都重新赋值即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt;v;    void recoverTree(TreeNode* root) &#123;        dfs(root);        int i&#x3D;0;        sort(v.begin(),v.end());        dfs1(root,i);    &#125;    void dfs(TreeNode*&amp;root)    &#123;        if(!root)return;        dfs(root-&gt;left);        v.push_back(root-&gt;val);        dfs(root-&gt;right);    &#125;    void dfs1(TreeNode*&amp;root,int &amp;i)    &#123;        if(!root)return;        dfs1(root-&gt;left,i);        root-&gt;val&#x3D;v[i++];        dfs1(root-&gt;right,i);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1008-前序遍历构造二叉搜索树"><a href="#1008-前序遍历构造二叉搜索树" class="headerlink" title="1008. 前序遍历构造二叉搜索树"></a><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008. 前序遍历构造二叉搜索树</a></h4><p>返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。</p><p>(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）</p><p>题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。</p><p>示例：</p><p>输入：[8,5,1,7,10,12]<br>输出：[8,5,10,1,7,null,12]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/03/08/1266.png" alt="1266.png (590×386) (leetcode-cn.com)"></p><p>因为是前序遍历，所以我们知道序列的第一个值为根节点，然后就像我们之前知道的，左子树的所有值小于根节点，右子树的所有值大于根节点，那么我们可以遍历一遍序列，把所有小于第一个值的元素存入一个vector容器v1里，大于第一个值的元素存入另一个vector容器v2里。再利用这两个数组分别去构造左右子树（重复如上步骤），最后得到的就是原来的二叉树了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* bstFromPreorder(vector&lt;int&gt;&amp; preorder) &#123;        TreeNode* root;        dfs(root,preorder);        return root;    &#125;    void dfs(TreeNode*&amp;root,vector&lt;int&gt;preorder)    &#123;        if(!preorder.size())return;        vector&lt;int&gt;v1;        vector&lt;int&gt;v2;        int num&#x3D;preorder[0],n&#x3D;preorder.size();        for(int i&#x3D;1;i&lt;n;i++)            if(preorder[i]&lt;num)                v1.push_back(preorder[i]);            else                v2.push_back(preorder[i]);        root&#x3D;new TreeNode(num);        dfs(root-&gt;left,v1);        dfs(root-&gt;right,v2);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结：2021-11-01——11-07</title>
      <link href="/2021/11/07/zhou-zong-jie-2021-11-01-11-07/"/>
      <url>/2021/11/07/zhou-zong-jie-2021-11-01-11-07/</url>
      
        <content type="html"><![CDATA[<h1 id="周总结：2021-11-01——11-07"><a href="#周总结：2021-11-01——11-07" class="headerlink" title="周总结：2021-11-01——11-07"></a>周总结：2021-11-01——11-07</h1><h3 id="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"><a href="#这里是这一周来刷题时印象比较深的几道题，挑出来做个总结" class="headerlink" title="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"></a>这里是这一周来刷题时印象比较深的几道题，挑出来做个总结</h3><h4 id="449-序列化和反序列化二叉搜索树"><a href="#449-序列化和反序列化二叉搜索树" class="headerlink" title="449. 序列化和反序列化二叉搜索树"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h4><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p>编码的字符串应尽可能紧凑。</p><p>示例 1：</p><p>输入：root = [2,1,3]<br>输出：[2,1,3]</p><p>前序转字符串的方式就是递归，每次先判断当前节点是否为空，如果为空就往字符串上加一个标志性的字符来说明这是空结点，我这里用的是N（NULL），如果不为空，就把当前节点的val值转为字符串加在字符串上，然后再把该节点的左右子节点送去递归，注意每个节点的val值之间要用特殊的字符隔开，我用的是“，”。等递归完后所有的字符串都合在一起了，直接return即可。</p><p>字符串转换成二叉树的方式也是递归（递归真是个好东西），我们用自己写的dfs函数来完成递归，一共三个参数，字符串data，节点root和索引下标i（i和节点要以引用方式传递）。一开始i先为0在之后的递归里逐渐增加，每次先判断data[i]是否为“N”，如果是说明这里的节点应该为空，把当前节点指向空后直接结束程序，注意要把i+=2（跳过”，“）。如果不为N，那就先遍历字符串，当遇到”，“时结束遍历，再把遍历过的字符串转换成数字，这就是节点的val值，把值赋给root，然后送root的左右子节点去递归。当递归结束后我们得到的root就是最开始的二叉树了</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Codec &#123;public:    &#x2F;&#x2F; Encodes a tree to a single string.    string serialize(TreeNode* root) &#123;        if(!root)return &quot;N&quot;;        return to_string(root-&gt;val)+&quot;,&quot;+serialize(root-&gt;left)+&quot;,&quot;+serialize(root-&gt;right);    &#125;    &#x2F;&#x2F; Decodes your encoded data to tree.    TreeNode* deserialize(string data) &#123;        TreeNode *root;        int i&#x3D;0;        dfs(data,i,root);        return root;    &#125;    void dfs(string data,int&amp; i,TreeNode*&amp; root)    &#123;        if(data[i]&#x3D;&#x3D;&#39;N&#39;)        &#123;            i+&#x3D;2;            root&#x3D;NULL;            return;        &#125;        string str;        for(int j&#x3D;i;j&lt;data.size();j++)        &#123;            if(data[j]&#x3D;&#x3D;&#39;,&#39;)            &#123;                j++;                i&#x3D;j;                break;            &#125;            str+&#x3D;data[j];        &#125;        root &#x3D;new TreeNode(get_num(str));        dfs(data,i,root-&gt;left);        dfs(data,i,root-&gt;right);    &#125;    int get_num(string str)    &#123;        int num&#x3D;0;        for(int i&#x3D;0;i&lt;str.size();i++)        &#123;            num&#x3D;num*10+(str[i]-&#39;0&#39;);        &#125;        return num;    &#125;&#125;;&#x2F;&#x2F; Your Codec object will be instantiated and called as such:&#x2F;&#x2F; Codec* ser &#x3D; new Codec();&#x2F;&#x2F; Codec* deser &#x3D; new Codec();&#x2F;&#x2F; string tree &#x3D; ser-&gt;serialize(root);&#x2F;&#x2F; TreeNode* ans &#x3D; deser-&gt;deserialize(tree);&#x2F;&#x2F; return ans;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h4><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p><p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p><p>我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。</p><p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" alt="q1248-01.png (304×270) (leetcode-cn.com)"></p><p>输入：root = [1,2,3,4], x = 4, y = 3<br>输出：false</p><p>堂兄弟的定义是：深度一样，父节点不一样。所以我们准备两个全局map容器father和mymap（不全局也可以，但dfs传参要多加这两个容器）来分别存放父节点和深度，我们用dfs函数来遍历树，dfs有五个参数，一个是当当前节点，一个是当前节点的子节点（左节点或右节点），一个是深度u（初始为0），还有两个是x和y。dfs一开始先判断当前节点是否为空，如果是就直接结束程序，如果不是就判断节点的val值等不等于x或y，如果等于就用mymap函数存下这个节点的深度u，再用father存下节点的父节点。然后我们把当前节点的左节点和右节点接着送去递归。当一切结束后，我们判断两个节点x和y的深度是否相等，如果相等判断他俩的父节点是否为同一个，如果为同一个即不是堂兄弟，如果不是则是堂兄弟。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    unordered_map&lt;int,int&gt;mymap;    unordered_map&lt;int,int&gt;father;    bool isCousins(TreeNode* root, int x, int y) &#123;        TreeNode* t;        t&#x3D;new TreeNode(200);        dfs(root,x,y,0,t);        if(mymap[x]&#x3D;&#x3D;mymap[y]&amp;&amp;father[x]!&#x3D;father[y])        &#123;            return true;        &#125;        return false;    &#125;    void dfs(TreeNode* p,int x,int y,int u,TreeNode* q)    &#123;        if(mymap.size()&#x3D;&#x3D;2)return;        if(!p)return;        if(p-&gt;val&#x3D;&#x3D;x)        &#123;            mymap[x]&#x3D;u;            father[x]&#x3D;q-&gt;val;        &#125;        else if(p-&gt;val&#x3D;&#x3D;y)        &#123;            mymap[y]&#x3D;u;            father[y]&#x3D;q-&gt;val;        &#125;        dfs(p-&gt;left,x,y,u+1,p);        dfs(p-&gt;right,x,y,u+1,p);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7</p><p>因为迭代是在一个函数里进行的，所以可以把全局函数vector&lt;vector&lt; int&gt;&gt;v设置在函数开头，当然也可以继续全局函数。先判断root是否为空，如果为空就返回空的v给它，如果不为空，那我们先准备一个queue容器que来存节点，先把root存入que中，然后开始while遍历，只要que不为空就一直遍历，每次遍历先拿一个数len存que的size，len就是当前层的节点数，这也决定了下面for循环的次数，再准备一个vector容器v1来存这一层节点的val值，然后开始for循环，循环len次，先把当前队列的头结点的val值存入v1中，然后把队列头结点的左子节点和右子节点存入que中，再把队头元素出队，for结束后把v1插入v中。一切遍历结束后返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;           vector&lt;vector&lt;int&gt;&gt;v;        if(!root)return v;        queue&lt;TreeNode*&gt;que;        que.push(root);        while(que.size())        &#123;            int len&#x3D;que.size();            vector&lt;int&gt;v1;            for(int i&#x3D;0;i&lt;len;i++)            &#123;                v1.push_back(que.front()-&gt;val);                if(que.front()-&gt;left)que.push(que.front()-&gt;left);                if(que.front()-&gt;right)que.push(que.front()-&gt;right);                que.pop();            &#125;            v.push_back(v1);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / <br>       4   5<br>      / \   \<br>     5   4   7</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;        if(!root1&amp;&amp;!root2)return root1;        else if(!root1&amp;&amp;root2)return root2;        else if(!root2&amp;&amp;root1)return root1;         dfs(root1,root2);        return root1;    &#125;    void dfs(TreeNode*&amp;p,TreeNode*&amp;q)    &#123;        if(!q)return;        else if(!p&amp;&amp;q)        &#123;            p&#x3D;q;            return;        &#125;        p-&gt;val+&#x3D;q-&gt;val;        dfs(p-&gt;left,q-&gt;left);        dfs(p-&gt;right,q-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-06每日刷题打卡</title>
      <link href="/2021/11/06/2021-11-06-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/06/2021-11-06-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-06每日刷题打卡"><a href="#2021-11-06每日刷题打卡" class="headerlink" title="2021-11-06每日刷题打卡"></a>2021-11-06每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a><a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></h4><p>给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p><p>示例 1：</p><p>输入：nums = [3,0,1]<br>输出：2<br>解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</p><p>简单粗暴，先把nums用sort快速排序一遍，然后找nums[i]!=i的那个下标，就是缺失的数，return i 即可。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(nums[i]!&#x3D;i)            &#123;                return i;            &#125;        &#125;        return n;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="力扣——二叉树"><a href="#力扣——二叉树" class="headerlink" title="力扣——二叉树"></a>力扣——二叉树</h2><h4 id="449-序列化和反序列化二叉搜索树"><a href="#449-序列化和反序列化二叉搜索树" class="headerlink" title="449. 序列化和反序列化二叉搜索树"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h4><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p>编码的字符串应尽可能紧凑。</p><p>示例 1：</p><p>输入：root = [2,1,3]<br>输出：[2,1,3]</p><p>我这里采用前序遍历的方法（本来想用层序的，但这样字符串可能要有点长，而且后序我不喜欢所以用前序）。</p><p>前序转字符串的方式就是递归，每次先判断当前节点是否为空，如果为空就往字符串上加一个标志性的字符来说明这是空结点，我这里用的是N（NULL），如果不为空，就把当前节点的val值转为字符串加在字符串上，然后再把该节点的左右子节点送去递归，注意每个节点的val值之间要用特殊的字符隔开，我用的是“，”。等递归完后所有的字符串都合在一起了，直接return即可。</p><p>字符串转换成二叉树的方式也是递归（递归真是个好东西），我们用自己写的dfs函数来完成递归，一共三个参数，字符串data，节点root和索引下标i（i和节点要以引用方式传递）。一开始i先为0在之后的递归里逐渐增加，每次先判断data[i]是否为“N”，如果是说明这里的节点应该为空，把当前节点指向空后直接结束程序，注意要把i+=2（跳过”，“）。如果不为N，那就先遍历字符串，当遇到”，“时结束遍历，再把遍历过的字符串转换成数字，这就是节点的val值，把值赋给root，然后送root的左右子节点去递归。当递归结束后我们得到的root就是最开始的二叉树了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Codec &#123;public:    &#x2F;&#x2F; Encodes a tree to a single string.    string serialize(TreeNode* root) &#123;        if(!root)return &quot;N&quot;;        return to_string(root-&gt;val)+&quot;,&quot;+serialize(root-&gt;left)+&quot;,&quot;+serialize(root-&gt;right);    &#125;    &#x2F;&#x2F; Decodes your encoded data to tree.    TreeNode* deserialize(string data) &#123;        TreeNode *root;        int i&#x3D;0;        dfs(data,i,root);        return root;    &#125;    void dfs(string data,int&amp; i,TreeNode*&amp; root)    &#123;        if(data[i]&#x3D;&#x3D;&#39;N&#39;)        &#123;            i+&#x3D;2;            root&#x3D;NULL;            return;        &#125;        string str;        for(int j&#x3D;i;j&lt;data.size();j++)        &#123;            if(data[j]&#x3D;&#x3D;&#39;,&#39;)            &#123;                j++;                i&#x3D;j;                break;            &#125;            str+&#x3D;data[j];        &#125;        root &#x3D;new TreeNode(get_num(str));        dfs(data,i,root-&gt;left);        dfs(data,i,root-&gt;right);    &#125;    int get_num(string str)    &#123;        int num&#x3D;0;        for(int i&#x3D;0;i&lt;str.size();i++)        &#123;            num&#x3D;num*10+(str[i]-&#39;0&#39;);        &#125;        return num;    &#125;&#125;;&#x2F;&#x2F; Your Codec object will be instantiated and called as such:&#x2F;&#x2F; Codec* ser &#x3D; new Codec();&#x2F;&#x2F; Codec* deser &#x3D; new Codec();&#x2F;&#x2F; string tree &#x3D; ser-&gt;serialize(root);&#x2F;&#x2F; TreeNode* ans &#x3D; deser-&gt;deserialize(tree);&#x2F;&#x2F; return ans;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1028-从先序遍历还原二叉树"><a href="#1028-从先序遍历还原二叉树" class="headerlink" title="1028. 从先序遍历还原二叉树"></a><a href="https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/">1028. 从先序遍历还原二叉树</a></h4><p>我们从二叉树的根节点 root 开始进行深度优先搜索。</p><p>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。</p><p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p><p>给出遍历输出 S，还原树并返回其根节点 root。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/recover-a-tree-from-preorder-traversal.png" alt="recover-a-tree-from-preorder-traversal.png (798×498) (leetcode-cn.com)"></p><p>输入：”1-2–3–4-5–6–7”<br>输出：[1,2,5,3,4,6,7]</p><p>这里我们采用递归的方法来写（问了大佬大佬写的用栈迭代更简单但我想不出来所以只能用递归），我们用dfs来实现递归，dfs有四个参数，一个是树的结点root，一个是字符串traversal，一个是深度u（u和i初始都为0），一个是遍历字符串的索引i。（索引和结点要以引用方式传递）每次开头先计算一下字符串的‘-’数，遍历字符串然后计算，当遇到不是‘-’的字符时判断一下‘-’数是否小于深度u，如果小于那么就直接return结束程序，如果不小于那就让i继承当前遍历的下标，然后结束这一次的遍历，然后在进行一次遍历，把遍历到的字符都变成数字，当遇到‘-’字符时结束遍历，把转变的数字赋给root，然后再把root的左右子结点送去递归，注意u要+1。最后所有递归结束后root就是字符串转换后的二叉树。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    void dfs(string traversal, TreeNode*&amp; root, int&amp; i, int u)    &#123;        int child_u &#x3D; 0;        for (int j &#x3D; i; j &lt; traversal.size(); j++)        &#123;            if (traversal[j] !&#x3D; &#39;-&#39;)            &#123;                if (child_u &lt; u)                &#123;                    return;                &#125;                else                    i &#x3D; j;                break;            &#125;            child_u++;        &#125;        int num&#x3D;0;;        for (int j &#x3D; i; j &lt; traversal.size(); j++)        &#123;            if (traversal[j] &#x3D;&#x3D; &#39;-&#39;)            &#123;                i &#x3D; j;                break;            &#125;            num&#x3D;num*10+(traversal[j]-&#39;0&#39;);        &#125;        root &#x3D; new TreeNode(num);        dfs(traversal, root-&gt;left, i, u + 1);        dfs(traversal, root-&gt;right, i, u + 1);    &#125;    TreeNode* recoverFromPreorder(string traversal) &#123;        TreeNode* root;        int i &#x3D; 0, deep &#x3D; 0;        dfs(traversal, root, i, deep);        return root;    &#125;    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="919-完全二叉树插入器和剑指-Offer-II-043-往完全二叉树添加节点"><a href="#919-完全二叉树插入器和剑指-Offer-II-043-往完全二叉树添加节点" class="headerlink" title="919. 完全二叉树插入器和剑指 Offer II 043. 往完全二叉树添加节点"></a><a href="https://leetcode-cn.com/problems/complete-binary-tree-inserter/">919. 完全二叉树插入器</a>和<a href="https://leetcode-cn.com/problems/NaqhDT/">剑指 Offer II 043. 往完全二叉树添加节点</a></h4><p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p><p>设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：</p><p>CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；<br>CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；<br>CBTInserter.get_root() 将返回树的头节点。</p><p>示例 1：</p><p>输入：inputs = [“CBTInserter”,”insert”,”get_root”], inputs = [[[1]],[2],[]]<br>输出：[null,1,[1,2]]</p><p>第一次在力扣写实现题！真不容易啊呜呜呜！</p><p>记得先在类里写个成员变量的二叉树，公有权限或私有权限都行（一开始忘了成员变量郁闷的要死）。</p><p>构造函数（要求实现功能是用传入的二叉树来初始化成员变量的二叉树）：用dfs递归的方式来初始化，每次把成员变量的二叉树的值和root的val一样，然后判断root是否有左右子节点，如果有就把成员变量的左右子节点和root的左右子节点分别传入下一次的递归里，当所有递归结束后得到的就是和root一样的二叉树了。</p><p>插入函数（往二叉树插入一个新的节点）：用层序遍历来遍历成员变量的二叉树，去找第一个没有左右子节点或者只有左节点没有右节点的那一个父节点随便创建一个新的节点，用传入的val值来初始化它，再把这个节点连在父节点的左节点或右节点上，最后返回这个父节点的val值。</p><p>返回函数：直接返回成员变量的二叉树即可，非常简单。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class CBTInserter &#123;private:TreeNode* root;public:    CBTInserter(TreeNode* root) &#123;        dfs(root,this-&gt;root);    &#125;    void dfs(TreeNode* root,TreeNode *&amp;p)    &#123;        p&#x3D;new TreeNode(root-&gt;val);        if(root-&gt;left)dfs(root-&gt;left,p-&gt;left);        if(root-&gt;right)dfs(root-&gt;right,p-&gt;right);    &#125;        int insert(int val) &#123;        queue&lt;TreeNode*&gt;que;        que.push(this-&gt;root);        TreeNode *q;        q&#x3D;new TreeNode(val);        while(que.size())        &#123;            int len&#x3D;que.size();            for(int i&#x3D;0;i&lt;len;i++)            &#123;                if(que.front()-&gt;left&amp;&amp;que.front()-&gt;right)                &#123;                    que.push(que.front()-&gt;left);                    que.push(que.front()-&gt;right);                &#125;                else if(que.front()-&gt;left&amp;&amp;!que.front()-&gt;right)                &#123;                    que.front()-&gt;right&#x3D;q;                    return que.front()-&gt;val;                &#125;                else if(!que.front()-&gt;left&amp;&amp;!que.front()-&gt;right)                &#123;                    que.front()-&gt;left&#x3D;q;                    return que.front()-&gt;val;                &#125;                que.pop();            &#125;        &#125;        return &#123;&#125;;    &#125;        TreeNode* get_root() &#123;        return this-&gt;root;    &#125;&#125;;&#x2F;** * Your CBTInserter object will be instantiated and called as such: * CBTInserter* obj &#x3D; new CBTInserter(root); * int param_1 &#x3D; obj-&gt;insert(val); * TreeNode* param_2 &#x3D; obj-&gt;get_root(); *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-05每日刷题打卡</title>
      <link href="/2021/11/05/2021-11-05-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/05/2021-11-05-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-05每日刷题打卡"><a href="#2021-11-05每日刷题打卡" class="headerlink" title="2021-11-05每日刷题打卡"></a>2021-11-05每日刷题打卡</h1><h2 id="力扣-——二叉树"><a href="#力扣-——二叉树" class="headerlink" title="力扣 ——二叉树"></a>力扣 ——二叉树</h2><h4 id="剑指-Offer-II-044-二叉树每层的最大值和515-在每个树行中找最大值"><a href="#剑指-Offer-II-044-二叉树每层的最大值和515-在每个树行中找最大值" class="headerlink" title="剑指 Offer II 044. 二叉树每层的最大值和515. 在每个树行中找最大值"></a><a href="https://leetcode-cn.com/problems/hPov7L/">剑指 Offer II 044. 二叉树每层的最大值</a>和<a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h4><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><p>示例1：</p><p>输入: root = [1,3,2,5,3,null,9]<br>输出: [1,3,9]<br>解释:<br>          1<br>         / <br>        3   2<br>       / \   \<br>      5   3   9 </p><p>层序遍历二叉树，每次遍历新的一层时准备一个max来存最大值，然后依次比较，遍历完后把max存入vector容器中，然后继续遍历下一层。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; largestValues(TreeNode* root) &#123;        vector&lt;int&gt;v;        if(!root)return v;        queue&lt;TreeNode*&gt;que;        que.push(root);        while(que.size())        &#123;            int len&#x3D;que.size();            int max&#x3D;que.front()-&gt;val;            for(int i&#x3D;0;i&lt;len;i++)            &#123;                if(max&lt;que.front()-&gt;val)max&#x3D;que.front()-&gt;val;                if(que.front()-&gt;left)que.push(que.front()-&gt;left);                if(que.front()-&gt;right)que.push(que.front()-&gt;right);                que.pop();            &#125;            v.push_back(max);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / <br>       4   5<br>      / \   \<br>     5   4   7<br>注意: 合并必须从两个树的根节点开始。</p><p>先判断一下，如果root1为空而root2不为空那就返回root2即可，反之返回root1，如果两个都空那么返回哪个都行，如果两个都不为空那我们就开始合并的操作。直接把两个树传入dfs里，我们以root1为主树，dfs的实现是，先判断root2是否为空，如果为空就直接结束程序，如果root2不为空而root1为空，那就直接让root1=root2，以此获得root2的当前结点和之后所有节点（记住dfs的参数传递要以引用的方式才行），如果两个都不为空，那就把root2的val值加到root1上，然后再分别把root1和root2的左子节点和右子节点传入dfs里。当递归结束后root1就是合并后的二叉树了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;        if(!root1&amp;&amp;!root2)return root1;        else if(!root1&amp;&amp;root2)return root2;        else if(!root2&amp;&amp;root1)return root1;         dfs(root1,root2);        return root1;    &#125;    void dfs(TreeNode*&amp;p,TreeNode*&amp;q)    &#123;        if(!q)return;        else if(!p&amp;&amp;q)        &#123;            p&#x3D;q;            return;        &#125;        p-&gt;val+&#x3D;q-&gt;val;        dfs(p-&gt;left,q-&gt;left);        dfs(p-&gt;right,q-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><p>给定一棵树的前序遍历 preorder 与中序遍历  inorder。请构造二叉树并返回其根节点。</p><p>示例 1:</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="tree.jpg (277×302) (leetcode.com)"></p><p>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]</p><p>这题感觉太复杂了想着一开始先写个大概出来等有错了一步步改，结果一写完发现通过测试例了，整个人疑惑了一下然后点了下提交就这么直接过了也太爽了！还有什么比这更爽的事情吗？</p><p>前序遍历的结构组成是：（根节点）（左子树）（右子树）           中序遍历的结构组成是：（左子树）（根节点）（右子树）</p><p>那么我们就可以发现了，前序遍历的开头必是根节点，然后我们拿根节点在中序遍历里找，左边就是左子树的序列，右边就是右子树的序列，然后我们再回到前序遍历里找左子树，找到的第一个就是左子树的根节点，然后再拿这个根节点回到中序遍历里找…………以此循环往复，中途每次找到根节点就把它和父节点连起来最后得到的就是整个树的样子了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        return dfs(preorder,inorder);    &#125;    TreeNode* dfs(vector&lt;int&gt;p,vector&lt;int&gt;q)    &#123;        if(!p.size())return NULL;        TreeNode *root;        root&#x3D;new TreeNode(p[0]);        int n&#x3D;q.size();        vector&lt;int&gt;v1;        vector&lt;int&gt;v2;        vector&lt;int&gt;v3;        vector&lt;int&gt;v4;        int j;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(q[i]&#x3D;&#x3D;p[0])            &#123;                j&#x3D;i;                break;            &#125;            v1.push_back(p[i+1]);            v2.push_back(q[i]);        &#125;        for(int i&#x3D;j+1;i&lt;n;i++)        &#123;            v3.push_back(p[i]);            v4.push_back(q[i]);        &#125;        root-&gt;left&#x3D;dfs(v1,v2);        root-&gt;right&#x3D;dfs(v3,v4);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7</p><p>这题和前面的<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a>基本一样，只不过前序遍历的根节点是数组的第一位，我们后续遍历的根节点是数组的最后一位，只要注意节点的取值，其它的就一模一样了。（如果写了前面不会写这题说明你没明白彻底建议多回去看几遍前面的题）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;        return dfs(inorder,postorder);    &#125;    TreeNode* dfs(vector&lt;int&gt;p,vector&lt;int&gt;q)    &#123;        if(!q.size())return NULL;        vector&lt;int&gt;v1;        vector&lt;int&gt;v2;        vector&lt;int&gt;v3;        vector&lt;int&gt;v4;        TreeNode *root;        int n&#x3D;q.size(),j;        root &#x3D;new TreeNode(q[n-1]);        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(p[i]&#x3D;&#x3D;q[n-1])            &#123;                j&#x3D;i;                break;            &#125;            v1.push_back(p[i]);            v2.push_back(q[i]);        &#125;        for(int i&#x3D;j+1;i&lt;n;i++)        &#123;            v3.push_back(p[i]);            v4.push_back(q[i-1]);        &#125;        root-&gt;left&#x3D;dfs(v1,v2);        root-&gt;right&#x3D;dfs(v3,v4);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h4><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>示例 1:</p><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="tree.jpg (401×301) (leetcode.com)"></p><p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]</p><p>这题目前能想到简单点的方法就是层序遍历，层序遍历完后把每层的最后一个数存入vector中，最后返回那个vector。（注意一开始要判断root是否为空，如果为空就返回一个空的vector容器给它）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt;v1;    vector&lt;int&gt;v;    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        if(!root)return v;        dfs(root,0);        for(int i&#x3D;0;i&lt;v1.size();i++)        &#123;            v.push_back(v1[i][v1[i].size()-1]);        &#125;        return v;    &#125;    void dfs(TreeNode*root,int u)    &#123;        if(!root)return;        if(v1.size()&lt;u+1)        &#123;            vector&lt;int&gt;v2;            v1.push_back(v2);        &#125;        v1[u].push_back(root-&gt;val);        dfs(root-&gt;left,u+1);        dfs(root-&gt;right,u+1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-04每日刷题打卡</title>
      <link href="/2021/11/04/2021-11-04-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/04/2021-11-04-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-04每日刷题打卡"><a href="#2021-11-04每日刷题打卡" class="headerlink" title="2021-11-04每日刷题打卡"></a>2021-11-04每日刷题打卡</h1><h2 id="力扣——二叉树"><a href="#力扣——二叉树" class="headerlink" title="力扣——二叉树"></a>力扣——二叉树</h2><h4 id="102-二叉树的层序遍历和剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#102-二叉树的层序遍历和剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="102. 二叉树的层序遍历和剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>和<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层序遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><p>层序遍历很好理解就是一层层遍历。</p><p>第一种方法——递归：先准备一个全局的vector&lt;vector&lt; int &gt;&gt;容器v用以存结构，函数里先判断root是否为空，如果为空就直接把空的v返回，如果不为空，就把root传入dfs里，同时要传一个层数u，我们为了符合数组的存储方式层数我们从0开始。进入dfs，先判断root是否为空，如果为空就直接结束程序，如果不为空则判断一下当前v的size是否小于u+1，如果小于我们就创建一个vector容器插入v中，然后我们通过v[u].push_back()来插入当前root的val值，再把root的left和right分别送入下一次的dfs递归中，此时我们传的层数为u+1。当所有递归结束后返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt;v;    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;           if(!root)return v;        vector&lt;int&gt;v1;        v.assign(1, v1);        dfs(root,0);        return v;    &#125;    void dfs(TreeNode* root, int u)    &#123;        if (!root)return;        else        &#123;            if(v.size()&lt;u+1)            &#123;                vector&lt;int&gt;v1;                v.push_back(v1);            &#125;            v[u].push_back(root-&gt;val);            dfs(root-&gt;left, u + 1);            dfs(root-&gt;right, u + 1);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种方法——迭代：因为迭代是在一个函数里进行的，所以可以把全局函数vector&lt;vector&lt; int&gt;&gt;v设置在函数开头，当然也可以继续全局函数。先判断root是否为空，如果为空就返回空的v给它，如果不为空，那我们先准备一个queue容器que来存节点，先把root存入que中，然后开始while遍历，只要que不为空就一直遍历，每次遍历先拿一个数len存que的size，len就是当前层的节点数，这也决定了下面for循环的次数，再准备一个vector容器v1来存这一层节点的val值，然后开始for循环，循环len次，先把当前队列的头结点的val值存入v1中，然后把队列头结点的左子节点和右子节点存入que中，再把队头元素出队，for结束后把v1插入v中。一切遍历结束后返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;           vector&lt;vector&lt;int&gt;&gt;v;        if(!root)return v;        queue&lt;TreeNode*&gt;que;        que.push(root);        while(que.size())        &#123;            int len&#x3D;que.size();            vector&lt;int&gt;v1;            for(int i&#x3D;0;i&lt;len;i++)            &#123;                v1.push_back(que.front()-&gt;val);                if(que.front()-&gt;left)que.push(que.front()-&gt;left);                if(que.front()-&gt;right)que.push(que.front()-&gt;right);                que.pop();            &#125;            v.push_back(v1);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h4><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p>示例 1：</p><p>输入：<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>输出：[3, 14.5, 11]<br>解释：<br>第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</p><p>通过上面层序遍历的方法先得到各层的节点数，然后就正常的求平均值就是。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt;v;    vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;        vector&lt;double&gt;nums;        if(!root)return nums;        dfs(root,0);        double sum&#x3D;0;        int n&#x3D;v.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            for(int j&#x3D;0;j&lt;v[i].size();j++)            &#123;                sum+&#x3D;v[i][j];            &#125;            nums.push_back(sum&#x2F;v[i].size());            sum&#x3D;0;        &#125;        return nums;    &#125;    void dfs(TreeNode* root,int u)    &#123;        if(!root)return;        else        &#123;            if(v.size()&lt;u+1)            &#123;                vector&lt;int&gt;v1;                v.push_back(v1);            &#125;            v[u].push_back(root-&gt;val);            dfs(root-&gt;left,u+1);            dfs(root-&gt;right,u+1);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p><p>​    3</p><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回锯齿形层序遍历如下：</p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><p>用上面求层序遍历的方法求完各层节点数，然后把奇数层的节点全都改成逆序就行（偷鸡法）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt;v;    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;        if(!root)return v;        dfs(root,0);        int n&#x3D;v.size();        for(int i&#x3D;1;i&lt;n;i+&#x3D;2)        &#123;            int m&#x3D;v[i].size();            int k&#x3D;m-1;            for(int j&#x3D;0;j&lt;m&#x2F;2;j++)            &#123;                swap(v[i][j],v[i][k]);                k--;            &#125;        &#125;        return v;    &#125;    void dfs(TreeNode* root, int u)    &#123;        if (!root)return;        if (v.size() &lt; u + 1)        &#123;            vector&lt;int&gt;v1;            v.push_back(v1);        &#125;        v[u].push_back(root-&gt;val);        dfs(root-&gt;left, u + 1);        dfs(root-&gt;right, u + 1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="剑指-Offer-II-045-二叉树最底层最左边的值和513-找树左下角的值"><a href="#剑指-Offer-II-045-二叉树最底层最左边的值和513-找树左下角的值" class="headerlink" title="剑指 Offer II 045. 二叉树最底层最左边的值和513. 找树左下角的值"></a><a href="https://leetcode-cn.com/problems/LwUNpT/">剑指 Offer II 045. 二叉树最底层最左边的值</a>和<a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p>示例 1:</p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt="tree1.jpg (302×182) (leetcode.com)"></p><p>输入: root = [2,1,3]<br>输出: 1</p><p>用上面求层序遍历的方法求完各层节点数，然后返回最后一层的的第一个数就行。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt;v;    int findBottomLeftValue(TreeNode* root) &#123;        if(!root)return NULL;        dfs(root,0);        int n&#x3D;v.size()-1;        return v[n][0];    &#125;    void dfs(TreeNode*root,int u)    &#123;        if(!root)return;        if(v.size()&lt;u+1)        &#123;            vector&lt;int&gt;v1;            v.push_back(v1);        &#125;        v[u].push_back(root-&gt;val);        dfs(root-&gt;left,u+1);        dfs(root-&gt;right,u+1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单一点的方法：用一个queue容器que来存节点，准备一个数num_left来存每层最左边的数。先把root存入que中，然后开始while循环，只要que里还有元素就继续循环，先把当前队列的头元素的val值赋给num_left，因为队头元素就是每层的最左边的节点，再准备一个值len存当前队列的节点数，这代表这一层的节点数，也是下面for循环的结束条件。然后进入for循环，每次把当前队头元素的左子节点和右子节点传入队列，然后弹出队头元素（这时前面的len作用就体现出来了，循环len次，每次弹出队头元素，这样循环完后上一层的节点就全都消失，取之而代的是下一层的节点，队头元素就是最左边的节点）。当while结束后返回num_left。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int findBottomLeftValue(TreeNode* root) &#123;        if(!root)return NULL;        queue&lt;TreeNode*&gt;que;        int num_left;        que.push(root);        while(que.size())        &#123;            int len&#x3D;que.size();            num_left&#x3D;que.front()-&gt;val;            for(int i&#x3D;0;i&lt;len;i++)            &#123;                if(que.front()-&gt;left)que.push(que.front()-&gt;left);                if(que.front()-&gt;right)que.push(que.front()-&gt;right);                que.pop();            &#125;        &#125;        return num_left;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-03每日刷题打卡</title>
      <link href="/2021/11/03/2021-11-03-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/03/2021-11-03-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-03每日刷题打卡"><a href="#2021-11-03每日刷题打卡" class="headerlink" title="2021-11-03每日刷题打卡"></a>2021-11-03每日刷题打卡</h1><h2 id="力扣——二叉树"><a href="#力扣——二叉树" class="headerlink" title="力扣——二叉树"></a>力扣——二叉树</h2><p>昨天的前中后序遍历我们用的是递归的方法写的，今天我们改用迭代的方法。</p><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>迭代我们需要准备一个stack容器sta来存放节点以保证能回溯，一个vector容器v来存储结果。先判断给的树root是否为空，如果为空就直接把v返回给他结束程序，如果root不为空我们就开始遍历，用while来遍历root，只要root不为NULL或sta.size()不为0就一直循环下去，while里再套入一个while，只要root不为空就一直在这个while里，每次遍历把当前节点存入sta中，把节点的val存入v中，然后root=root-&gt;left一直遍历下去。当内部的while结束时说明当前节点为空了，也就说明它的父节点没有左节点，我们把存在sta中的父节点取出赋给root，同时顶端元素出栈，把现在节点的val值存入v中，然后让当前节点往right的方向走，然后回到最开始的地方进行下一次迭代。最后迭代结束后v里就是我们要的前序遍历，返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        if(!root)return v;        stack&lt;TreeNode*&gt;sta;        while(sta.size()||root)        &#123;            while(root)            &#123;                v.push_back(root-&gt;val);                sta.push(root);                root&#x3D;root-&gt;left;            &#125;            root&#x3D;sta.top();            sta.pop();            root&#x3D;root-&gt;right;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,3,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>中序遍历和前序遍历的大体步骤一样，但是while循环里的操作顺序略有不同，在while的嵌套while中，我们不往v中存节点的val值，只把节点存入sta中，然后一直往left遍历，当嵌套while结束时说明当前节点的父节点没有左节点，我们把sta的顶端元素（即父节点）赋给root，同时把顶端元素弹出，然后把当前节点的val存入v中，再把节点向right方向走，回到开头处继续迭代。最后返回v。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        if(!root)return v;        stack&lt;TreeNode*&gt;sta;        while(sta.size()||root)        &#123;            while(root)            &#123;                sta.push(root);                root&#x3D;root-&gt;left;            &#125;            root&#x3D;sta.top();            sta.pop();            v.push_back(root-&gt;val);            root&#x3D;root-&gt;right;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:</p><p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p><p>输出: [3,2,1]</p><p>和前面的中序遍历也是大同小异，但我们这里事先准备的不止v和sta，还要准备一个树节点p，初始指向NULL,然后开始遍历，嵌套的while和中序遍历一样，只存节点在sta里，然后节点一直往left走，嵌套的while结束说明当前节点的父节点没有左子树，我们从sta中取出并弹出顶端元素给root，然后判断一下，现在root的right是否等于NULL或等于p，如果满足一点，那么我们把当前节点的val存入v中，并把当前节点赋给p，然后令当前节点变为NULL；如果不满足任意一点，那么我们就把当前节点在存回sta中，并让节点向right方向走。然后回到开头继续迭代，最后返回v。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        if(!root)return v;        stack&lt;TreeNode*&gt;sta;        TreeNode*p&#x3D;NULL;        while(sta.size()||root)        &#123;            while(root)            &#123;                sta.push(root);                root&#x3D;root-&gt;left;            &#125;            root&#x3D;sta.top();            sta.pop();            if(!root-&gt;right||root-&gt;right&#x3D;&#x3D;p)            &#123;                v.push_back(root-&gt;val);                p&#x3D;root;                root&#x3D;NULL;            &#125;            else            &#123;                sta.push(root);                root&#x3D;root-&gt;right;            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h4><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p><p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p><p>我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。</p><p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" alt="q1248-01.png (304×270) (leetcode-cn.com)"></p><p>输入：root = [1,2,3,4], x = 4, y = 3<br>输出：false</p><p>堂兄弟的定义是：深度一样，父节点不一样。所以我们准备两个全局map容器father和mymap（不全局也可以，但dfs传参要多加这两个容器）来分别存放父节点和深度，我们用dfs函数来遍历树，dfs有五个参数，一个是当当前节点，一个是当前节点的子节点（左节点或右节点），一个是深度u（初始为0），还有两个是x和y。dfs一开始先判断当前节点是否为空，如果是就直接结束程序，如果不是就判断节点的val值等不等于x或y，如果等于就用mymap函数存下这个节点的深度u，再用father存下节点的父节点。然后我们把当前节点的左节点和右节点接着送去递归。当一切结束后，我们判断两个节点x和y的深度是否相等，如果相等判断他俩的父节点是否为同一个，如果为同一个即不是堂兄弟，如果不是则是堂兄弟。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    unordered_map&lt;int,int&gt;mymap;    unordered_map&lt;int,int&gt;father;    bool isCousins(TreeNode* root, int x, int y) &#123;        TreeNode* t;        t&#x3D;new TreeNode(200);        dfs(root,x,y,0,t);        if(mymap[x]&#x3D;&#x3D;mymap[y]&amp;&amp;father[x]!&#x3D;father[y])        &#123;            return true;        &#125;        return false;    &#125;    void dfs(TreeNode* p,int x,int y,int u,TreeNode* q)    &#123;        if(mymap.size()&#x3D;&#x3D;2)return;        if(!p)return;        if(p-&gt;val&#x3D;&#x3D;x)        &#123;            mymap[x]&#x3D;u;            father[x]&#x3D;q-&gt;val;        &#125;        else if(p-&gt;val&#x3D;&#x3D;y)        &#123;            mymap[y]&#x3D;u;            father[y]&#x3D;q-&gt;val;        &#125;        dfs(p-&gt;left,x,y,u+1,p);        dfs(p-&gt;right,x,y,u+1,p);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="flaten.jpg (1021×461) (leetcode.com)"></p><p>输入：root = [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]</p><p>准备一个全局vector容器v来存放节点，注意是存节点而不是val值，不喜欢全局变量的话dfs的参数要把v也传过去比较麻烦我就直接全局设定了。之前我们写过递归求前序遍历的方法拿到这里来也是通用的，当我们把前序排序的结果存在v里后，我们把根节点的left和right都指向NULL，然后用for遍历，i=1(因为根节点已经是v[0]了)，每次把根节点的right指向v[i]，然后把root往right上走一格，注意要把left都指向NULL。最后遍历完要把最后一个节点的right指向NULL。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;TreeNode*&gt;v;    void dfs(TreeNode* root)    &#123;        if (!root)return;        else        &#123;            v.push_back(root);            dfs(root-&gt;left);            dfs(root-&gt;right);        &#125;    &#125;    void flatten(TreeNode* root) &#123;        if (!root)return;        dfs(root);        root-&gt;left &#x3D; NULL;        root-&gt;right &#x3D; NULL;        int n &#x3D; v.size();        for (int i &#x3D; 1; i &lt; n; i++)        &#123;            root-&gt;right &#x3D; v[i];            root &#x3D; root-&gt;right;            root-&gt;left&#x3D;NULL;        &#125;        root-&gt;right &#x3D; NULL;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="872-叶子相似的树"><a href="#872-叶子相似的树" class="headerlink" title="872. 叶子相似的树"></a><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a></h4><p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。</p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt="tree.png (735×617) (s3-lc-upload.s3.amazonaws.com)"></p><p>举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。</p><p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。</p><p>如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg" alt="leaf-similar-1.jpg (1122×444) (leetcode.com)"></p><p>输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]<br>输出：true</p><p>这回没法用全局vector容器了，因为这次有两个v，如果用全局系统不知道把值插入哪个地方，所以这次老老实实传v做参数吧。</p><p>准备两个vector容器v1和v2，分别存root1和root2的叶子节点，我们实现一个dfs函数（这里我们采用的是前序遍历的方法），传入树节点root和vector容器做参数，每次先判断当前节点是否为空，如果为空就结束程序，如果不为空就判断当前节点有没有子节点（left和right）如果没有就说明这个是一个叶节点，我们把这个节点的val值存入v中，并结束程序。如果这个节点不是叶子节点，那我们就把当前节点的left和right分别送去递归。当递归完后v1和v2就存好了两个数的叶子节点，先判断两个v所存元素个数是否相等，如果不相等就直接返回false，如果相等再一个个比较元素，如果有不一样的就返回false。如果都一样就返回true。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool leafSimilar(TreeNode* root1, TreeNode* root2) &#123;        vector&lt;int&gt;v1;        vector&lt;int&gt;v2;        dfs(root1,v1);        dfs(root2,v2);        int n&#x3D;v1.size(),m&#x3D;v2.size();        if(n!&#x3D;m)return false;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(v1[i]!&#x3D;v2[i])return false;        &#125;        return true;    &#125;    void dfs(TreeNode* root,vector&lt;int&gt;&amp;v)    &#123;        if(!root)return;        else if(!root-&gt;left&amp;&amp;!root-&gt;right)        &#123;            v.push_back(root-&gt;val);            return;        &#125;        dfs(root-&gt;left,v);        dfs(root-&gt;right,v);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-02每日刷题打卡</title>
      <link href="/2021/11/02/2021-11-02-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/02/2021-11-02-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-02每日刷题打卡"><a href="#2021-11-02每日刷题打卡" class="headerlink" title="2021-11-02每日刷题打卡"></a>2021-11-02每日刷题打卡</h1><h2 id="力扣——二叉树"><a href="#力扣——二叉树" class="headerlink" title="力扣——二叉树"></a>力扣——二叉树</h2><h4 id="104-二叉树的最大深度和剑指-Offer-55-I-二叉树的深度"><a href="#104-二叉树的最大深度和剑指-Offer-55-I-二叉树的深度" class="headerlink" title="104. 二叉树的最大深度和剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>和<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p>​    3</p><p>   / <br>  9  20<br>    /  <br>   15   7</p><p>返回它的最大深度 3 。</p><p>遍历树，每次对比左子树和右子树的深度，选最大的那个。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root &#x3D;&#x3D; nullptr) return 0;        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="ex_depth.jpg (432×302) (leetcode.com)"></p><p>输入：root = [3,9,20,null,null,15,7]<br>输出：2</p><p>遍历树，每遍历一个结点判断一下，如果这个结点为NULL就返回0，如果这个结点left和right都为NULL，说明这个结点就是叶子结点，返回1。如果不是叶子节点，拿这个结点接着去遍历，这个结点的左子树和右子树看看哪个的深度最小，最后返回这个小的深度+1（+1是算上根节点）。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        if(!root)return 0;        if(!root-&gt;left&amp;&amp;!root-&gt;right)return 1;        int num&#x3D;100000;        if(root-&gt;left!&#x3D;NULL)num&#x3D;min(minDepth(root-&gt;left),num);        if(root-&gt;right!&#x3D;NULL)num&#x3D;min(minDepth(root-&gt;right),num);        return num+1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="complete.jpg (372×302) (leetcode.com)"></p><p>输入：root = [1,2,3,4,5,6]<br>输出：6</p><p>用dfs来写树是最方便了，dfs函数一开始先判断结点是否为NULL，如果是就返回0，如果不是再判断这节点是否是叶子节点（无左节点和右节点），如果是就只记此处有一个节点（return 1)。如果不是就递归调用dfs本身，把这个节点的左节点和右节点当做参数送去遍历，把结果相加后再＋1返回(+1是为了算上自己本身的节点)。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int countNodes(TreeNode* root) &#123;        if(!root)return 0;        return dfs(root-&gt;left)+dfs(root-&gt;right)+1;    &#125;    int dfs(TreeNode *p)    &#123;        if(!p)return 0;        else if(!p-&gt;left&amp;&amp;!p-&gt;right)return 1;        return dfs(p-&gt;left)+dfs(p-&gt;right)+1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h4><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p><p>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg" alt="subtree1-tree.jpg (532×400) (leetcode.com)"></p><p>输入：root = [3,4,5,1,2], subRoot = [4,1,2]<br>输出：true</p><p>判断root中有subRoot的条件是：root和subRoot相等，或subRoot是root的一个左子树，或subRoot是root的一个右子树。而判断root和subRoot相等的条件是：root和subRoot的val值相等，且root的左子树和subRoot的左子树的val值相等，且root的右子树和subRoot的右子树的val值相等。所以我们要写两个递归函数，一个是判断root中有subRoot的dfs函数，还有一个是判断root和subRoot相等的check函数。</p><p>dfs的实现是，先判断当前节点是否为NULL，如果是说明不与subRoot本身相等（subRoot本身至少有一个节点），然后用check来判断当前节点是否和subRoot相等，判断subRoot是否是root的左子树或右子树，只要这三者有一个为true那就为true；</p><p>check的实现是，判断当前节点和subRoot是否都为NULL（我们传递的参数有可能是subRoot的子节点，所以会出现subRoot为空的情况），如果都为空说明相等返回true，然后判断当前节点和subRoot是否有一个为空，如果有就返回false，判断当前节点的val和subRoot的val是否相等，如果不相等返回false，如果相等把当前节点的左节点和subRoot的左节点拿去下一次判断，再把当前节点的右节点和subRoot的右节点拿去下一次判断，两者只要有一个不为true那就都不为true。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123;        return dfs(root,subRoot);    &#125;    bool dfs(TreeNode*p,TreeNode*q)    &#123;        if(!p)return false;        return check(p,q)||dfs(p-&gt;left,q)||dfs(p-&gt;right,q);    &#125;    bool check(TreeNode*p,TreeNode*q)    &#123;        if(!p&amp;&amp;!q)return true;        if(!p&amp;&amp;q||p&amp;&amp;!q||p-&gt;val!&#x3D;q-&gt;val)return false;        return check(p-&gt;left,q-&gt;left)&amp;&amp;check(p-&gt;right,q-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前序遍历：先从根节点开始，然后到左节点，再到右节点。</p><p>我们准备一个vector容器v来存放遍历顺序，用dfs来遍历树，dfs的实现是：先判断当前节点是否为空，如果为空就结束程序，如果不为空就先把当前节点的值存入v中，然后把节点的左子树先送去dfs下一次递归，再把右子树送去下一次递归。当递归完后前序排列的顺序就都存在v中了，返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        dfs(root,v);        return v;    &#125;    void dfs(TreeNode* p,vector&lt;int&gt;&amp; v)    &#123;        if(!p)return;        else        &#123;            v.push_back(p-&gt;val);            dfs(p-&gt;left,v);            dfs(p-&gt;right,v);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,3,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>中序遍历：先从左节点开始，然后到跟节点，再到右节点。</p><p>我们准备一个vector容器v来存放遍历顺序，用dfs来遍历树，dfs的实现是：先判断当前节点是否为空，如果为空就结束程序，如果不为空就先把节点的左子树先送去dfs下一次递归，然后把当前节点的值存入v中，再把右子树送去下一次递归。当递归完后中序排列的顺序就都存在v中了，返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        dfs(root,v);        return v;    &#125;       void dfs(TreeNode* p,vector&lt;int&gt;&amp; v)    &#123;        if(!p)return;        else        &#123;            dfs(p-&gt;left,v);            v.push_back(p-&gt;val);            dfs(p-&gt;right,v);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:</p><p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p><p>输出: [3,2,1]</p><p>后序遍历：先从左节点开始，然后到右节点，再到跟节点。</p><p>我们准备一个vector容器v来存放遍历顺序，用dfs来遍历树，dfs的实现是：先判断当前节点是否为空，如果为空就结束程序，如果不为空就先把节点的左子树先送去dfs下一次递归，然后把右子树送去下一次递归，再把当前节点的值存入v中。当递归完后后序排列的顺序就都存在v中了，返回v即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;v;        dfs(root,v);        return v;    &#125;    void dfs(TreeNode*p,vector&lt;int&gt;&amp; v)    &#123;        if(!p)return;        else        &#123;            dfs(p-&gt;left,v);            dfs(p-&gt;right,v);            v.push_back(p-&gt;val);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这三个遍历只是改变了在v中插入值、传左子树递归、传右子树递归的顺序而已。本质上来说是一模一样的。</p>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-11-01每日刷题打卡</title>
      <link href="/2021/11/01/2021-11-01-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/11/01/2021-11-01-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-11-01每日刷题打卡"><a href="#2021-11-01每日刷题打卡" class="headerlink" title="2021-11-01每日刷题打卡"></a>2021-11-01每日刷题打卡</h1><h2 id="力扣——二叉树"><a href="#力扣——二叉树" class="headerlink" title="力扣——二叉树"></a>力扣——二叉树</h2><h4 id="965-单值二叉树"><a href="#965-单值二叉树" class="headerlink" title="965. 单值二叉树"></a><a href="https://leetcode-cn.com/problems/univalued-binary-tree/">965. 单值二叉树</a></h4><p>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。</p><p>只有给定的树是单值二叉树时，才返回 true；否则返回 false。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png" alt="screen-shot-2018-12-25-at-50104-pm.png "></p><p>输入：[1,1,1,1,1,null,1]<br>输出：true</p><p>这题考的就是树的遍历，比起链表的一个指针next，树有两个指针一个left，一个right。对于树的遍历我们最好用的就是递归的方式。全局变量设定一个bool类型flag初始化为true，每次遍历对比当前节点的val和其left与right的val值，如果不相等就设为false并直接结束所有程序返回flag，如果相等，就把root-&gt;left和root-&gt;right放入遍历中。最后返回flag。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool flag&#x3D;true;    bool isUnivalTree(TreeNode* root) &#123;        if(root&#x3D;&#x3D;NULL)return flag;        if(root-&gt;left!&#x3D;NULL)        &#123;            if(root-&gt;val!&#x3D;root-&gt;left-&gt;val)flag&#x3D;false;            isUnivalTree(root-&gt;left);        &#125;        if(root-&gt;right!&#x3D;NULL)        &#123;            if(root-&gt;val!&#x3D;root-&gt;right-&gt;val)flag&#x3D;false;            isUnivalTree(root-&gt;right);        &#125;        return flag;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种方法，不用全局变量。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isUnivalTree(TreeNode* root) &#123;        bool flag&#x3D;true;        int val&#x3D;root-&gt;val;        dfs(root,flag,val);        return flag;    &#125;    void dfs(TreeNode* root,bool &amp;flag,int val)    &#123;        if(root&#x3D;&#x3D;NULL)return;        if(root-&gt;left!&#x3D;NULL&amp;&amp;root-&gt;left-&gt;val!&#x3D;val)flag&#x3D;false;        if(root-&gt;right!&#x3D;NULL&amp;&amp;root-&gt;right-&gt;val!&#x3D;val)flag&#x3D;false;        dfs(root-&gt;left,flag,val);        dfs(root-&gt;right,flag,val);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h4><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="ex1.jpg (622×182) (leetcode.com)"></p><p>输入：p = [1,2,3], q = [1,2,3]<br>输出：true</p><p>还是遍历树，不过这次是同时遍历两个，还要对比他们的val值。注意有一点，对比root-&gt;val时要考虑到节点为NULL的情况，这会使程序报错，所以对比值前我们应该先判断一下两个节点是否为NULL，如果两个都为NULL那就直接return结束程序，如果只有一个为空就把flag改为false（一个节点有值一个节点没值肯定不一样），如果都不为空就对比val。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSameTree(TreeNode* p, TreeNode* q) &#123;        bool flag&#x3D;true;        dfs(p,q,flag);        return flag;    &#125;    void dfs(TreeNode* p, TreeNode* q,bool &amp;flag) &#123;        if(!flag)return;        if(p&#x3D;&#x3D;NULL&amp;&amp;q&#x3D;&#x3D;NULL)return;        else if(p&#x3D;&#x3D;NULL&amp;&amp;q!&#x3D;NULL||p!&#x3D;NULL&amp;&amp;q&#x3D;&#x3D;NULL)        &#123;            flag&#x3D;false;            return;        &#125;        if(p-&gt;val!&#x3D;q-&gt;val)flag&#x3D;false;        dfs(p-&gt;left,q-&gt;left,flag);        dfs(p-&gt;right,q-&gt;right,flag);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="101-对称二叉树和剑指-Offer-28-对称的二叉树（这两题完全一样，我们放在一起说）"><a href="#101-对称二叉树和剑指-Offer-28-对称的二叉树（这两题完全一样，我们放在一起说）" class="headerlink" title="101. 对称二叉树和剑指 Offer 28. 对称的二叉树（这两题完全一样，我们放在一起说）"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a>和<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a>（这两题完全一样，我们放在一起说）</h4><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p>​    1</p><p>   / <br>  2   2<br> / \ / <br>3  4 4  3</p><p>这题就是上题的翻版，不过上题比较的是相同的子节点，即left和left比，right和right比。这题是left和right比，right和left比。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        bool flag&#x3D;true;        dfs(root-&gt;left,root-&gt;right,flag);        return flag;    &#125;    void dfs(TreeNode *p,TreeNode*q,bool &amp;flag)    &#123;        if(!flag)return;        if(!p&amp;&amp;!q)return;        else if(!p&amp;&amp;q || p&amp;&amp;!q)        &#123;            flag&#x3D;false;            return;        &#125;        if(p-&gt;val!&#x3D;q-&gt;val)flag&#x3D;false;        dfs(p-&gt;left,q-&gt;right,flag);        dfs(p-&gt;right,q-&gt;left,flag);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AcWing——算法基础"><a href="#AcWing——算法基础" class="headerlink" title="AcWing——算法基础"></a>AcWing——算法基础</h2><h4 id="842-排列数字-AcWing题库"><a href="#842-排列数字-AcWing题库" class="headerlink" title="842. 排列数字 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/844/">842. 排列数字 - AcWing题库</a></h4><p>给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>按字典序输出所有排列方案，每个方案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤7</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 2 31 3 22 1 32 3 13 1 23 2 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是我们第一次接触到DFS（深度优先搜索）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将  <em>回溯</em>  到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。</p><p>这里排列数字的过程就是，我们要组成一个三位数的数字，第一位的可能性有1、2、3，我们先选1，第二位的可能性就剩2、3，我们选2，第三位就只剩3了，这条路搜索完毕，我们回溯到第二位上，选3为第二位，这样第三位就只剩2了，这条路也搜索完毕，我们回溯到第二位上，第二位可能的结果也都搜索完，我们回溯到第一位上，选数字2为第一位，然后继续搜…………这样最后我们就可以拿到所有的数。</p><p>我们准备一个int数组math来存放结果，一个bool数组st来告诉我们哪些数不能用，写一个递归函数dfs来进行我们的搜索，只有一个参数u，dfs进来先判断u和n是否相同，如果相同则输出math里存放的结果（要注意换行）。如果不相同我们就开始for(int i=0;i&lt; n;i++)遍历，判断st[i]的值是否为true，如果为true说明i表示的数我们已经使用过了，如果为false说明这个数我们没用过，可以放在第u位上，所有我们math[u]=i，同时把st[i]改为true告诉程序这个数已经被用过了。然后我们递归调用dfs(u+1)，下面是回溯的操作，我们要把数变回原来的样子，即这个数没被使用过的样子st[i]=false。这样我们最后就能获得所有的结果。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100010;int n;int math[N];bool st[N];void dfs(int u)&#123;    if(u&#x3D;&#x3D;n)    &#123;        for(int i&#x3D;0;i&lt;n;i++)printf(&quot;%d &quot;,math[i]);        cout&lt;&lt;endl;        return;    &#125;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)    &#123;        if(!st[i])        &#123;            st[i]&#x3D;true;            math[u]&#x3D;i;            dfs(u+1);            st[i]&#x3D;false;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;math[i]);    dfs(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="843-n-皇后问题-AcWing题库"><a href="#843-n-皇后问题-AcWing题库" class="headerlink" title="843. n-皇后问题 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/845/">843. n-皇后问题 - AcWing题库</a></h4><p>n−n−皇后问题是指将 n 个皇后放在 n×n的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p><p><img src="https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png" alt="1_597ec77c49-8-queens.png"></p><p>现在给定整数 n，请你输出所有的满足条件的棋子摆法。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含整数 n。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>每个解决方案占 n 行，每行输出一个长度为 nn 的字符串，用来表示完整的棋盘状态。</p><p>其中 <code>.</code> 表示某一个位置的方格状态为空，<code>Q</code> 表示某一个位置的方格上摆着皇后。</p><p>每个方案输出完成后，输出一个空行。</p><p><strong>注意：行末不能有多余空格。</strong></p><p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤9</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">.Q.....QQ.....Q...Q.Q......Q.Q..<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DFS中最最最最最最最最最经典的八皇后问题，我们用的就是深度优先搜索的方法来写这道题，拿一个二维数组来模拟棋盘的样子，Q代表皇后的位置，我们的想法是先把皇后放在所有可能的地方上，每放一个皇后，就判断这个皇后同行同列同斜列上有没有皇后，如果有就说明这个方法不可行，然后回溯，然后再选新地方放…………以此类推。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100;int n;char queen[N][N];bool col[N],dg[N],udg[N];void dfs(int u)&#123;    if(u&#x3D;&#x3D;n)    &#123;        for(int i&#x3D;0;i&lt;n;i++)cout&lt;&lt;queen[i]&lt;&lt;endl;        cout&lt;&lt;endl;        return;    &#125;    for(int i&#x3D;0;i&lt;n;i++)    &#123;        if(!col[i]&amp;&amp;!dg[i+u]&amp;&amp;!udg[n-u+i])        &#123;            queen[u][i]&#x3D;&#39;Q&#39;;            col[i]&#x3D;dg[u+i]&#x3D;udg[n-u+i]&#x3D;true;            dfs(u+1);            col[i]&#x3D;dg[u+i]&#x3D;udg[n-u+i]&#x3D;false;            queen[u][i]&#x3D;&#39;.&#39;;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)        for(int j&#x3D;0;j&lt;n;j++)            queen[i][j]&#x3D;&#39;.&#39;;    dfs(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周总结：2021-10-25——10-31</title>
      <link href="/2021/10/31/zhou-zong-jie-2021-10-25-10-31/"/>
      <url>/2021/10/31/zhou-zong-jie-2021-10-25-10-31/</url>
      
        <content type="html"><![CDATA[<h1 id="周总结：2021-10-25——10-31"><a href="#周总结：2021-10-25——10-31" class="headerlink" title="周总结：2021-10-25——10-31"></a>周总结：2021-10-25——10-31</h1><h3 id="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"><a href="#这里是这一周来刷题时印象比较深的几道题，挑出来做个总结" class="headerlink" title="这里是这一周来刷题时印象比较深的几道题，挑出来做个总结"></a>这里是这一周来刷题时印象比较深的几道题，挑出来做个总结</h3><h4 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h4><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>进阶：</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</p><p>示例 1:</p><p>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        queue&lt;int&gt;que;        int n &#x3D; nums.size();        int m &#x3D; k % n;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            que.push(nums[i]);        &#125;        while(m--)        &#123;            int num&#x3D;que.front();            que.pop();            que.push(num);        &#125;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            nums[i]&#x3D;que.front();            que.pop();        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_map&lt;int,int&gt;mymap;        stack&lt;int&gt;sta;        vector&lt;int&gt;v;        int n&#x3D;nums1.size();        for(int i&#x3D;nums2.size()-1;i&gt;&#x3D;0;i--)        &#123;            int num &#x3D; nums2[i];            while(!sta.empty()&amp;&amp;sta.top()&lt;num)            &#123;                sta.pop();            &#125;            mymap[num]&#x3D;sta.empty()?-1:sta.top();            sta.push(num);        &#125;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            v.push_back(mymap[nums1[i]]);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        if(s.size()&#x3D;&#x3D;0)        &#123;            return 0;        &#125;        int len&#x3D;0;        string str;        int n&#x3D;s.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            for(int j&#x3D;i;j&lt;n;j++)            &#123;                string str1;                str1+&#x3D;s[j];                string::size_type idx &#x3D; str.find( str1 );                if(str.size()!&#x3D;0&amp;&amp;idx !&#x3D; string::npos)                &#123;                    break;                &#125;                else                &#123;                    str+&#x3D;str1;                &#125;            &#125;                        if(len&lt;str.size())            &#123;                len&#x3D;str.size();            &#125;            str.clear();        &#125;                return len;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h4><p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p><p>进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p><p>示例 1：</p><p>输入：nums = [1,2,1,3,2,5]<br>输出：[3,5]<br>解释：[5, 3] 也是有效的答案。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        vector&lt;int&gt;v;        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(i+1&gt;&#x3D;n&amp;&amp;v.size()&lt;&#x3D;1)            &#123;                v.push_back(nums[i]);            &#125;            else            &#123;                if(nums[i]!&#x3D;nums[i+1])                &#123;                    v.push_back(nums[i]);                       if(v.size()&#x3D;&#x3D;2)                    &#123;                        break;                    &#125;                                                                &#125;                else                &#123;                    int num&#x3D;nums[i];                    while(nums[i]&#x3D;&#x3D;num)                    &#123;                        i++;                    &#125;                    i--;                &#125;            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-30每日刷题打卡</title>
      <link href="/2021/10/30/2021-10-30-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/30/2021-10-30-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-30每日刷题打卡"><a href="#2021-10-30每日刷题打卡" class="headerlink" title="2021-10-30每日刷题打卡"></a>2021-10-30每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h4><p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p><p>进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p><p>示例 1：</p><p>输入：nums = [1,2,1,3,2,5]<br>输出：[3,5]<br>解释：[5, 3] 也是有效的答案。</p><p>用哈希计数，准备一个unordered_map容器mymap，遍历nums，用mymap计算每个数字出现的次数。最后从mymap里找到出现次数为1的两个数，返回即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int,int&gt;mymap;        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            mymap[nums[i]]++;        &#125;        vector&lt;int&gt;v;        for(auto i:mymap)        &#123;            if(i.second&#x3D;&#x3D;1)            &#123;                v.push_back(i.first);            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进阶——常数空间：就准备一个vector容器v来存结果的两个数，对nums排序，遍历nums，每次判断当前数是否和下一个数相同，如果不相同就把数插入v中，如果相同就持续遍历，直到不相同为止。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        vector&lt;int&gt;v;        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(i+1&gt;&#x3D;n&amp;&amp;v.size()&lt;&#x3D;1)            &#123;                v.push_back(nums[i]);            &#125;            else            &#123;                if(nums[i]!&#x3D;nums[i+1])                &#123;                    v.push_back(nums[i]);                       if(v.size()&#x3D;&#x3D;2)                    &#123;                        break;                    &#125;                                                                &#125;                else                &#123;                    int num&#x3D;nums[i];                    while(nums[i]&#x3D;&#x3D;num)                    &#123;                        i++;                    &#125;                    i--;                &#125;            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/789/">787. 归并排序 - AcWing题库</a></p><p>给定你一个长度为 n 的整数数列。</p><p>请你使用归并排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">53 1 2 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>归并排序也是分治的思想，把一串数组对半分，直到分成一个个数，在把数两个两个的组合成有序对数。比如我们把6 2 4 5 3 1这个数组进行排序，最终分成6和2和4和5和3和1这六个数组，然后两两组合成2 6、4 5、3 1，（组合的方式是，拿一个数组tmp来存，把两个目标数组里的数进行比较，每次挑小的那个放入tmp中即可），再组合成2 4 5 6、3 1，再组合就成了1 2 3 4 5 6，这就是归并排序，即分治后归并。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;1e6+5;int n;int nums[N],tmp[N];void merge_sort(int nums[],int l,int r)&#123;    if(l&gt;&#x3D;r)return;    int mid&#x3D;(l+r)&#x2F;2;    merge_sort(nums,l,mid);    merge_sort(nums,mid+1,r);    int k&#x3D;0,i&#x3D;l,j&#x3D;mid+1;    while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;r)    &#123;        if(nums[i]&lt;&#x3D;nums[j])tmp[k++]&#x3D;nums[i++];        else tmp[k++]&#x3D;nums[j++];    &#125;    while(i&lt;&#x3D;mid)tmp[k++]&#x3D;nums[i++];    while(j&lt;&#x3D;r)tmp[k++]&#x3D;nums[j++];        for(i&#x3D;l,j&#x3D;0;i&lt;&#x3D;r;i++,j++)        nums[i]&#x3D;tmp[j];&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;nums[i]);    merge_sort(nums,0,n-1);    for(int i&#x3D;0;i&lt;n;i++)printf(&quot;%d &quot;,nums[i]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-29每日刷题打卡</title>
      <link href="/2021/10/29/2021-10-29-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/29/2021-10-29-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-29每日刷题打卡"><a href="#2021-10-29每日刷题打卡" class="headerlink" title="2021-10-29每日刷题打卡"></a>2021-10-29每日刷题打卡</h1><h2 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h2><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/woGGnF/">间隔删除链表结点 - 力扣 (LeetCode) 竞赛 (leetcode-cn.com)</a></p><p>给你一个链表的头结点 <code>head</code>，每隔一个结点删除另一个结点（要求保留头结点）。<br>请返回最终链表的头结点。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>head = [1,2,3,4]</code></p><p>输出: <code>[1,3]</code></p><p>解释：<br>蓝色结点为删除的结点</p><p>  <img src="https://pic.leetcode-cn.com/1622545030-DwtsVD-image.png" alt="08"></p></blockquote><p>开头写一个指针指向head，用这个指针遍历，一次遍历跳过当前节点，一次遍历直接往下走没有多余操作。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* deleteListNode(ListNode* head) &#123;        ListNode*p,*q;        p&#x3D;head;        q&#x3D;(ListNode*)malloc(sizeof(ListNode));        q-&gt;next&#x3D;p;        int i&#x3D;1;        while(p!&#x3D;NULL&amp;&amp;p-&gt;next!&#x3D;NULL)        &#123;            if(i&#x3D;&#x3D;1)            &#123;                i&#x3D;0;                p-&gt;next&#x3D;p-&gt;next-&gt;next;            &#125;            else            &#123;                i++;                p&#x3D;p-&gt;next;            &#125;        &#125;        return q-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/9Rs2aO/">柱状图分析 - 力扣 (LeetCode) 竞赛 (leetcode-cn.com)</a></p><p>某柱状图上共有 N 个柱形，数组 <code>heights</code> 中按照排列顺序记录了每个柱形的高度。假定任选 <code>cnt</code> 个柱形可组成一个柱形组，请在所有可能的柱形组中，找出最大高度与最小高度的差值为最小的柱形组，按高度升序返回该柱形组。若存在多个柱形组满足条件，则返回第一个元素最小的柱形组。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>heights = [3,2,7,6,1,8], cnt = 3</code></p><p>输出：<code>[1,2,3]</code></p><p>解释：[1,2,3] 与 [6,7,8] 都符合在所有的柱形组中，最大高度与最小高度的差值为最小的条件，选择第一个元素最小的 [1,2,3] 返回。</p></blockquote><p>先对heights进行排序，然后用长度为cnt的滑动窗口持续找。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; analysisHistogram(vector&lt;int&gt;&amp; heights, int cnt) &#123;        sort(heights.begin(),heights.end());        vector&lt;int&gt;v;        int min&#x3D;1000000,n;        for(int i&#x3D;0;i&lt;&#x3D;heights.size()-cnt;i++)            &#123;            int num&#x3D;heights[cnt+i-1]-heights[i];            if(num&lt;min)                &#123;                n&#x3D;i;                min&#x3D;num;            &#125;        &#125;        for(int i&#x3D;n;i&lt;n+cnt;i++)            &#123;            v.push_back(heights[i]);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-28每日刷题打卡</title>
      <link href="/2021/10/28/2021-10-28-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/28/2021-10-28-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-28每日刷题打卡"><a href="#2021-10-28每日刷题打卡" class="headerlink" title="2021-10-28每日刷题打卡"></a>2021-10-28每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="869-重新排序得到-2-的幂"><a href="#869-重新排序得到-2-的幂" class="headerlink" title="869. 重新排序得到 2 的幂"></a><a href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></h4><p>给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p><p>如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。</p><p>示例 1：</p><p>输入：1<br>输出：true</p><p>说是通过排序来判断能不能组成2的幂数那就不用管啥顺序了，直接判断这个数的组成就行（比如16就是1个1和1个6组成）。 先是看到2的幂，一看到条件数最大也就10^9,那就直接整个蠢方法，拿个字符串数组把小于10^9的2的幂全存进去（包括1）。再准备两个map容器，第一个拿来存所给数的组成成分，遍历我们的字符串数组，就找size和所给数位数相等的元素就行，遍历到后用第二个map容器来统计这个字符串的所给成分，之后拿两个map容器做对比，如果相同就可以返回true，如果不相等就把第二个map清空开始找下一个字符串。要是遍历完后还没能返回true那就返回false。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool reorderedPowerOf2(int n) &#123;        string math[]&#x3D;&#123;&quot;1&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;16&quot;,&quot;32&quot;,&quot;64&quot;,&quot;128&quot;,&quot;256&quot;,&quot;512&quot;,&quot;1024&quot;,&quot;2048&quot;,&quot;4096&quot;,                       &quot;8192&quot;,&quot;16384&quot;,&quot;32768&quot;,&quot;65536&quot;,&quot;131072&quot;,&quot;262144&quot;,&quot;524288&quot;,&quot;1048576&quot;,                       &quot;2097152&quot;,&quot;4194304&quot;,&quot;8388608&quot;,&quot;16777216&quot;,&quot;33554432&quot;,&quot;67108864&quot;,&quot;134217728&quot;,                       &quot;268435456&quot;,&quot;536870912&quot;&#125;;        string num;        vector&lt;int&gt;v;        unordered_map&lt;char,int&gt;num_map;        unordered_map&lt;char,int&gt;math_map;        while(n!&#x3D;0)        &#123;            v.push_back(n%10);            n&#x2F;&#x3D;10;        &#125;        int m&#x3D;v.size();        for(int i&#x3D;m-1;i&gt;&#x3D;0;i--)        &#123;            num+&#x3D;v[i]+48;        &#125;        for(int i&#x3D;0;i&lt;m;i++)        &#123;            num_map[num[i]]++;        &#125;        for(int i&#x3D;0;i&lt;30;i++)        &#123;            if(math[i].size()&#x3D;&#x3D;m)            &#123;                for(int j&#x3D;0;j&lt;m;j++)                &#123;                    math_map[math[i][j]]++;                &#125;                for(int i&#x3D;0;i&lt;m;i++)                &#123;                    if(math_map[num[i]]!&#x3D;num_map[num[i]])                    &#123;                        math_map.clear();                        break;                    &#125;                &#125;                if(math_map.size()!&#x3D;0)                &#123;                    return true;                &#125;            &#125;            else if(math[i].size()&gt;m)            &#123;                break;            &#125;        &#125;        return false;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ACWing——算法基础"><a href="#ACWing——算法基础" class="headerlink" title="ACWing——算法基础"></a>ACWing——算法基础</h2><p><a href="https://www.acwing.com/problem/content/787/">785. 快速排序 - AcWing题库</a></p><p>给定你一个长度为 nn 的整数数列。</p><p>请你使用快速排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">53 1 2 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要用到分治的思想，即把数组分成一部分一部分的来解决。比如4 1 3 2 5，我们先取一个中间值x，随便取，这里我们取2，然后把数组分成两截，大于等于x的放在数组右边，小于等于的我们放在左边。（放的方法我们可以用双指针，一个l在最左边（找大于等于x的值），一个r在最右边（找小于等于x的值），开始遍历，l遍历到4的时候，因为大于x所以就不往前走了，到r走，r走到5，大于x，继续走，走到2小于x了，停下来，然后做个判断，如果l&lt;j，那就把两者的数据交换一下，这样数组就变成了2 1 3 4 5，两个指针继续走，当l&gt;j时结束循环，这样大于等于2的数都在右边了，小于等于2的数都在左边），然后我们把左边的数组继续送去如上操作，右边也是，知道数组里只有一个元素为止。这就是分治——分成一个个小的解决。当一切分完后，排序也排好了。时间复杂度为nlogn，如果被数据针对会变成n^2.</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1e6 + 10;int n;int nums[N];void quick_sort(int nums[], int l, int r)&#123;    if (l &gt;&#x3D; r)return;    int x &#x3D; nums[(l+r)&#x2F;2], i &#x3D; l-1, j &#x3D; r+1 ;    while (i &lt; j)    &#123;        do i++;while(nums[i]&lt;x);        do j--;while(nums[j]&gt;x);        if (i &lt; j)swap(nums[i], nums[j]);    &#125;    quick_sort(nums, l, j);    quick_sort(nums, j + 1, r);&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i &#x3D; 0; i &lt; n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);    &#125;    quick_sort(nums, 0, n - 1);    for (int i &#x3D; 0; i &lt; n; i++)    &#123;        printf(&quot;%d &quot;, nums[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/788/">786. 第k个数 - AcWing题库</a></p><p>给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 kk 个数。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 k。</p><p>第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整数数列。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示数列的第 k 小数。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>1≤k≤n</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">5 32 4 1 5 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这就是上面的题，为了加深上面的印象，只不过这里不是输出数组，而是输出数组索引为k-1的那个元素。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;1e6+10;int n;int k;int nums[N];void quick_sort(int nums[],int l,int r)&#123;    if(l&gt;&#x3D;r)return ;    int x&#x3D;nums[(l+r)&#x2F;2],i&#x3D;l-1,j&#x3D;r+1;    while(i&lt;j)    &#123;        do        &#123;            i++;        &#125;while(nums[i]&lt;x);        do        &#123;            j--;        &#125;while(nums[j]&gt;x);        if(i&lt;j) swap(nums[i],nums[j]);    &#125;    quick_sort(nums,l,j);    quick_sort(nums,j+1,r);&#125;int main()&#123;    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);    for(int i&#x3D;0;i&lt;n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;nums[i]);    &#125;    quick_sort(nums,0,n-1);    cout&lt;&lt;nums[k-1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-27每日刷题打卡</title>
      <link href="/2021/10/27/2021-10-27-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/27/2021-10-27-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-27每日刷题打卡"><a href="#2021-10-27每日刷题打卡" class="headerlink" title="2021-10-27每日刷题打卡"></a>2021-10-27每日刷题打卡</h1><h2 id="力扣——算法入门"><a href="#力扣——算法入门" class="headerlink" title="力扣——算法入门"></a>力扣——算法入门</h2><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a></h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>示例 1：</p><p>输入：s = [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>简简单单的双指针</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int left&#x3D;0,right&#x3D;s.size()-1;        while(left&lt;right)        &#123;            char c&#x3D;s[left];            s[left]&#x3D;s[right];            s[right]&#x3D;c;            left++;            right--;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></h4><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p>示例：</p><p>输入：”Let’s take LeetCode contest”<br>输出：”s’teL ekat edoCteeL tsetnoc”</p><p>用上快慢指针，一个慢指针left，一个快指针right，初始都指向0，开始遍历，当right&gt;=s.size()时结束循环。每次遍历时判断s[left]是否是空格，如果是，left和right都++；如果不是空格，则right先走，走到right的下一个为空格时停下（因为结尾处没空格，所以要加个判断right&lt;n，防止越界报错），然后left和right开始呼唤元素，换完后两个指针去往之前right停下的位置，继续下一次遍历。最后返回s。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    string reverseWords(string s) &#123;        int left&#x3D;0,right&#x3D;0,n&#x3D;s.size();        while(right&lt;n)        &#123;            if(s[left]&#x3D;&#x3D;&#39; &#39;)            &#123;                left++;                right++;            &#125;            else            &#123;                while(right+1&lt;n&amp;&amp;s[right+1]!&#x3D;&#39; &#39;)                &#123;                    right++;                &#125;                int m&#x3D;right+1;                while(left&lt;right)                &#123;                    char c&#x3D;s[left];                    s[left]&#x3D;s[right];                    s[right]&#x3D;c;                    left++;                    right--;                &#125;                left&#x3D;m;                right&#x3D;m;            &#125;        &#125;        return s;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：</p><p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p><p>还是用快慢指针走，准备两个指针，一个p一个q，初始都指向head，开始遍历，当q为空或q的next为空时结束遍历。每次p走一格，q走两格，这也p的位置就始终在q与头结点的位置的中间处，那么当q走到末尾时，p自然就为链表的中间结点了。遍历结束后返回p即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        ListNode*p,*q;        p&#x3D;head;        q&#x3D;head;        while(q!&#x3D;NULL&amp;&amp;q-&gt;next!&#x3D;NULL)        &#123;            p&#x3D;p-&gt;next;            q&#x3D;q-&gt;next;            q&#x3D;q-&gt;next;        &#125;        return p;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="image-20211027090622223"></p><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p><p>继续快慢指针,准备三个指针p,q,o，p-&gt;next指向head，o指向p，q指向head。q做快指针先走，走n格之后q和p一起走，当q为NULL时，p-&gt;next就是我们要的倒数第n个节点了，我们直接用p-&gt;next=p-&gt;next-&gt;next跳过他就好，最后返回o-&gt;next（o-&gt;next指向的是修改好的链表）。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode *p,*q,*o;        p&#x3D;(ListNode*)malloc(sizeof(ListNode));        p-&gt;next&#x3D;head;        q&#x3D;head;        o&#x3D;p;        while(n--)        &#123;            q&#x3D;q-&gt;next;        &#125;        while(q!&#x3D;NULL)        &#123;            q&#x3D;q-&gt;next;            p&#x3D;p-&gt;next;        &#125;        p-&gt;next&#x3D;p-&gt;next-&gt;next;        return o-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>准备一个数len维护最长序列的长度（初始化为0），字符串str计算各个位置上出发最高的子序列为多少。for遍历s，内部嵌套一个for，内部for拿来计算最长子序列，每次从当前遍历元素开始计算，遍历一个新的字符时，用find判断字符串str中有没有相同的字符，如果没有就把字符接到str上，如果有就跳出当前循环，把str的长度和len做对比，如果大于len就把str的长度赋给len，判断完之后要清空str以免造成误差。最后返回len。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        if(s.size()&#x3D;&#x3D;0)        &#123;            return 0;        &#125;        int len&#x3D;0;        string str;        int n&#x3D;s.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            for(int j&#x3D;i;j&lt;n;j++)            &#123;                string str1;                str1+&#x3D;s[j];                string::size_type idx &#x3D; str.find( str1 );                if(str.size()!&#x3D;0&amp;&amp;idx !&#x3D; string::npos)                &#123;                    break;                &#125;                else                &#123;                    str+&#x3D;str1;                &#125;            &#125;                        if(len&lt;str.size())            &#123;                len&#x3D;str.size();            &#125;            str.clear();        &#125;                return len;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h4><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p><p>换句话说，s1 的排列之一是 s2 的 子串 。</p><p>示例 1：</p><p>输入：s1 = “ab” s2 = “eidbaooo”<br>输出：true<br>解释：s2 包含 s1 的排列之一 (“ba”).</p><p>这题一开始觉得老恶心了，想着是把s1可能的排序都找一遍然后在s2里判断有没有相同的序列，后来发现不用这么麻烦，只要找s2里的字符串组成有没有和s1完全一样的就行（比如s1由一个c两个b组成，那只要在s2里也找一个由一个c两个b组成的字符串就行）。既然找成分那就要用上map容器了，准备两个map容器，一个s1map存字符串s1的组成情况，一个s2map存s2中子字符串的组成情况，先遍历一遍s1获得s1的组成情况并存在s1map里，然后开始遍历s2，在for里再嵌套一个for，每次从当前字符开始向前遍历s1.size()个位置，保存这段字符串的组成情况存在s2map里，然后判断s1map和s2map的组成情况是否相同，如果相同就返回true，如果不相同就清空s2map并直接进入下次循环。要是知道末尾也没能返回true就返回false。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool checkInclusion(string s1, string s2) &#123;        unordered_map&lt;char, int&gt;s1map;        unordered_map&lt;char, int&gt;s2map;        int n &#x3D; s1.size(), m &#x3D; s2.size();        for (int i &#x3D; 0; i &lt; n; i++)        &#123;            s1map[s1[i]]++;        &#125;        for (int i &#x3D; 0; i &lt; m; i++)        &#123;            for (int j &#x3D; i; j &lt; i+n; j++)            &#123;                if(j&gt;&#x3D;m)                &#123;                    break;                &#125;                s2map[s2[j]]++;            &#125;            for (int k &#x3D; 0; k &lt; n; k++)            &#123;                if (s2map[s1[k]] !&#x3D; s1map[s1[k]])                &#123;                    s2map.clear();                    break;                &#125;            &#125;            if (s2map.size() !&#x3D; 0)            &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-26每日刷题打卡</title>
      <link href="/2021/10/26/2021-10-26-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/26/2021-10-26-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-26每日刷题打卡"><a href="#2021-10-26每日刷题打卡" class="headerlink" title="2021-10-26每日刷题打卡"></a>2021-10-26每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p><p>这题有两个方法，第一种节省空间但速度慢，第二种速度快但占用空间较多</p><p>第一种：创建一个vector容器v来存放结果，直接for遍历nums1，里面再放上一个for用来遍历nums2，每次遍历nums1新的元素时去nums2里找到和当前nums1相同的元素，找到以后继续遍历，如果有大于它的数就把那个数插入v中并break结束循环，如果没有大于他的数就插入一个-1。当nums1遍历完后结束循环，返回v即可</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;int&gt;v;        int n&#x3D;nums1.size(),m&#x3D;nums2.size();        bool b&#x3D;false;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            for(int j&#x3D;0;j&lt;m;j++)            &#123;                if(b&amp;&amp;nums2[j]&gt;nums1[i])                &#123;                    v.push_back(nums2[j]);                    break;                &#125;                if(nums1[i]&#x3D;&#x3D;nums2[j])                &#123;                    b&#x3D;true;                &#125;            &#125;            b&#x3D;false;            if(v.size()&#x3D;&#x3D;i)            &#123;                v.push_back(-1);            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种：要用上map、stack的知识，准备一个unordered_map容器mymap，一个stack容器sta，一个vector容器v。先遍历nums2，从最后一个元素开始遍历，每次遍历判断栈sta顶部元素是否小于当前元素，如果小于就持续出栈，知道栈为空或顶端元素大于当前遍历元素，然后mymap开始记录当前元素之后有无最大值，mymap[nums2[i]]==sta.empty?-1:sta.top()，这里意思是，如果栈为空，说明我们之前遍历过的元素没有大于当前元素的（因为都在前面出栈弹掉了），如果栈不为空，就说明栈顶元素是大于我们当前元素的，把这个元素赋给mymap，事后要将当前元素入栈。遍历完后开始遍历nums1，每次经由mymap[nums[i]]获知当前元素之后有没有大于它的元素。把结果插入v中。最后返回v</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_map&lt;int,int&gt;mymap;        stack&lt;int&gt;sta;        vector&lt;int&gt;v;        int n&#x3D;nums1.size();        for(int i&#x3D;nums2.size()-1;i&gt;&#x3D;0;i--)        &#123;            int num &#x3D; nums2[i];            while(!sta.empty()&amp;&amp;sta.top()&lt;num)            &#123;                sta.pop();            &#125;            mymap[num]&#x3D;sta.empty()?-1:sta.top();            sta.push(num);        &#125;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            v.push_back(mymap[nums1[i]]);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h4><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>进阶：</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</p><p>示例 1:</p><p>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p><p>原本试了下看看能不能把O(1)的算法写出来，结果超时了。。。我还是写简单的吧</p><p>准备一个vector容器v，遍历一遍nums，每次在v的（i+k)%nums.size() 位置上放上nums[i]的值（%nums.size()是为了防止数组越界，同时把旋转后的数插入v前面的位置上。)，但由于这里没有返回值，是要修改nums里的值，所以我们遍历一遍v把值复制给nums。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        int n&#x3D;nums.size();        vector&lt;int&gt;v(n);        for(int i&#x3D;0;i&lt;n;i++)        &#123;            v[(i+k)%n]&#x3D;nums[i];        &#125;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            nums[i]&#x3D;v[i];        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个方法，利用队列queue来进行旋转操作（出队后入队）。准备一个queue容器que，将nums从尾部数据开始依次入队que（先进先出），然后把队头元素出队再入队，一个进行k次，之后队列里的位置就是旋转好的序列了，再把que的数据复制在nums里即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        queue&lt;int&gt;que;        int n &#x3D; nums.size();        int m &#x3D; k % n;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            que.push(nums[i]);        &#125;        while(m--)        &#123;            int num&#x3D;que.front();            que.pop();            que.push(num);        &#125;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            nums[i]&#x3D;que.front();            que.pop();        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h4><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>尽量减少不知道咋减少。。。嘛反正是没用额外的数组。</p><p>准备两个指针l和r，初始都为0，用两个指针来遍历nums，当l或r大于等于nums.size()时结束循环，如果l当前指向的位置数不为0，则l和r同时++，如果l指向的位置数为0，则r往前移动，直到nums[r]不为0，然后交换l和r位置上的元素（这里要注意r可能会超出nums.size()，所以要加判断如果r大于等于nums.size()就结束循环）。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;    int l &#x3D; 0, r &#x3D; 0, n &#x3D; nums.size();    while (r &lt; n)    &#123;        if (nums[l] !&#x3D; 0)        &#123;            l++;            r++;        &#125;        else        &#123;            while (r &lt; n&amp;&amp;nums[r] &#x3D;&#x3D; 0 )            &#123;                r++;                            &#125;            if (r &gt;&#x3D; n)            &#123;                break;            &#125;            int math &#x3D; nums[l];            nums[l] &#x3D; nums[r];            nums[r] &#x3D; math;        &#125;    &#125;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照 非递减顺序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p><p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p><p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p><p>示例 1：</p><p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p><p>双指针写法，因为这数组是递增的，所以我们可以用头尾双指针来写，一个left=0，一个right=numbers.size()-1，一个vector容器v，开始遍历，每次判断numbers[left]+numbers[right]的值，如果等于目标值就把left和right插入v中，break掉循环并返回v。如果大于目标值，说明number[right]的值过大（总不能是left太大，人家已经最小了），把right–以减小numbers[right]的值。如果小于目标值说明numbers[left]的值过下，把left++。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;        int i&#x3D;0,j&#x3D;numbers.size()-1;        vector&lt;int&gt;v;       while(i&lt;j)       &#123;           if(numbers[i]+numbers[j]&#x3D;&#x3D;target)           &#123;               v.push_back(i+1);               v.push_back(j+1);               break;           &#125;           else if(numbers[i]+numbers[j]&gt;target)           &#123;               j--;           &#125;           else           &#123;               i++;           &#125;       &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/25/hello-world/"/>
      <url>/2021/10/25/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到我的个人网站！"><a href="#欢迎来到我的个人网站！" class="headerlink" title="欢迎来到我的个人网站！"></a>欢迎来到我的个人网站！</h1>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HelloWorld </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
