<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021-10-30每日刷题打卡</title>
      <link href="/2021/10/30/2021-10-30-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/30/2021-10-30-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-30每日刷题打卡"><a href="#2021-10-30每日刷题打卡" class="headerlink" title="2021-10-30每日刷题打卡"></a>2021-10-30每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h4><p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p><p>进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p><p>示例 1：</p><p>输入：nums = [1,2,1,3,2,5]<br>输出：[3,5]<br>解释：[5, 3] 也是有效的答案。</p><p>用哈希计数，准备一个unordered_map容器mymap，遍历nums，用mymap计算每个数字出现的次数。最后从mymap里找到出现次数为1的两个数，返回即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int,int&gt;mymap;        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            mymap[nums[i]]++;        &#125;        vector&lt;int&gt;v;        for(auto i:mymap)        &#123;            if(i.second&#x3D;&#x3D;1)            &#123;                v.push_back(i.first);            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进阶——常数空间：就准备一个vector容器v来存结果的两个数，对nums排序，遍历nums，每次判断当前数是否和下一个数相同，如果不相同就把数插入v中，如果相同就持续遍历，直到不相同为止。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        vector&lt;int&gt;v;        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            if(i+1&gt;&#x3D;n&amp;&amp;v.size()&lt;&#x3D;1)            &#123;                v.push_back(nums[i]);            &#125;            else            &#123;                if(nums[i]!&#x3D;nums[i+1])                &#123;                    v.push_back(nums[i]);                       if(v.size()&#x3D;&#x3D;2)                    &#123;                        break;                    &#125;                                                                &#125;                else                &#123;                    int num&#x3D;nums[i];                    while(nums[i]&#x3D;&#x3D;num)                    &#123;                        i++;                    &#125;                    i--;                &#125;            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/789/">787. 归并排序 - AcWing题库</a></p><p>给定你一个长度为 n 的整数数列。</p><p>请你使用归并排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">53 1 2 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>归并排序也是分治的思想，把一串数组对半分，直到分成一个个数，在把数两个两个的组合成有序对数。比如我们把6 2 4 5 3 1这个数组进行排序，最终分成6和2和4和5和3和1这六个数组，然后两两组合成2 6、4 5、3 1，（组合的方式是，拿一个数组tmp来存，把两个目标数组里的数进行比较，每次挑小的那个放入tmp中即可），再组合成2 4 5 6、3 1，再组合就成了1 2 3 4 5 6，这就是归并排序，即分治后归并。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;1e6+5;int n;int nums[N],tmp[N];void merge_sort(int nums[],int l,int r)&#123;    if(l&gt;&#x3D;r)return;    int mid&#x3D;(l+r)&#x2F;2;    merge_sort(nums,l,mid);    merge_sort(nums,mid+1,r);    int k&#x3D;0,i&#x3D;l,j&#x3D;mid+1;    while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;r)    &#123;        if(nums[i]&lt;&#x3D;nums[j])tmp[k++]&#x3D;nums[i++];        else tmp[k++]&#x3D;nums[j++];    &#125;    while(i&lt;&#x3D;mid)tmp[k++]&#x3D;nums[i++];    while(j&lt;&#x3D;r)tmp[k++]&#x3D;nums[j++];        for(i&#x3D;l,j&#x3D;0;i&lt;&#x3D;r;i++,j++)        nums[i]&#x3D;tmp[j];&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;nums[i]);    merge_sort(nums,0,n-1);    for(int i&#x3D;0;i&lt;n;i++)printf(&quot;%d &quot;,nums[i]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-29每日刷题打卡</title>
      <link href="/2021/10/29/2021-10-29-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/29/2021-10-29-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-29每日刷题打卡"><a href="#2021-10-29每日刷题打卡" class="headerlink" title="2021-10-29每日刷题打卡"></a>2021-10-29每日刷题打卡</h1><h2 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h2><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/woGGnF/">间隔删除链表结点 - 力扣 (LeetCode) 竞赛 (leetcode-cn.com)</a></p><p>给你一个链表的头结点 <code>head</code>，每隔一个结点删除另一个结点（要求保留头结点）。<br>请返回最终链表的头结点。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>head = [1,2,3,4]</code></p><p>输出: <code>[1,3]</code></p><p>解释：<br>蓝色结点为删除的结点</p><p>  <img src="https://pic.leetcode-cn.com/1622545030-DwtsVD-image.png" alt="08"></p></blockquote><p>开头写一个指针指向head，用这个指针遍历，一次遍历跳过当前节点，一次遍历直接往下走没有多余操作。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* deleteListNode(ListNode* head) &#123;        ListNode*p,*q;        p&#x3D;head;        q&#x3D;(ListNode*)malloc(sizeof(ListNode));        q-&gt;next&#x3D;p;        int i&#x3D;1;        while(p!&#x3D;NULL&amp;&amp;p-&gt;next!&#x3D;NULL)        &#123;            if(i&#x3D;&#x3D;1)            &#123;                i&#x3D;0;                p-&gt;next&#x3D;p-&gt;next-&gt;next;            &#125;            else            &#123;                i++;                p&#x3D;p-&gt;next;            &#125;        &#125;        return q-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/9Rs2aO/">柱状图分析 - 力扣 (LeetCode) 竞赛 (leetcode-cn.com)</a></p><p>某柱状图上共有 N 个柱形，数组 <code>heights</code> 中按照排列顺序记录了每个柱形的高度。假定任选 <code>cnt</code> 个柱形可组成一个柱形组，请在所有可能的柱形组中，找出最大高度与最小高度的差值为最小的柱形组，按高度升序返回该柱形组。若存在多个柱形组满足条件，则返回第一个元素最小的柱形组。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>heights = [3,2,7,6,1,8], cnt = 3</code></p><p>输出：<code>[1,2,3]</code></p><p>解释：[1,2,3] 与 [6,7,8] 都符合在所有的柱形组中，最大高度与最小高度的差值为最小的条件，选择第一个元素最小的 [1,2,3] 返回。</p></blockquote><p>先对heights进行排序，然后用长度为cnt的滑动窗口持续找。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; analysisHistogram(vector&lt;int&gt;&amp; heights, int cnt) &#123;        sort(heights.begin(),heights.end());        vector&lt;int&gt;v;        int min&#x3D;1000000,n;        for(int i&#x3D;0;i&lt;&#x3D;heights.size()-cnt;i++)            &#123;            int num&#x3D;heights[cnt+i-1]-heights[i];            if(num&lt;min)                &#123;                n&#x3D;i;                min&#x3D;num;            &#125;        &#125;        for(int i&#x3D;n;i&lt;n+cnt;i++)            &#123;            v.push_back(heights[i]);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-28每日刷题打卡</title>
      <link href="/2021/10/28/2021-10-28-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/28/2021-10-28-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-28每日刷题打卡"><a href="#2021-10-28每日刷题打卡" class="headerlink" title="2021-10-28每日刷题打卡"></a>2021-10-28每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="869-重新排序得到-2-的幂"><a href="#869-重新排序得到-2-的幂" class="headerlink" title="869. 重新排序得到 2 的幂"></a><a href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></h4><p>给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p><p>如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。</p><p>示例 1：</p><p>输入：1<br>输出：true</p><p>说是通过排序来判断能不能组成2的幂数那就不用管啥顺序了，直接判断这个数的组成就行（比如16就是1个1和1个6组成）。 先是看到2的幂，一看到条件数最大也就10^9,那就直接整个蠢方法，拿个字符串数组把小于10^9的2的幂全存进去（包括1）。再准备两个map容器，第一个拿来存所给数的组成成分，遍历我们的字符串数组，就找size和所给数位数相等的元素就行，遍历到后用第二个map容器来统计这个字符串的所给成分，之后拿两个map容器做对比，如果相同就可以返回true，如果不相等就把第二个map清空开始找下一个字符串。要是遍历完后还没能返回true那就返回false。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool reorderedPowerOf2(int n) &#123;        string math[]&#x3D;&#123;&quot;1&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;16&quot;,&quot;32&quot;,&quot;64&quot;,&quot;128&quot;,&quot;256&quot;,&quot;512&quot;,&quot;1024&quot;,&quot;2048&quot;,&quot;4096&quot;,                       &quot;8192&quot;,&quot;16384&quot;,&quot;32768&quot;,&quot;65536&quot;,&quot;131072&quot;,&quot;262144&quot;,&quot;524288&quot;,&quot;1048576&quot;,                       &quot;2097152&quot;,&quot;4194304&quot;,&quot;8388608&quot;,&quot;16777216&quot;,&quot;33554432&quot;,&quot;67108864&quot;,&quot;134217728&quot;,                       &quot;268435456&quot;,&quot;536870912&quot;&#125;;        string num;        vector&lt;int&gt;v;        unordered_map&lt;char,int&gt;num_map;        unordered_map&lt;char,int&gt;math_map;        while(n!&#x3D;0)        &#123;            v.push_back(n%10);            n&#x2F;&#x3D;10;        &#125;        int m&#x3D;v.size();        for(int i&#x3D;m-1;i&gt;&#x3D;0;i--)        &#123;            num+&#x3D;v[i]+48;        &#125;        for(int i&#x3D;0;i&lt;m;i++)        &#123;            num_map[num[i]]++;        &#125;        for(int i&#x3D;0;i&lt;30;i++)        &#123;            if(math[i].size()&#x3D;&#x3D;m)            &#123;                for(int j&#x3D;0;j&lt;m;j++)                &#123;                    math_map[math[i][j]]++;                &#125;                for(int i&#x3D;0;i&lt;m;i++)                &#123;                    if(math_map[num[i]]!&#x3D;num_map[num[i]])                    &#123;                        math_map.clear();                        break;                    &#125;                &#125;                if(math_map.size()!&#x3D;0)                &#123;                    return true;                &#125;            &#125;            else if(math[i].size()&gt;m)            &#123;                break;            &#125;        &#125;        return false;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ACWing——算法基础"><a href="#ACWing——算法基础" class="headerlink" title="ACWing——算法基础"></a>ACWing——算法基础</h2><p><a href="https://www.acwing.com/problem/content/787/">785. 快速排序 - AcWing题库</a></p><p>给定你一个长度为 nn 的整数数列。</p><p>请你使用快速排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">53 1 2 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要用到分治的思想，即把数组分成一部分一部分的来解决。比如4 1 3 2 5，我们先取一个中间值x，随便取，这里我们取2，然后把数组分成两截，大于等于x的放在数组右边，小于等于的我们放在左边。（放的方法我们可以用双指针，一个l在最左边（找大于等于x的值），一个r在最右边（找小于等于x的值），开始遍历，l遍历到4的时候，因为大于x所以就不往前走了，到r走，r走到5，大于x，继续走，走到2小于x了，停下来，然后做个判断，如果l&lt;j，那就把两者的数据交换一下，这样数组就变成了2 1 3 4 5，两个指针继续走，当l&gt;j时结束循环，这样大于等于2的数都在右边了，小于等于2的数都在左边），然后我们把左边的数组继续送去如上操作，右边也是，知道数组里只有一个元素为止。这就是分治——分成一个个小的解决。当一切分完后，排序也排好了。时间复杂度为nlogn，如果被数据针对会变成n^2.</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1e6 + 10;int n;int nums[N];void quick_sort(int nums[], int l, int r)&#123;    if (l &gt;&#x3D; r)return;    int x &#x3D; nums[(l+r)&#x2F;2], i &#x3D; l-1, j &#x3D; r+1 ;    while (i &lt; j)    &#123;        do i++;while(nums[i]&lt;x);        do j--;while(nums[j]&gt;x);        if (i &lt; j)swap(nums[i], nums[j]);    &#125;    quick_sort(nums, l, j);    quick_sort(nums, j + 1, r);&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i &#x3D; 0; i &lt; n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);    &#125;    quick_sort(nums, 0, n - 1);    for (int i &#x3D; 0; i &lt; n; i++)    &#123;        printf(&quot;%d &quot;, nums[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/788/">786. 第k个数 - AcWing题库</a></p><p>给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 kk 个数。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 k。</p><p>第二行包含 n 个整数（所有整数均在 1∼10^9 范围内），表示整数数列。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示数列的第 k 小数。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>1≤k≤n</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">5 32 4 1 5 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这就是上面的题，为了加深上面的印象，只不过这里不是输出数组，而是输出数组索引为k-1的那个元素。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N&#x3D;1e6+10;int n;int k;int nums[N];void quick_sort(int nums[],int l,int r)&#123;    if(l&gt;&#x3D;r)return ;    int x&#x3D;nums[(l+r)&#x2F;2],i&#x3D;l-1,j&#x3D;r+1;    while(i&lt;j)    &#123;        do        &#123;            i++;        &#125;while(nums[i]&lt;x);        do        &#123;            j--;        &#125;while(nums[j]&gt;x);        if(i&lt;j) swap(nums[i],nums[j]);    &#125;    quick_sort(nums,l,j);    quick_sort(nums,j+1,r);&#125;int main()&#123;    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);    for(int i&#x3D;0;i&lt;n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;nums[i]);    &#125;    quick_sort(nums,0,n-1);    cout&lt;&lt;nums[k-1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
            <tag> y总算法课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-27每日刷题打卡</title>
      <link href="/2021/10/27/2021-10-27-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/27/2021-10-27-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-27每日刷题打卡"><a href="#2021-10-27每日刷题打卡" class="headerlink" title="2021-10-27每日刷题打卡"></a>2021-10-27每日刷题打卡</h1><h2 id="力扣——算法入门"><a href="#力扣——算法入门" class="headerlink" title="力扣——算法入门"></a>力扣——算法入门</h2><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a></h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>示例 1：</p><p>输入：s = [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>简简单单的双指针</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int left&#x3D;0,right&#x3D;s.size()-1;        while(left&lt;right)        &#123;            char c&#x3D;s[left];            s[left]&#x3D;s[right];            s[right]&#x3D;c;            left++;            right--;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></h4><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p>示例：</p><p>输入：”Let’s take LeetCode contest”<br>输出：”s’teL ekat edoCteeL tsetnoc”</p><p>用上快慢指针，一个慢指针left，一个快指针right，初始都指向0，开始遍历，当right&gt;=s.size()时结束循环。每次遍历时判断s[left]是否是空格，如果是，left和right都++；如果不是空格，则right先走，走到right的下一个为空格时停下（因为结尾处没空格，所以要加个判断right&lt;n，防止越界报错），然后left和right开始呼唤元素，换完后两个指针去往之前right停下的位置，继续下一次遍历。最后返回s。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    string reverseWords(string s) &#123;        int left&#x3D;0,right&#x3D;0,n&#x3D;s.size();        while(right&lt;n)        &#123;            if(s[left]&#x3D;&#x3D;&#39; &#39;)            &#123;                left++;                right++;            &#125;            else            &#123;                while(right+1&lt;n&amp;&amp;s[right+1]!&#x3D;&#39; &#39;)                &#123;                    right++;                &#125;                int m&#x3D;right+1;                while(left&lt;right)                &#123;                    char c&#x3D;s[left];                    s[left]&#x3D;s[right];                    s[right]&#x3D;c;                    left++;                    right--;                &#125;                left&#x3D;m;                right&#x3D;m;            &#125;        &#125;        return s;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：</p><p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p><p>还是用快慢指针走，准备两个指针，一个p一个q，初始都指向head，开始遍历，当q为空或q的next为空时结束遍历。每次p走一格，q走两格，这也p的位置就始终在q与头结点的位置的中间处，那么当q走到末尾时，p自然就为链表的中间结点了。遍历结束后返回p即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        ListNode*p,*q;        p&#x3D;head;        q&#x3D;head;        while(q!&#x3D;NULL&amp;&amp;q-&gt;next!&#x3D;NULL)        &#123;            p&#x3D;p-&gt;next;            q&#x3D;q-&gt;next;            q&#x3D;q-&gt;next;        &#125;        return p;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="image-20211027090622223"></p><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p><p>继续快慢指针,准备三个指针p,q,o，p-&gt;next指向head，o指向p，q指向head。q做快指针先走，走n格之后q和p一起走，当q为NULL时，p-&gt;next就是我们要的倒数第n个节点了，我们直接用p-&gt;next=p-&gt;next-&gt;next跳过他就好，最后返回o-&gt;next（o-&gt;next指向的是修改好的链表）。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode *p,*q,*o;        p&#x3D;(ListNode*)malloc(sizeof(ListNode));        p-&gt;next&#x3D;head;        q&#x3D;head;        o&#x3D;p;        while(n--)        &#123;            q&#x3D;q-&gt;next;        &#125;        while(q!&#x3D;NULL)        &#123;            q&#x3D;q-&gt;next;            p&#x3D;p-&gt;next;        &#125;        p-&gt;next&#x3D;p-&gt;next-&gt;next;        return o-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>准备一个数len维护最长序列的长度（初始化为0），字符串str计算各个位置上出发最高的子序列为多少。for遍历s，内部嵌套一个for，内部for拿来计算最长子序列，每次从当前遍历元素开始计算，遍历一个新的字符时，用find判断字符串str中有没有相同的字符，如果没有就把字符接到str上，如果有就跳出当前循环，把str的长度和len做对比，如果大于len就把str的长度赋给len，判断完之后要清空str以免造成误差。最后返回len。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        if(s.size()&#x3D;&#x3D;0)        &#123;            return 0;        &#125;        int len&#x3D;0;        string str;        int n&#x3D;s.size();        for(int i&#x3D;0;i&lt;n;i++)        &#123;            for(int j&#x3D;i;j&lt;n;j++)            &#123;                string str1;                str1+&#x3D;s[j];                string::size_type idx &#x3D; str.find( str1 );                if(str.size()!&#x3D;0&amp;&amp;idx !&#x3D; string::npos)                &#123;                    break;                &#125;                else                &#123;                    str+&#x3D;str1;                &#125;            &#125;                        if(len&lt;str.size())            &#123;                len&#x3D;str.size();            &#125;            str.clear();        &#125;                return len;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h4><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p><p>换句话说，s1 的排列之一是 s2 的 子串 。</p><p>示例 1：</p><p>输入：s1 = “ab” s2 = “eidbaooo”<br>输出：true<br>解释：s2 包含 s1 的排列之一 (“ba”).</p><p>这题一开始觉得老恶心了，想着是把s1可能的排序都找一遍然后在s2里判断有没有相同的序列，后来发现不用这么麻烦，只要找s2里的字符串组成有没有和s1完全一样的就行（比如s1由一个c两个b组成，那只要在s2里也找一个由一个c两个b组成的字符串就行）。既然找成分那就要用上map容器了，准备两个map容器，一个s1map存字符串s1的组成情况，一个s2map存s2中子字符串的组成情况，先遍历一遍s1获得s1的组成情况并存在s1map里，然后开始遍历s2，在for里再嵌套一个for，每次从当前字符开始向前遍历s1.size()个位置，保存这段字符串的组成情况存在s2map里，然后判断s1map和s2map的组成情况是否相同，如果相同就返回true，如果不相同就清空s2map并直接进入下次循环。要是知道末尾也没能返回true就返回false。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool checkInclusion(string s1, string s2) &#123;        unordered_map&lt;char, int&gt;s1map;        unordered_map&lt;char, int&gt;s2map;        int n &#x3D; s1.size(), m &#x3D; s2.size();        for (int i &#x3D; 0; i &lt; n; i++)        &#123;            s1map[s1[i]]++;        &#125;        for (int i &#x3D; 0; i &lt; m; i++)        &#123;            for (int j &#x3D; i; j &lt; i+n; j++)            &#123;                if(j&gt;&#x3D;m)                &#123;                    break;                &#125;                s2map[s2[j]]++;            &#125;            for (int k &#x3D; 0; k &lt; n; k++)            &#123;                if (s2map[s1[k]] !&#x3D; s1map[s1[k]])                &#123;                    s2map.clear();                    break;                &#125;            &#125;            if (s2map.size() !&#x3D; 0)            &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-26每日刷题打卡</title>
      <link href="/2021/10/26/2021-10-26-mei-ri-shua-ti-da-qia/"/>
      <url>/2021/10/26/2021-10-26-mei-ri-shua-ti-da-qia/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-26每日刷题打卡"><a href="#2021-10-26每日刷题打卡" class="headerlink" title="2021-10-26每日刷题打卡"></a>2021-10-26每日刷题打卡</h1><h2 id="力扣——每日一题"><a href="#力扣——每日一题" class="headerlink" title="力扣——每日一题"></a>力扣——每日一题</h2><h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p><p>这题有两个方法，第一种节省空间但速度慢，第二种速度快但占用空间较多</p><p>第一种：创建一个vector容器v来存放结果，直接for遍历nums1，里面再放上一个for用来遍历nums2，每次遍历nums1新的元素时去nums2里找到和当前nums1相同的元素，找到以后继续遍历，如果有大于它的数就把那个数插入v中并break结束循环，如果没有大于他的数就插入一个-1。当nums1遍历完后结束循环，返回v即可</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;int&gt;v;        int n&#x3D;nums1.size(),m&#x3D;nums2.size();        bool b&#x3D;false;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            for(int j&#x3D;0;j&lt;m;j++)            &#123;                if(b&amp;&amp;nums2[j]&gt;nums1[i])                &#123;                    v.push_back(nums2[j]);                    break;                &#125;                if(nums1[i]&#x3D;&#x3D;nums2[j])                &#123;                    b&#x3D;true;                &#125;            &#125;            b&#x3D;false;            if(v.size()&#x3D;&#x3D;i)            &#123;                v.push_back(-1);            &#125;        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种：要用上map、stack的知识，准备一个unordered_map容器mymap，一个stack容器sta，一个vector容器v。先遍历nums2，从最后一个元素开始遍历，每次遍历判断栈sta顶部元素是否小于当前元素，如果小于就持续出栈，知道栈为空或顶端元素大于当前遍历元素，然后mymap开始记录当前元素之后有无最大值，mymap[nums2[i]]==sta.empty?-1:sta.top()，这里意思是，如果栈为空，说明我们之前遍历过的元素没有大于当前元素的（因为都在前面出栈弹掉了），如果栈不为空，就说明栈顶元素是大于我们当前元素的，把这个元素赋给mymap，事后要将当前元素入栈。遍历完后开始遍历nums1，每次经由mymap[nums[i]]获知当前元素之后有没有大于它的元素。把结果插入v中。最后返回v</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_map&lt;int,int&gt;mymap;        stack&lt;int&gt;sta;        vector&lt;int&gt;v;        int n&#x3D;nums1.size();        for(int i&#x3D;nums2.size()-1;i&gt;&#x3D;0;i--)        &#123;            int num &#x3D; nums2[i];            while(!sta.empty()&amp;&amp;sta.top()&lt;num)            &#123;                sta.pop();            &#125;            mymap[num]&#x3D;sta.empty()?-1:sta.top();            sta.push(num);        &#125;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            v.push_back(mymap[nums1[i]]);        &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h4><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>进阶：</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</p><p>示例 1:</p><p>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p><p>原本试了下看看能不能把O(1)的算法写出来，结果超时了。。。我还是写简单的吧</p><p>准备一个vector容器v，遍历一遍nums，每次在v的（i+k)%nums.size() 位置上放上nums[i]的值（%nums.size()是为了防止数组越界，同时把旋转后的数插入v前面的位置上。)，但由于这里没有返回值，是要修改nums里的值，所以我们遍历一遍v把值复制给nums。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        int n&#x3D;nums.size();        vector&lt;int&gt;v(n);        for(int i&#x3D;0;i&lt;n;i++)        &#123;            v[(i+k)%n]&#x3D;nums[i];        &#125;        for(int i&#x3D;0;i&lt;n;i++)        &#123;            nums[i]&#x3D;v[i];        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个方法，利用队列queue来进行旋转操作（出队后入队）。准备一个queue容器que，将nums从尾部数据开始依次入队que（先进先出），然后把队头元素出队再入队，一个进行k次，之后队列里的位置就是旋转好的序列了，再把que的数据复制在nums里即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;        queue&lt;int&gt;que;        int n &#x3D; nums.size();        int m &#x3D; k % n;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            que.push(nums[i]);        &#125;        while(m--)        &#123;            int num&#x3D;que.front();            que.pop();            que.push(num);        &#125;        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)        &#123;            nums[i]&#x3D;que.front();            que.pop();        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h4><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>尽量减少不知道咋减少。。。嘛反正是没用额外的数组。</p><p>准备两个指针l和r，初始都为0，用两个指针来遍历nums，当l或r大于等于nums.size()时结束循环，如果l当前指向的位置数不为0，则l和r同时++，如果l指向的位置数为0，则r往前移动，直到nums[r]不为0，然后交换l和r位置上的元素（这里要注意r可能会超出nums.size()，所以要加判断如果r大于等于nums.size()就结束循环）。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;    int l &#x3D; 0, r &#x3D; 0, n &#x3D; nums.size();    while (r &lt; n)    &#123;        if (nums[l] !&#x3D; 0)        &#123;            l++;            r++;        &#125;        else        &#123;            while (r &lt; n&amp;&amp;nums[r] &#x3D;&#x3D; 0 )            &#123;                r++;                            &#125;            if (r &gt;&#x3D; n)            &#123;                break;            &#125;            int math &#x3D; nums[l];            nums[l] &#x3D; nums[r];            nums[r] &#x3D; math;        &#125;    &#125;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照 非递减顺序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p><p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p><p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p><p>示例 1：</p><p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p><p>双指针写法，因为这数组是递增的，所以我们可以用头尾双指针来写，一个left=0，一个right=numbers.size()-1，一个vector容器v，开始遍历，每次判断numbers[left]+numbers[right]的值，如果等于目标值就把left和right插入v中，break掉循环并返回v。如果大于目标值，说明number[right]的值过大（总不能是left太大，人家已经最小了），把right–以减小numbers[right]的值。如果小于目标值说明numbers[left]的值过下，把left++。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;        int i&#x3D;0,j&#x3D;numbers.size()-1;        vector&lt;int&gt;v;       while(i&lt;j)       &#123;           if(numbers[i]+numbers[j]&#x3D;&#x3D;target)           &#123;               v.push_back(i+1);               v.push_back(j+1);               break;           &#125;           else if(numbers[i]+numbers[j]&gt;target)           &#123;               j--;           &#125;           else           &#123;               i++;           &#125;       &#125;        return v;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日打卡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日打卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/25/hello-world/"/>
      <url>/2021/10/25/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到我的个人网站！"><a href="#欢迎来到我的个人网站！" class="headerlink" title="欢迎来到我的个人网站！"></a>欢迎来到我的个人网站！</h1>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HelloWorld </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
